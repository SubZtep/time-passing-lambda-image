var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS((exports2, module2) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  module2.exports = _interopRequireDefault;
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports2, module2) => {
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module2.exports = _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      module2.exports = _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  module2.exports = _typeof;
});

// node_modules/@babel/runtime/helpers/interopRequireWildcard.js
var require_interopRequireWildcard = __commonJS((exports2, module2) => {
  var _typeof = require_typeof();
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  module2.exports = _interopRequireWildcard;
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS((exports2, module2) => {
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  module2.exports = _arrayLikeToArray;
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS((exports2, module2) => {
  var arrayLikeToArray = require_arrayLikeToArray();
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return arrayLikeToArray(arr);
  }
  module2.exports = _arrayWithoutHoles;
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS((exports2, module2) => {
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  module2.exports = _iterableToArray;
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS((exports2, module2) => {
  var arrayLikeToArray = require_arrayLikeToArray();
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
  module2.exports = _unsupportedIterableToArray;
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS((exports2, module2) => {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableSpread;
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS((exports2, module2) => {
  var arrayWithoutHoles = require_arrayWithoutHoles();
  var iterableToArray = require_iterableToArray();
  var unsupportedIterableToArray = require_unsupportedIterableToArray();
  var nonIterableSpread = require_nonIterableSpread();
  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }
  module2.exports = _toConsumableArray;
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS((exports2, module2) => {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module2.exports = _defineProperty;
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS((exports2, module2) => {
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  module2.exports = _arrayWithHoles;
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS((exports2, module2) => {
  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  module2.exports = _iterableToArrayLimit;
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS((exports2, module2) => {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableRest;
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS((exports2, module2) => {
  var arrayWithHoles = require_arrayWithHoles();
  var iterableToArrayLimit = require_iterableToArrayLimit();
  var unsupportedIterableToArray = require_unsupportedIterableToArray();
  var nonIterableRest = require_nonIterableRest();
  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }
  module2.exports = _slicedToArray;
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS((exports2, module2) => {
  function _setPrototypeOf(o, p) {
    module2.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  module2.exports = _setPrototypeOf;
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS((exports2, module2) => {
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  module2.exports = _isNativeReflectConstruct;
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS((exports2, module2) => {
  var setPrototypeOf = require_setPrototypeOf();
  var isNativeReflectConstruct = require_isNativeReflectConstruct();
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      module2.exports = _construct = Reflect.construct;
    } else {
      module2.exports = _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  module2.exports = _construct;
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS((exports2, module2) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  module2.exports = _classCallCheck;
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS((exports2, module2) => {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  module2.exports = _createClass;
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS((exports2, module2) => {
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  module2.exports = _assertThisInitialized;
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS((exports2, module2) => {
  var _typeof = require_typeof();
  var assertThisInitialized = require_assertThisInitialized();
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return assertThisInitialized(self2);
  }
  module2.exports = _possibleConstructorReturn;
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS((exports2, module2) => {
  function _getPrototypeOf(o) {
    module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  module2.exports = _getPrototypeOf;
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  var setPrototypeOf = require_setPrototypeOf();
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      setPrototypeOf(subClass, superClass);
  }
  module2.exports = _inherits;
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS((exports2, module2) => {
  var runtime = function(exports3) {
    "use strict";
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined2;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define2(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define2({}, "");
    } catch (err) {
      define2 = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context);
      return generator;
    }
    exports3.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return {type: "normal", arg: fn.call(obj, arg)};
      } catch (err) {
        return {type: "throw", arg: err};
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function() {
      return this;
    };
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define2(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports3.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports3.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define2(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports3.awrap = function(arg) {
      return {__await: arg};
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function() {
      return this;
    };
    exports3.AsyncIterator = AsyncIterator;
    exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined2) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined2;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define2(Gp, toStringTagSymbol, "Generator");
    Gp[iteratorSymbol] = function() {
      return this;
    };
    Gp.toString = function() {
      return "[object Generator]";
    };
    function pushTryEntry(locs) {
      var entry = {tryLoc: locs[0]};
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{tryLoc: "root"}];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports3.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined2;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return {next: doneResult};
    }
    exports3.values = values;
    function doneResult() {
      return {value: undefined2, done: true};
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined2;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined2;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined2;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined2;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      catch: function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined2;
        }
        return ContinueSentinel;
      }
    };
    return exports3;
  }(typeof module2 === "object" ? module2.exports : {});
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS((exports2, module2) => {
  module2.exports = require_runtime();
});

// node_modules/@jimp/utils/dist/index.js
var require_dist = __commonJS((exports2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isNodePattern = isNodePattern;
  exports2.throwError = throwError;
  exports2.scan = scan;
  exports2.scanIterator = scanIterator;
  var _regenerator = _interopRequireDefault(require_regenerator());
  var _marked = /* @__PURE__ */ _regenerator["default"].mark(scanIterator);
  function isNodePattern(cb) {
    if (typeof cb === "undefined") {
      return false;
    }
    if (typeof cb !== "function") {
      throw new TypeError("Callback must be a function");
    }
    return true;
  }
  function throwError(error, cb) {
    if (typeof error === "string") {
      error = new Error(error);
    }
    if (typeof cb === "function") {
      return cb.call(this, error);
    }
    throw error;
  }
  function scan(image, x, y, w, h, f) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    for (var _y = y; _y < y + h; _y++) {
      for (var _x = x; _x < x + w; _x++) {
        var idx = image.bitmap.width * _y + _x << 2;
        f.call(image, _x, _y, idx);
      }
    }
    return image;
  }
  function scanIterator(image, x, y, w, h) {
    var _y, _x, idx;
    return _regenerator["default"].wrap(function scanIterator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            x = Math.round(x);
            y = Math.round(y);
            w = Math.round(w);
            h = Math.round(h);
            _y = y;
          case 5:
            if (!(_y < y + h)) {
              _context.next = 17;
              break;
            }
            _x = x;
          case 7:
            if (!(_x < x + w)) {
              _context.next = 14;
              break;
            }
            idx = image.bitmap.width * _y + _x << 2;
            _context.next = 11;
            return {
              x: _x,
              y: _y,
              idx,
              image
            };
          case 11:
            _x++;
            _context.next = 7;
            break;
          case 14:
            _y++;
            _context.next = 5;
            break;
          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
});

// node_modules/any-base/src/converter.js
var require_converter = __commonJS((exports2, module2) => {
  "use strict";
  function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
      throw new Error("Bad alphabet");
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
  }
  Converter.prototype.convert = function(number) {
    var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
    if (!this.isValid(number)) {
      throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
    }
    if (this.srcAlphabet === this.dstAlphabet) {
      return number;
    }
    for (i = 0; i < length; i++) {
      numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
      divide = 0;
      newlen = 0;
      for (i = 0; i < length; i++) {
        divide = divide * fromBase + numberMap[i];
        if (divide >= toBase) {
          numberMap[newlen++] = parseInt(divide / toBase, 10);
          divide = divide % toBase;
        } else if (newlen > 0) {
          numberMap[newlen++] = 0;
        }
      }
      length = newlen;
      result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);
    return result;
  };
  Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
      if (this.srcAlphabet.indexOf(number[i]) === -1) {
        return false;
      }
    }
    return true;
  };
  module2.exports = Converter;
});

// node_modules/any-base/index.js
var require_any_base = __commonJS((exports2, module2) => {
  var Converter = require_converter();
  function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    return function(number) {
      return converter.convert(number);
    };
  }
  anyBase.BIN = "01";
  anyBase.OCT = "01234567";
  anyBase.DEC = "0123456789";
  anyBase.HEX = "0123456789abcdef";
  module2.exports = anyBase;
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  var _0777 = parseInt("0777", 8);
  module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    var cb = f || function() {
    };
    p = path.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path.dirname(p) === p)
            return cb(er);
          mkdirP(path.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/pixelmatch/index.js
var require_pixelmatch = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = pixelmatch;
  function pixelmatch(img1, img2, output, width, height, options) {
    if (!options)
      options = {};
    var threshold = options.threshold === void 0 ? 0.1 : options.threshold;
    var maxDelta = 35215 * threshold * threshold, diff = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var pos = (y * width + x) * 4;
        var delta = colorDelta(img1, img2, pos, pos);
        if (delta > maxDelta) {
          if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
            if (output)
              drawPixel(output, pos, 255, 255, 0);
          } else {
            if (output)
              drawPixel(output, pos, 255, 0, 0);
            diff++;
          }
        } else if (output) {
          var val = blend(grayPixel(img1, pos), 0.1);
          drawPixel(output, pos, val, val, val);
        }
      }
    }
    return diff;
  }
  function antialiased(img, x1, y1, width, height, img2) {
    var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, minX, minY, maxX, maxY;
    for (var x = x0; x <= x2; x++) {
      for (var y = y0; y <= y2; y++) {
        if (x === x1 && y === y1)
          continue;
        var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
        if (delta === 0)
          zeroes++;
        else if (delta < 0)
          negatives++;
        else if (delta > 0)
          positives++;
        if (zeroes > 2)
          return false;
        if (!img2)
          continue;
        if (delta < min) {
          min = delta;
          minX = x;
          minY = y;
        }
        if (delta > max) {
          max = delta;
          maxX = x;
          maxY = y;
        }
      }
    }
    if (!img2)
      return true;
    if (negatives === 0 || positives === 0)
      return false;
    return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);
  }
  function colorDelta(img1, img2, k, m, yOnly) {
    var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
    if (yOnly)
      return y;
    var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
    return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
  }
  function rgb2y(r, g, b) {
    return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
  }
  function rgb2i(r, g, b) {
    return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
  }
  function rgb2q(r, g, b) {
    return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
  }
  function blend(c, a) {
    return 255 + (c - 255) * a;
  }
  function drawPixel(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
  }
  function grayPixel(img, i) {
    var a = img[i + 3] / 255, r = blend(img[i + 0], a), g = blend(img[i + 1], a), b = blend(img[i + 2], a);
    return rgb2y(r, g, b);
  }
});

// node_modules/tinycolor2/tinycolor.js
var require_tinycolor = __commonJS((exports2, module2) => {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor) {
        return color;
      }
      if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return {h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a};
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return {h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a};
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return {r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a};
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return {r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a};
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s = tinycolor(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
        if (needsAlphaFormat) {
          if (format === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor(this.toString());
      },
      _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor.fromRatio = function(color, opts) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
          if (color.hasOwnProperty(i)) {
            if (i === "a") {
              newColor[i] = color[i];
            } else {
              newColor[i] = convertToPercentage(color[i]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor(color, opts);
    };
    function inputToRGB(color) {
      var rgb = {r: 0, g: 0, b: 0};
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a
      };
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, l = (max + min) / 2;
      if (max == min) {
        h = s = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {h, s, l};
    }
    function hslToRgb(h, s, l) {
      var r, g, b;
      h = bound01(h, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      function hue2rgb(p2, q2, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2)
          return q2;
        if (t < 2 / 3)
          return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        return p2;
      }
      if (s === 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return {r: r * 255, g: g * 255, b: b * 255};
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, v = max;
      var d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max == min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {h, s, v};
    }
    function hsvToRgb(h, s, v) {
      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
      return {r: r * 255, g: g * 255, b: b * 255};
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r, g, b, a) {
      var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];
      return hex.join("");
    }
    tinycolor.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
      return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function greyscale(color) {
      return tinycolor(color).desaturate(100);
    }
    function lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor(rgb);
    }
    function darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
    }
    function complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
    }
    function triad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({h: (h + 120) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({h: (h + 240) % 360, s: hsl.s, l: hsl.l})
      ];
    }
    function tetrad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({h: (h + 90) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({h: (h + 180) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({h: (h + 270) % 360, s: hsl.s, l: hsl.l})
      ];
    }
    function splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({h: (h + 216) % 360, s: hsl.s, l: hsl.l})
      ];
    }
    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
      }
      return ret;
    }
    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h = hsv.h, s = hsv.s, v = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor({h, s, v}));
        v = (v + modification) % 1;
      }
      return ret;
    }
    tinycolor.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return tinycolor(rgba);
    };
    tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i = 0; i < colorList.length; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor(colorList[i]);
        }
      }
      if (tinycolor.isReadable(baseColor, bestColor, {level, size}) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor.hexNames = flip(names);
    function flip(o) {
      var flipped = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          flipped[o[i]] = i;
        }
      }
      return flipped;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var processPercent = isPercentage(n);
      n = mathMin(max, mathMax(0, parseFloat(n)));
      if (processPercent) {
        n = parseInt(n * max, 10) / 100;
      }
      if (Math2.abs(n - max) < 1e-6) {
        return 1;
      }
      return n % max / parseFloat(max);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n) {
      return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") != -1;
    }
    function pad2(c) {
      return c.length == 1 ? "0" + c : "" + c;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        n = n * 100 + "%";
      }
      return n;
    }
    function convertDecimalToHex(d) {
      return Math2.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h) {
      return parseIntFromHex(h) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return {r: 0, g: 0, b: 0, a: 0, format: "name"};
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return {r: match[1], g: match[2], b: match[3]};
      }
      if (match = matchers.rgba.exec(color)) {
        return {r: match[1], g: match[2], b: match[3], a: match[4]};
      }
      if (match = matchers.hsl.exec(color)) {
        return {h: match[1], s: match[2], l: match[3]};
      }
      if (match = matchers.hsla.exec(color)) {
        return {h: match[1], s: match[2], l: match[3], a: match[4]};
      }
      if (match = matchers.hsv.exec(color)) {
        return {h: match[1], s: match[2], v: match[3]};
      }
      if (match = matchers.hsva.exec(color)) {
        return {h: match[1], s: match[2], v: match[3], a: match[4]};
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || {level: "AA", size: "small"};
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return {level, size};
    }
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = tinycolor;
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return tinycolor;
      });
    } else {
      window.tinycolor = tinycolor;
    }
  })(Math);
});

// node_modules/@jimp/core/dist/modules/phash.js
var require_phash = __commonJS((exports2, module2) => {
  "use strict";
  function ImagePHash(size, smallerSize) {
    this.size = this.size || size;
    this.smallerSize = this.smallerSize || smallerSize;
    initCoefficients(this.size);
  }
  ImagePHash.prototype.size = 32;
  ImagePHash.prototype.smallerSize = 8;
  ImagePHash.prototype.distance = function(s1, s2) {
    var counter = 0;
    for (var k = 0; k < s1.length; k++) {
      if (s1[k] !== s2[k]) {
        counter++;
      }
    }
    return counter / s1.length;
  };
  ImagePHash.prototype.getHash = function(img) {
    img = img.clone().resize(this.size, this.size);
    img.grayscale();
    var vals = [];
    for (var x = 0; x < img.bitmap.width; x++) {
      vals[x] = [];
      for (var y = 0; y < img.bitmap.height; y++) {
        vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
      }
    }
    var dctVals = applyDCT(vals, this.size);
    var total = 0;
    for (var _x = 0; _x < this.smallerSize; _x++) {
      for (var _y = 0; _y < this.smallerSize; _y++) {
        total += dctVals[_x][_y];
      }
    }
    var avg = total / (this.smallerSize * this.smallerSize);
    var hash = "";
    for (var _x2 = 0; _x2 < this.smallerSize; _x2++) {
      for (var _y2 = 0; _y2 < this.smallerSize; _y2++) {
        hash += dctVals[_x2][_y2] > avg ? "1" : "0";
      }
    }
    return hash;
  };
  function intToRGBA(i) {
    var rgba = {};
    rgba.r = Math.floor(i / Math.pow(256, 3));
    rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
    rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
    return rgba;
  }
  var c = [];
  function initCoefficients(size) {
    for (var i = 1; i < size; i++) {
      c[i] = 1;
    }
    c[0] = 1 / Math.sqrt(2);
  }
  function applyDCT(f, size) {
    var N = size;
    var F = [];
    for (var u = 0; u < N; u++) {
      F[u] = [];
      for (var v = 0; v < N; v++) {
        var sum = 0;
        for (var i = 0; i < N; i++) {
          for (var j = 0; j < N; j++) {
            sum += Math.cos((2 * i + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i][j];
          }
        }
        sum *= c[u] * c[v] / 4;
        F[u][v] = sum;
      }
    }
    return F;
  }
  module2.exports = ImagePHash;
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS((exports2, module2) => {
  function _extends() {
    module2.exports = _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  module2.exports = _extends;
});

// node_modules/phin/lib/phin.compiled.js
var require_phin_compiled = __commonJS((exports2, module2) => {
  "use strict";
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var http = require("http");
  var https = require("https");
  var url = require("url");
  var qs = require("querystring");
  var zlib = require("zlib");
  var util = require("util");
  var phin = function phin2(opts, cb) {
    if (typeof opts !== "string") {
      if (!opts.hasOwnProperty("url")) {
        throw new Error("Missing url option from options for request method.");
      }
    }
    var addr = (typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object" ? url.parse(opts.url) : url.parse(opts);
    var options = {hostname: addr.hostname, port: addr.port || (addr.protocol.toLowerCase() === "http:" ? 80 : 443), path: addr.path, method: "GET", headers: {}, auth: addr.auth || null, parse: "none", stream: false};
    if ((typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object") {
      options = Object.assign(options, opts);
    }
    options.port = Number(options.port);
    if (options.hasOwnProperty("timeout"))
      delete options.timeout;
    if (options.compressed === true) {
      options.headers["accept-encoding"] = "gzip, deflate";
    }
    if (opts.hasOwnProperty("form")) {
      if (_typeof(opts.form) !== "object") {
        throw new Error("phin 'form' option must be of type Object if present.");
      }
      var formDataString = qs.stringify(opts.form);
      options.headers["Content-Type"] = "application/x-www-form-urlencoded";
      options.headers["Content-Length"] = Buffer.byteLength(formDataString);
      opts.data = formDataString;
    }
    var req = void 0;
    var resHandler = function resHandler2(res) {
      var stream = res;
      if (options.compressed === true) {
        if (res.headers["content-encoding"] === "gzip") {
          stream = res.pipe(zlib.createGunzip());
        } else if (res.headers["content-encoding"] === "deflate") {
          stream = res.pipe(zlib.createInflate());
        }
      }
      if (options.stream === true) {
        res.stream = stream;
        if (cb)
          cb(null, res);
      } else {
        res.body = new Buffer([]);
        stream.on("data", function(chunk) {
          res.body = Buffer.concat([res.body, chunk]);
        });
        stream.on("end", function() {
          if (cb) {
            if (options.parse === "json") {
              try {
                res.body = JSON.parse(res.body.toString());
              } catch (err) {
                cb("Invalid JSON received.", res);
                return;
              }
            }
            cb(null, res);
          }
        });
      }
    };
    switch (addr.protocol.toLowerCase()) {
      case "http:":
        req = http.request(options, resHandler);
        break;
      case "https:":
        req = https.request(options, resHandler);
        break;
      default:
        if (cb)
          cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
        return;
    }
    if (typeof opts.timeout === "number") {
      req.setTimeout(opts.timeout, function() {
        req.abort();
        if (cb)
          cb(new Error("Timeout has been reached."), null);
        cb = null;
      });
    }
    req.on("error", function(err) {
      if (cb)
        cb(err, null);
    });
    if (opts.hasOwnProperty("data")) {
      var postData = opts.data;
      if (!(opts.data instanceof Buffer) && _typeof(opts.data) === "object") {
        var contentType = options.headers["content-type"] || options.headers["Content-Type"];
        if (contentType === "application/x-www-form-urlencoded") {
          postData = qs.stringify(opts.data);
        } else {
          try {
            postData = JSON.stringify(opts.data);
          } catch (err) {
            if (cb)
              cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
          }
        }
      }
      req.write(postData);
    }
    req.end();
  };
  phin.promisified = function(opts, http2) {
    return new Promise(function(resolve, reject) {
      phin(opts, function(err, res) {
        if (err) {
          reject(err);
        } else {
          resolve(res);
        }
      }, http2);
    });
  };
  if (util.promisify) {
    phin[util.promisify.custom] = phin.promisified;
  }
  module2.exports = phin;
});

// node_modules/@jimp/core/dist/request.js
var require_request = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _extends2 = _interopRequireDefault(require_extends());
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(source, true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  if (process.browser || process.env.ENVIRONMENT === "BROWSER" || typeof process.versions.electron !== "undefined" && process.type === "renderer" && typeof XMLHttpRequest === "function") {
    module2.exports = function(options, cb) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", options.url, true);
      xhr.responseType = "arraybuffer";
      xhr.addEventListener("load", function() {
        if (xhr.status < 400) {
          try {
            var data = Buffer.from(this.response);
            cb(null, xhr, data);
          } catch (error) {
            return cb(new Error("Response is not a buffer for url " + options.url + ". Error: " + error.message));
          }
        } else {
          cb(new Error("HTTP Status " + xhr.status + " for url " + options.url));
        }
      });
      xhr.addEventListener("error", function(e) {
        cb(e);
      });
      xhr.send();
    };
  } else {
    module2.exports = function(_ref, cb) {
      var options = (0, _extends2["default"])({}, _ref);
      var p = require_phin_compiled();
      p(_objectSpread({
        compression: true
      }, options), function(err, res) {
        if (err === null) {
          cb(null, res, res.body);
        } else {
          cb(err);
        }
      });
    };
  }
});

// node_modules/@jimp/core/dist/constants.js
var require_constants = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.EDGE_CROP = exports2.EDGE_WRAP = exports2.EDGE_EXTEND = exports2.BLEND_EXCLUSION = exports2.BLEND_DIFFERENCE = exports2.BLEND_HARDLIGHT = exports2.BLEND_LIGHTEN = exports2.BLEND_DARKEN = exports2.BLEND_OVERLAY = exports2.BLEND_SCREEN = exports2.BLEND_ADD = exports2.BLEND_MULTIPLY = exports2.BLEND_DESTINATION_OVER = exports2.BLEND_SOURCE_OVER = exports2.VERTICAL_ALIGN_BOTTOM = exports2.VERTICAL_ALIGN_MIDDLE = exports2.VERTICAL_ALIGN_TOP = exports2.HORIZONTAL_ALIGN_RIGHT = exports2.HORIZONTAL_ALIGN_CENTER = exports2.HORIZONTAL_ALIGN_LEFT = exports2.AUTO = void 0;
  var AUTO = -1;
  exports2.AUTO = AUTO;
  var HORIZONTAL_ALIGN_LEFT = 1;
  exports2.HORIZONTAL_ALIGN_LEFT = HORIZONTAL_ALIGN_LEFT;
  var HORIZONTAL_ALIGN_CENTER = 2;
  exports2.HORIZONTAL_ALIGN_CENTER = HORIZONTAL_ALIGN_CENTER;
  var HORIZONTAL_ALIGN_RIGHT = 4;
  exports2.HORIZONTAL_ALIGN_RIGHT = HORIZONTAL_ALIGN_RIGHT;
  var VERTICAL_ALIGN_TOP = 8;
  exports2.VERTICAL_ALIGN_TOP = VERTICAL_ALIGN_TOP;
  var VERTICAL_ALIGN_MIDDLE = 16;
  exports2.VERTICAL_ALIGN_MIDDLE = VERTICAL_ALIGN_MIDDLE;
  var VERTICAL_ALIGN_BOTTOM = 32;
  exports2.VERTICAL_ALIGN_BOTTOM = VERTICAL_ALIGN_BOTTOM;
  var BLEND_SOURCE_OVER = "srcOver";
  exports2.BLEND_SOURCE_OVER = BLEND_SOURCE_OVER;
  var BLEND_DESTINATION_OVER = "dstOver";
  exports2.BLEND_DESTINATION_OVER = BLEND_DESTINATION_OVER;
  var BLEND_MULTIPLY = "multiply";
  exports2.BLEND_MULTIPLY = BLEND_MULTIPLY;
  var BLEND_ADD = "add";
  exports2.BLEND_ADD = BLEND_ADD;
  var BLEND_SCREEN = "screen";
  exports2.BLEND_SCREEN = BLEND_SCREEN;
  var BLEND_OVERLAY = "overlay";
  exports2.BLEND_OVERLAY = BLEND_OVERLAY;
  var BLEND_DARKEN = "darken";
  exports2.BLEND_DARKEN = BLEND_DARKEN;
  var BLEND_LIGHTEN = "lighten";
  exports2.BLEND_LIGHTEN = BLEND_LIGHTEN;
  var BLEND_HARDLIGHT = "hardLight";
  exports2.BLEND_HARDLIGHT = BLEND_HARDLIGHT;
  var BLEND_DIFFERENCE = "difference";
  exports2.BLEND_DIFFERENCE = BLEND_DIFFERENCE;
  var BLEND_EXCLUSION = "exclusion";
  exports2.BLEND_EXCLUSION = BLEND_EXCLUSION;
  var EDGE_EXTEND = 1;
  exports2.EDGE_EXTEND = EDGE_EXTEND;
  var EDGE_WRAP = 2;
  exports2.EDGE_WRAP = EDGE_WRAP;
  var EDGE_CROP = 3;
  exports2.EDGE_CROP = EDGE_CROP;
});

// node_modules/@jimp/core/dist/composite/composite-modes.js
var require_composite_modes = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.srcOver = srcOver;
  exports2.dstOver = dstOver;
  exports2.multiply = multiply;
  exports2.add = add;
  exports2.screen = screen;
  exports2.overlay = overlay;
  exports2.darken = darken;
  exports2.lighten = lighten;
  exports2.hardLight = hardLight;
  exports2.difference = difference;
  exports2.exclusion = exclusion;
  function srcOver(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
    var g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
    var b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function dstOver(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
    var g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
    var b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function multiply(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    var g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    var b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function add(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (sra + dra) / a;
    var g = (sga + dga) / a;
    var b = (sba + dba) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function screen(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    var g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    var b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function overlay(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
    var g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
    var b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function darken(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    var g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    var b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function lighten(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    var g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    var b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function hardLight(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
    var g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
    var b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function difference(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
    var g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
    var b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
  function exclusion(src, dst) {
    var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a;
    var sra = src.r * src.a;
    var sga = src.g * src.a;
    var sba = src.b * src.a;
    var dra = dst.r * dst.a;
    var dga = dst.g * dst.a;
    var dba = dst.b * dst.a;
    var r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    var g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    var b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
      r,
      g,
      b,
      a
    };
  }
});

// node_modules/@jimp/core/dist/composite/index.js
var require_composite = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireWildcard = require_interopRequireWildcard();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = composite;
  var _utils = require_dist();
  var constants = _interopRequireWildcard(require_constants());
  var compositeModes = _interopRequireWildcard(require_composite_modes());
  function composite(src, x, y) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var cb = arguments.length > 4 ? arguments[4] : void 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!(src instanceof this.constructor)) {
      return _utils.throwError.call(this, "The source must be a Jimp image", cb);
    }
    if (typeof x !== "number" || typeof y !== "number") {
      return _utils.throwError.call(this, "x and y must be numbers", cb);
    }
    var _options = options, mode = _options.mode, opacitySource = _options.opacitySource, opacityDest = _options.opacityDest;
    if (!mode) {
      mode = constants.BLEND_SOURCE_OVER;
    }
    if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
      opacitySource = 1;
    }
    if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
      opacityDest = 1;
    }
    var blendmode = compositeModes[mode];
    x = Math.round(x);
    y = Math.round(y);
    var baseImage = this;
    if (opacityDest !== 1) {
      baseImage.opacity(opacityDest);
    }
    src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
      var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);
      var blended = blendmode({
        r: this.bitmap.data[idx + 0] / 255,
        g: this.bitmap.data[idx + 1] / 255,
        b: this.bitmap.data[idx + 2] / 255,
        a: this.bitmap.data[idx + 3] / 255
      }, {
        r: baseImage.bitmap.data[dstIdx + 0] / 255,
        g: baseImage.bitmap.data[dstIdx + 1] / 255,
        b: baseImage.bitmap.data[dstIdx + 2] / 255,
        a: baseImage.bitmap.data[dstIdx + 3] / 255
      }, opacitySource);
      baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
      baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
      baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
      baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
    });
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  module2.exports = exports2.default;
});

// node_modules/@jimp/core/dist/utils/promisify.js
var require_promisify = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var promisify = function promisify2(fun, ctx) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return new Promise(function(resolve, reject) {
      args.push(function(err, data) {
        if (err) {
          reject(err);
        }
        resolve(data);
      });
      fun.bind(ctx).apply(void 0, args);
    });
  };
  var _default = promisify;
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/core/dist/utils/mime.js
var require_mime = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.getExtension = exports2.getType = exports2.addType = void 0;
  var mimeTypes = {};
  var findType = function findType2(extension) {
    return Object.entries(mimeTypes).find(function(type) {
      return type[1].includes(extension);
    }) || [];
  };
  var addType = function addType2(mime, extensions) {
    mimeTypes[mime] = extensions;
  };
  exports2.addType = addType;
  var getType = function getType2(path) {
    var pathParts = path.split("/").slice(-1);
    var extension = pathParts[pathParts.length - 1].split(".").pop();
    var type = findType(extension);
    return type[0];
  };
  exports2.getType = getType;
  var getExtension = function getExtension2(type) {
    return (mimeTypes[type.toLowerCase()] || [])[0];
  };
  exports2.getExtension = getExtension;
});

// node_modules/file-type/index.js
var require_file_type = __commonJS((exports2, module2) => {
  "use strict";
  var toBytes = (s) => [...s].map((c) => c.charCodeAt(0));
  var xpiZipFilename = toBytes("META-INF/mozilla.rsa");
  var oxmlContentTypes = toBytes("[Content_Types].xml");
  var oxmlRels = toBytes("_rels/.rels");
  module2.exports = (input) => {
    const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buf && buf.length > 1)) {
      return null;
    }
    const check = (header, options) => {
      options = Object.assign({
        offset: 0
      }, options);
      for (let i = 0; i < header.length; i++) {
        if (options.mask) {
          if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
            return false;
          }
        } else if (header[i] !== buf[i + options.offset]) {
          return false;
        }
      }
      return true;
    };
    const checkString = (header, options) => check(toBytes(header), options);
    if (check([255, 216, 255])) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (check([87, 69, 66, 80], {offset: 8})) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (check([70, 76, 73, 70])) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], {offset: 8})) {
      return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
      };
    }
    if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (check([56, 66, 80, 83])) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (check([80, 75, 3, 4])) {
      if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], {offset: 30})) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check(xpiZipFilename, {offset: 30})) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", {offset: 30})) {
        return {
          ext: "odt",
          mime: "application/vnd.oasis.opendocument.text"
        };
      }
      if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {offset: 30})) {
        return {
          ext: "ods",
          mime: "application/vnd.oasis.opendocument.spreadsheet"
        };
      }
      if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", {offset: 30})) {
        return {
          ext: "odp",
          mime: "application/vnd.oasis.opendocument.presentation"
        };
      }
      const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr2) => i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
      let zipHeaderIndex = 0;
      let oxmlFound = false;
      let type = null;
      do {
        const offset = zipHeaderIndex + 30;
        if (!oxmlFound) {
          oxmlFound = check(oxmlContentTypes, {offset}) || check(oxmlRels, {offset});
        }
        if (!type) {
          if (checkString("word/", {offset})) {
            type = {
              ext: "docx",
              mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            };
          } else if (checkString("ppt/", {offset})) {
            type = {
              ext: "pptx",
              mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            };
          } else if (checkString("xl/", {offset})) {
            type = {
              ext: "xlsx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            };
          }
        }
        if (oxmlFound && type) {
          return type;
        }
        zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
      } while (zipHeaderIndex >= 0);
      if (type) {
        return type;
      }
    }
    if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (check([117, 115, 116, 97, 114], {offset: 257})) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (check([51, 103, 112, 53]) || check([0, 0, 0]) && check([102, 116, 121, 112], {offset: 4}) && (check([109, 112, 52, 49], {offset: 8}) || check([109, 112, 52, 50], {offset: 8}) || check([105, 115, 111, 109], {offset: 8}) || check([105, 115, 111, 50], {offset: 8}) || check([109, 109, 112, 52], {offset: 8}) || check([77, 52, 86], {offset: 8}) || check([100, 97, 115, 104], {offset: 8}))) {
      return {
        ext: "mp4",
        mime: "video/mp4"
      };
    }
    if (check([77, 84, 104, 100])) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (check([26, 69, 223, 163])) {
      const sliced = buf.subarray(4, 4 + 4096);
      const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
      if (idPos !== -1) {
        const docTypePos = idPos + 3;
        const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
        if (findDocType("matroska")) {
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        }
        if (findDocType("webm")) {
          return {
            ext: "webm",
            mime: "video/webm"
          };
        }
      }
    }
    if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], {offset: 4}) || check([102, 116, 121, 112, 113, 116, 32, 32], {offset: 4}) || check([109, 100, 97, 116], {offset: 4}) || check([119, 105, 100, 101], {offset: 4})) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (check([82, 73, 70, 70])) {
      if (check([65, 86, 73], {offset: 8})) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (check([87, 65, 86, 69], {offset: 8})) {
        return {
          ext: "wav",
          mime: "audio/vnd.wave"
        };
      }
      if (check([81, 76, 67, 77], {offset: 8})) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
      };
    }
    if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (check([102, 116, 121, 112, 51, 103], {offset: 4})) {
      return {
        ext: "3gp",
        mime: "video/3gpp"
      };
    }
    for (let start = 0; start < 2 && start < buf.length - 16; start++) {
      if (check([73, 68, 51], {offset: start}) || check([255, 226], {offset: start, mask: [255, 226]})) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([255, 228], {offset: start, mask: [255, 228]})) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (check([255, 248], {offset: start, mask: [255, 252]})) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (check([255, 240], {offset: start, mask: [255, 252]})) {
        return {
          ext: "mp4",
          mime: "audio/mpeg"
        };
      }
    }
    if (check([102, 116, 121, 112, 77, 52, 65], {offset: 4}) || check([77, 52, 65, 32])) {
      return {
        ext: "m4a",
        mime: "audio/mp4"
      };
    }
    if (check([79, 112, 117, 115, 72, 101, 97, 100], {offset: 28})) {
      return {
        ext: "opus",
        mime: "audio/opus"
      };
    }
    if (check([79, 103, 103, 83])) {
      if (check([128, 116, 104, 101, 111, 114, 97], {offset: 28})) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (check([1, 118, 105, 100, 101, 111, 0], {offset: 28})) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (check([127, 70, 76, 65, 67], {offset: 28})) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (check([83, 112, 101, 101, 120, 32, 32], {offset: 28})) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (check([1, 118, 111, 114, 98, 105, 115], {offset: 28})) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (check([102, 76, 97, 67])) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (check([77, 65, 67, 32])) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (check([119, 118, 112, 107])) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (check([35, 33, 65, 77, 82, 10])) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (check([37, 80, 68, 70])) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], {offset: 1})) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (check([123, 92, 114, 116, 102])) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], {offset: 4}) || check([79, 84, 84, 79], {offset: 4}))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], {offset: 4}) || check([79, 84, 84, 79], {offset: 4}))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (check([76, 80], {offset: 34}) && (check([0, 0, 1], {offset: 8}) || check([1, 0, 2], {offset: 8}) || check([2, 0, 2], {offset: 8}))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (check([37, 33])) {
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (check([83, 81, 76, 105])) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (check([67, 114, 50, 52])) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
      return {
        ext: "deb",
        mime: "application/x-deb"
      };
    }
    if (check([33, 60, 97, 114, 99, 104, 62])) {
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (check([31, 160]) || check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (check([76, 90, 73, 80])) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "msi",
        mime: "application/x-msi"
      };
    }
    if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (check([71], {offset: 4}) && (check([71], {offset: 192}) || check([71], {offset: 196}))) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (check([66, 76, 69, 78, 68, 69, 82])) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      if (check([106, 112, 50, 32], {offset: 20})) {
        return {
          ext: "jp2",
          mime: "image/jp2"
        };
      }
      if (check([106, 112, 120, 32], {offset: 20})) {
        return {
          ext: "jpx",
          mime: "image/jpx"
        };
      }
      if (check([106, 112, 109, 32], {offset: 20})) {
        return {
          ext: "jpm",
          mime: "image/jpm"
        };
      }
      if (check([109, 106, 112, 50], {offset: 20})) {
        return {
          ext: "mj2",
          mime: "image/mj2"
        };
      }
    }
    if (check([70, 79, 82, 77, 0])) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (check([66, 79, 79, 75, 77, 79, 66, 73], {offset: 60})) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (check([102, 116, 121, 112], {offset: 4})) {
      if (check([109, 105, 102, 49], {offset: 8})) {
        return {
          ext: "heic",
          mime: "image/heif"
        };
      }
      if (check([109, 115, 102, 49], {offset: 8})) {
        return {
          ext: "heic",
          mime: "image/heif-sequence"
        };
      }
      if (check([104, 101, 105, 99], {offset: 8}) || check([104, 101, 105, 120], {offset: 8})) {
        return {
          ext: "heic",
          mime: "image/heic"
        };
      }
      if (check([104, 101, 118, 99], {offset: 8}) || check([104, 101, 118, 120], {offset: 8})) {
        return {
          ext: "heic",
          mime: "image/heic-sequence"
        };
      }
    }
    if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    return null;
  };
});

// node_modules/exif-parser/lib/jpeg.js
var require_jpeg = __commonJS((exports2, module2) => {
  module2.exports = {
    parseSections: function(stream, iterator) {
      var len, markerType;
      stream.setBigEndian(true);
      while (stream.remainingLength() > 0 && markerType !== 218) {
        if (stream.nextUInt8() !== 255) {
          throw new Error("Invalid JPEG section offset");
        }
        markerType = stream.nextUInt8();
        if (markerType >= 208 && markerType <= 217 || markerType === 218) {
          len = 0;
        } else {
          len = stream.nextUInt16() - 2;
        }
        iterator(markerType, stream.branch(0, len));
        stream.skip(len);
      }
    },
    getSizeFromSOFSection: function(stream) {
      stream.skip(1);
      return {
        height: stream.nextUInt16(),
        width: stream.nextUInt16()
      };
    },
    getSectionName: function(markerType) {
      var name, index;
      switch (markerType) {
        case 216:
          name = "SOI";
          break;
        case 196:
          name = "DHT";
          break;
        case 219:
          name = "DQT";
          break;
        case 221:
          name = "DRI";
          break;
        case 218:
          name = "SOS";
          break;
        case 254:
          name = "COM";
          break;
        case 217:
          name = "EOI";
          break;
        default:
          if (markerType >= 224 && markerType <= 239) {
            name = "APP";
            index = markerType - 224;
          } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
            name = "SOF";
            index = markerType - 192;
          } else if (markerType >= 208 && markerType <= 215) {
            name = "RST";
            index = markerType - 208;
          }
          break;
      }
      var nameStruct = {
        name
      };
      if (typeof index === "number") {
        nameStruct.index = index;
      }
      return nameStruct;
    }
  };
});

// node_modules/exif-parser/lib/exif.js
var require_exif = __commonJS((exports2, module2) => {
  function readExifValue(format, stream) {
    switch (format) {
      case 1:
        return stream.nextUInt8();
      case 3:
        return stream.nextUInt16();
      case 4:
        return stream.nextUInt32();
      case 5:
        return [stream.nextUInt32(), stream.nextUInt32()];
      case 6:
        return stream.nextInt8();
      case 8:
        return stream.nextUInt16();
      case 9:
        return stream.nextUInt32();
      case 10:
        return [stream.nextInt32(), stream.nextInt32()];
      case 11:
        return stream.nextFloat();
      case 12:
        return stream.nextDouble();
      default:
        throw new Error("Invalid format while decoding: " + format);
    }
  }
  function getBytesPerComponent(format) {
    switch (format) {
      case 1:
      case 2:
      case 6:
      case 7:
        return 1;
      case 3:
      case 8:
        return 2;
      case 4:
      case 9:
      case 11:
        return 4;
      case 5:
      case 10:
      case 12:
        return 8;
      default:
        return 0;
    }
  }
  function readExifTag(tiffMarker, stream) {
    var tagType = stream.nextUInt16(), format = stream.nextUInt16(), bytesPerComponent = getBytesPerComponent(format), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components, values, value, c;
    if (valueBytes > 4) {
      stream = tiffMarker.openWithOffset(stream.nextUInt32());
    }
    if (format === 2) {
      values = stream.nextString(components);
      var lastNull = values.indexOf("\0");
      if (lastNull !== -1) {
        values = values.substr(0, lastNull);
      }
    } else if (format === 7) {
      values = stream.nextBuffer(components);
    } else if (format !== 0) {
      values = [];
      for (c = 0; c < components; ++c) {
        values.push(readExifValue(format, stream));
      }
    }
    if (valueBytes < 4) {
      stream.skip(4 - valueBytes);
    }
    return [tagType, values, format];
  }
  function readIFDSection(tiffMarker, stream, iterator) {
    var numberOfEntries = stream.nextUInt16(), tag, i;
    for (i = 0; i < numberOfEntries; ++i) {
      tag = readExifTag(tiffMarker, stream);
      iterator(tag[0], tag[1], tag[2]);
    }
  }
  function readHeader(stream) {
    var exifHeader = stream.nextString(6);
    if (exifHeader !== "Exif\0\0") {
      throw new Error("Invalid EXIF header");
    }
    var tiffMarker = stream.mark();
    var tiffHeader = stream.nextUInt16();
    if (tiffHeader === 18761) {
      stream.setBigEndian(false);
    } else if (tiffHeader === 19789) {
      stream.setBigEndian(true);
    } else {
      throw new Error("Invalid TIFF header");
    }
    if (stream.nextUInt16() !== 42) {
      throw new Error("Invalid TIFF data");
    }
    return tiffMarker;
  }
  module2.exports = {
    IFD0: 1,
    IFD1: 2,
    GPSIFD: 3,
    SubIFD: 4,
    InteropIFD: 5,
    parseTags: function(stream, iterator) {
      var tiffMarker;
      try {
        tiffMarker = readHeader(stream);
      } catch (e) {
        return false;
      }
      var subIfdOffset, gpsOffset, interopOffset;
      var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = this.IFD0;
      readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
        switch (tagType) {
          case 34853:
            gpsOffset = value[0];
            break;
          case 34665:
            subIfdOffset = value[0];
            break;
          default:
            iterator(IFD0, tagType, value, format);
            break;
        }
      });
      var ifd1Offset = ifd0Stream.nextUInt32();
      if (ifd1Offset !== 0) {
        var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
        readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
      }
      if (gpsOffset) {
        var gpsStream = tiffMarker.openWithOffset(gpsOffset);
        readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
      }
      if (subIfdOffset) {
        var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
        readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
          if (tagType === 40965) {
            interopOffset = value[0];
          } else {
            iterator(InteropIFD, tagType, value, format);
          }
        });
      }
      if (interopOffset) {
        var interopStream = tiffMarker.openWithOffset(interopOffset);
        readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
      }
      return true;
    }
  };
});

// node_modules/exif-parser/lib/date.js
var require_date = __commonJS((exports2, module2) => {
  function parseNumber(s) {
    return parseInt(s, 10);
  }
  var hours = 3600;
  var minutes = 60;
  function parseDateTimeParts(dateParts, timeParts) {
    dateParts = dateParts.map(parseNumber);
    timeParts = timeParts.map(parseNumber);
    var year = dateParts[0];
    var month = dateParts[1] - 1;
    var day = dateParts[2];
    var hours2 = timeParts[0];
    var minutes2 = timeParts[1];
    var seconds = timeParts[2];
    var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
    var timestamp = date / 1e3;
    return timestamp;
  }
  function parseDateWithTimezoneFormat(dateTimeStr) {
    var dateParts = dateTimeStr.substr(0, 10).split("-");
    var timeParts = dateTimeStr.substr(11, 8).split(":");
    var timezoneStr = dateTimeStr.substr(19, 6);
    var timezoneParts = timezoneStr.split(":").map(parseNumber);
    var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    timestamp -= timezoneOffset;
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  }
  function parseDateWithSpecFormat(dateTimeStr) {
    var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  }
  function parseExifDate(dateTimeStr) {
    var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
    var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
    var timestamp;
    if (isTimezoneFormat) {
      return parseDateWithTimezoneFormat(dateTimeStr);
    } else if (isSpecFormat) {
      return parseDateWithSpecFormat(dateTimeStr);
    }
  }
  module2.exports = {
    parseDateWithSpecFormat,
    parseDateWithTimezoneFormat,
    parseExifDate
  };
});

// node_modules/exif-parser/lib/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var exif = require_exif();
  var date = require_date();
  var degreeTags = [
    {
      section: exif.GPSIFD,
      type: 2,
      name: "GPSLatitude",
      refType: 1,
      refName: "GPSLatitudeRef",
      posVal: "N"
    },
    {
      section: exif.GPSIFD,
      type: 4,
      name: "GPSLongitude",
      refType: 3,
      refName: "GPSLongitudeRef",
      posVal: "E"
    }
  ];
  var dateTags = [
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    },
    {
      section: exif.SubIFD,
      type: 36867,
      name: "DateTimeOriginal"
    },
    {
      section: exif.SubIFD,
      type: 36868,
      name: "CreateDate"
    },
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    }
  ];
  module2.exports = {
    castDegreeValues: function(getTagValue, setTagValue) {
      degreeTags.forEach(function(t) {
        var degreeVal = getTagValue(t);
        if (degreeVal) {
          var degreeRef = getTagValue({section: t.section, type: t.refType, name: t.refName});
          var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
          var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
          setTagValue(t, degree);
        }
      });
    },
    castDateValues: function(getTagValue, setTagValue) {
      dateTags.forEach(function(t) {
        var dateStrVal = getTagValue(t);
        if (dateStrVal) {
          var timestamp = date.parseExifDate(dateStrVal);
          if (typeof timestamp !== "undefined") {
            setTagValue(t, timestamp);
          }
        }
      });
    },
    simplifyValue: function(values, format) {
      if (Array.isArray(values)) {
        values = values.map(function(value) {
          if (format === 10 || format === 5) {
            return value[0] / value[1];
          }
          return value;
        });
        if (values.length === 1) {
          values = values[0];
        }
      }
      return values;
    }
  };
});

// node_modules/exif-parser/lib/exif-tags.js
var require_exif_tags = __commonJS((exports2, module2) => {
  module2.exports = {
    exif: {
      1: "InteropIndex",
      2: "InteropVersion",
      11: "ProcessingSoftware",
      254: "SubfileType",
      255: "OldSubfileType",
      256: "ImageWidth",
      257: "ImageHeight",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Thresholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      269: "DocumentName",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      292: "T4Options",
      293: "T6Options",
      296: "ResolutionUnit",
      297: "PageNumber",
      300: "ColorResponseUnit",
      301: "TransferFunction",
      305: "Software",
      306: "ModifyDate",
      315: "Artist",
      316: "HostComputer",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      320: "ColorMap",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFD",
      332: "InkSet",
      333: "InkNames",
      334: "NumberofInks",
      336: "DotRange",
      337: "TargetPrinter",
      338: "ExtraSamples",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      435: "T82Options",
      437: "JPEGTables",
      512: "JPEGProc",
      513: "ThumbnailOffset",
      514: "ThumbnailLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "ApplicationNotes",
      999: "USPTOMiscellaneous",
      4096: "RelatedImageFileFormat",
      4097: "RelatedImageWidth",
      4098: "RelatedImageHeight",
      18246: "Rating",
      18247: "XP_DIP_XML",
      18248: "StitchInfo",
      18249: "RatingPercent",
      32781: "ImageID",
      32931: "WangTag1",
      32932: "WangAnnotation",
      32933: "WangTag3",
      32934: "WangTag4",
      32995: "Matteing",
      32996: "DataType",
      32997: "ImageDepth",
      32998: "TileDepth",
      33405: "Model2",
      33421: "CFARepeatPatternDim",
      33422: "CFAPattern2",
      33423: "BatteryLevel",
      33424: "KodakIFD",
      33432: "Copyright",
      33434: "ExposureTime",
      33437: "FNumber",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "PixelScale",
      33589: "AdventScale",
      33590: "AdventRevision",
      33628: "UIC1Tag",
      33629: "UIC2Tag",
      33630: "UIC3Tag",
      33631: "UIC4Tag",
      33723: "IPTC-NAA",
      33918: "IntergraphPacketData",
      33919: "IntergraphFlagRegisters",
      33920: "IntergraphMatrix",
      33921: "INGRReserved",
      33922: "ModelTiePoint",
      34016: "Site",
      34017: "ColorSequence",
      34018: "IT8Header",
      34019: "RasterPadding",
      34020: "BitsPerRunLength",
      34021: "BitsPerExtendedRunLength",
      34022: "ColorTable",
      34023: "ImageColorIndicator",
      34024: "BackgroundColorIndicator",
      34025: "ImageColorValue",
      34026: "BackgroundColorValue",
      34027: "PixelIntensityRange",
      34028: "TransparencyIndicator",
      34029: "ColorCharacterization",
      34030: "HCUsage",
      34031: "TrapIndicator",
      34032: "CMYKEquivalent",
      34118: "SEMInfo",
      34152: "AFCP_IPTC",
      34232: "PixelMagicJBIGOptions",
      34264: "ModelTransform",
      34306: "WB_GRGBLevels",
      34310: "LeafData",
      34377: "PhotoshopSettings",
      34665: "ExifOffset",
      34675: "ICC_Profile",
      34687: "TIFF_FXExtensions",
      34688: "MultiProfiles",
      34689: "SharedData",
      34690: "T88Options",
      34732: "ImageLayer",
      34735: "GeoTiffDirectory",
      34736: "GeoTiffDoubleParams",
      34737: "GeoTiffAsciiParams",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34853: "GPSInfo",
      34855: "ISO",
      34856: "Opto-ElectricConvFactor",
      34857: "Interlace",
      34858: "TimeZoneOffset",
      34859: "SelfTimerMode",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      34908: "FaxRecvParams",
      34909: "FaxSubAddress",
      34910: "FaxRecvTime",
      34954: "LeafSubIFD",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "CreateDate",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureCompensation",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37387: "FlashEnergy",
      37388: "SpatialFrequencyResponse",
      37389: "Noise",
      37390: "FocalPlaneXResolution",
      37391: "FocalPlaneYResolution",
      37392: "FocalPlaneResolutionUnit",
      37393: "ImageNumber",
      37394: "SecurityClassification",
      37395: "ImageHistory",
      37396: "SubjectArea",
      37397: "ExposureIndex",
      37398: "TIFF-EPStandardID",
      37399: "SensingMethod",
      37434: "CIP3DataFile",
      37435: "CIP3Sheet",
      37436: "CIP3Side",
      37439: "StoNits",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubSecTime",
      37521: "SubSecTimeOriginal",
      37522: "SubSecTimeDigitized",
      37679: "MSDocumentText",
      37680: "MSPropertySetStorage",
      37681: "MSDocumentTextPosition",
      37724: "ImageSourceData",
      40091: "XPTitle",
      40092: "XPComment",
      40093: "XPAuthor",
      40094: "XPKeywords",
      40095: "XPSubject",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "ExifImageWidth",
      40963: "ExifImageHeight",
      40964: "RelatedSoundFile",
      40965: "InteropOffset",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41485: "Noise",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41489: "ImageNumber",
      41490: "SecurityClassification",
      41491: "ImageHistory",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41494: "TIFF-EPStandardID",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFormat",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "OwnerName",
      42033: "SerialNumber",
      42034: "LensInfo",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42112: "GDALMetadata",
      42113: "GDALNoData",
      42240: "Gamma",
      44992: "ExpandSoftware",
      44993: "ExpandLens",
      44994: "ExpandFilm",
      44995: "ExpandFilterLens",
      44996: "ExpandScanner",
      44997: "ExpandFlashLamp",
      48129: "PixelFormat",
      48130: "Transformation",
      48131: "Uncompressed",
      48132: "ImageType",
      48256: "ImageWidth",
      48257: "ImageHeight",
      48258: "WidthResolution",
      48259: "HeightResolution",
      48320: "ImageOffset",
      48321: "ImageByteCount",
      48322: "AlphaOffset",
      48323: "AlphaByteCount",
      48324: "ImageDataDiscard",
      48325: "AlphaDataDiscard",
      50215: "OceScanjobDesc",
      50216: "OceApplicationSelector",
      50217: "OceIDNumber",
      50218: "OceImageLogic",
      50255: "Annotations",
      50341: "PrintIM",
      50560: "USPTOOriginalContentType",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "DNGLensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50739: "ShadowScale",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50752: "RawImageSegmentation",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50781: "RawDataUniqueID",
      50784: "AliasLayerMetadata",
      50827: "OriginalRawFileName",
      50828: "OriginalRawFileData",
      50829: "ActiveArea",
      50830: "MaskedAreas",
      50831: "AsShotICCProfile",
      50832: "AsShotPreProfileMatrix",
      50833: "CurrentICCProfile",
      50834: "CurrentPreProfileMatrix",
      50879: "ColorimetricReference",
      50898: "PanasonicTitle",
      50899: "PanasonicTitle2",
      50931: "CameraCalibrationSig",
      50932: "ProfileCalibrationSig",
      50933: "ProfileIFD",
      50934: "AsShotProfileName",
      50935: "NoiseReductionApplied",
      50936: "ProfileName",
      50937: "ProfileHueSatMapDims",
      50938: "ProfileHueSatMapData1",
      50939: "ProfileHueSatMapData2",
      50940: "ProfileToneCurve",
      50941: "ProfileEmbedPolicy",
      50942: "ProfileCopyright",
      50964: "ForwardMatrix1",
      50965: "ForwardMatrix2",
      50966: "PreviewApplicationName",
      50967: "PreviewApplicationVersion",
      50968: "PreviewSettingsName",
      50969: "PreviewSettingsDigest",
      50970: "PreviewColorSpace",
      50971: "PreviewDateTime",
      50972: "RawImageDigest",
      50973: "OriginalRawFileDigest",
      50974: "SubTileBlockSize",
      50975: "RowInterleaveFactor",
      50981: "ProfileLookTableDims",
      50982: "ProfileLookTableData",
      51008: "OpcodeList1",
      51009: "OpcodeList2",
      51022: "OpcodeList3",
      51041: "NoiseProfile",
      51043: "TimeCodes",
      51044: "FrameRate",
      51058: "TStop",
      51081: "ReelName",
      51089: "OriginalDefaultFinalSize",
      51090: "OriginalBestQualitySize",
      51091: "OriginalDefaultCropSize",
      51105: "CameraLabel",
      51107: "ProfileHueSatMapEncoding",
      51108: "ProfileLookTableEncoding",
      51109: "BaselineExposureOffset",
      51110: "DefaultBlackRender",
      51111: "NewRawImageDigest",
      51112: "RawToPreviewGain",
      51125: "DefaultUserCrop",
      59932: "Padding",
      59933: "OffsetSchema",
      65e3: "OwnerName",
      65001: "SerialNumber",
      65002: "Lens",
      65024: "KDC_IFD",
      65100: "RawFile",
      65101: "Converter",
      65102: "WhiteBalance",
      65105: "Exposure",
      65106: "Shadows",
      65107: "Brightness",
      65108: "Contrast",
      65109: "Saturation",
      65110: "Sharpness",
      65111: "Smoothness",
      65112: "MoireFilter"
    },
    gps: {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    }
  };
});

// node_modules/exif-parser/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  var jpeg = require_jpeg();
  var exif = require_exif();
  var simplify = require_simplify();
  function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
    this.startMarker = startMarker;
    this.tags = tags;
    this.imageSize = imageSize;
    this.thumbnailOffset = thumbnailOffset;
    this.thumbnailLength = thumbnailLength;
    this.thumbnailType = thumbnailType;
    this.app1Offset = app1Offset;
  }
  ExifResult.prototype = {
    hasThumbnail: function(mime) {
      if (!this.thumbnailOffset || !this.thumbnailLength) {
        return false;
      }
      if (typeof mime !== "string") {
        return true;
      }
      if (mime.toLowerCase().trim() === "image/jpeg") {
        return this.thumbnailType === 6;
      }
      if (mime.toLowerCase().trim() === "image/tiff") {
        return this.thumbnailType === 1;
      }
      return false;
    },
    getThumbnailOffset: function() {
      return this.app1Offset + 6 + this.thumbnailOffset;
    },
    getThumbnailLength: function() {
      return this.thumbnailLength;
    },
    getThumbnailBuffer: function() {
      return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    },
    _getThumbnailStream: function() {
      return this.startMarker.openWithOffset(this.getThumbnailOffset());
    },
    getImageSize: function() {
      return this.imageSize;
    },
    getThumbnailSize: function() {
      var stream = this._getThumbnailStream(), size;
      jpeg.parseSections(stream, function(sectionType, sectionStream) {
        if (jpeg.getSectionName(sectionType).name === "SOF") {
          size = jpeg.getSizeFromSOFSection(sectionStream);
        }
      });
      return size;
    }
  };
  function Parser(stream) {
    this.stream = stream;
    this.flags = {
      readBinaryTags: false,
      resolveTagNames: true,
      simplifyValues: true,
      imageSize: true,
      hidePointers: true,
      returnTags: true
    };
  }
  Parser.prototype = {
    enableBinaryFields: function(enable) {
      this.flags.readBinaryTags = !!enable;
      return this;
    },
    enablePointers: function(enable) {
      this.flags.hidePointers = !enable;
      return this;
    },
    enableTagNames: function(enable) {
      this.flags.resolveTagNames = !!enable;
      return this;
    },
    enableImageSize: function(enable) {
      this.flags.imageSize = !!enable;
      return this;
    },
    enableReturnTags: function(enable) {
      this.flags.returnTags = !!enable;
      return this;
    },
    enableSimpleValues: function(enable) {
      this.flags.simplifyValues = !!enable;
      return this;
    },
    parse: function() {
      var start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
      if (flags.resolveTagNames) {
        tagNames = require_exif_tags();
      }
      if (flags.resolveTagNames) {
        tags = {};
        getTagValue = function(t) {
          return tags[t.name];
        };
        setTagValue = function(t, value) {
          tags[t.name] = value;
        };
      } else {
        tags = [];
        getTagValue = function(t) {
          var i;
          for (i = 0; i < tags.length; ++i) {
            if (tags[i].type === t.type && tags[i].section === t.section) {
              return tags.value;
            }
          }
        };
        setTagValue = function(t, value) {
          var i;
          for (i = 0; i < tags.length; ++i) {
            if (tags[i].type === t.type && tags[i].section === t.section) {
              tags.value = value;
              return;
            }
          }
        };
      }
      jpeg.parseSections(stream, function(sectionType, sectionStream) {
        var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
        if (sectionType === 225) {
          validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
            if (!flags.readBinaryTags && format === 7) {
              return;
            }
            if (tagType === 513) {
              thumbnailOffset = value[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 514) {
              thumbnailLength = value[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 259) {
              thumbnailType = value[0];
              if (flags.hidePointers) {
                return;
              }
            }
            if (!flags.returnTags) {
              return;
            }
            if (flags.simplifyValues) {
              value = simplify.simplifyValue(value, format);
            }
            if (flags.resolveTagNames) {
              var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
              var name = sectionTagNames[tagType];
              if (!name) {
                name = tagNames.exif[tagType];
              }
              if (!tags.hasOwnProperty(name)) {
                tags[name] = value;
              }
            } else {
              tags.push({
                section: ifdSection,
                type: tagType,
                value
              });
            }
          });
          if (validExifHeaders) {
            app1Offset = sectionOffset;
          }
        } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
          imageSize = jpeg.getSizeFromSOFSection(sectionStream);
        }
      });
      if (flags.simplifyValues) {
        simplify.castDegreeValues(getTagValue, setTagValue);
        simplify.castDateValues(getTagValue, setTagValue);
      }
      return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
    }
  };
  module2.exports = Parser;
});

// node_modules/exif-parser/lib/dom-bufferstream.js
var require_dom_bufferstream = __commonJS((exports2, module2) => {
  function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
    this.global = global;
    offset = offset || 0;
    length = length || arrayBuffer.byteLength - offset;
    this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
    this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
    this.setBigEndian(bigEndian);
    this.offset = 0;
    this.parentOffset = (parentOffset || 0) + offset;
  }
  DOMBufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.littleEndian = !bigEndian;
    },
    nextUInt8: function() {
      var value = this.view.getUint8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.view.getInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.view.getUint16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.view.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.view.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.view.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.view.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.view.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.arrayBuffer.byteLength - this.offset;
    },
    nextString: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
        },
        offset: this.offset,
        getParentOffset: function() {
          return self2.parentOffset;
        }
      };
    },
    offsetFrom: function(marker) {
      return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
      return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
    }
  };
  module2.exports = DOMBufferStream;
});

// node_modules/exif-parser/lib/bufferstream.js
var require_bufferstream = __commonJS((exports2, module2) => {
  function BufferStream(buffer, offset, length, bigEndian) {
    this.buffer = buffer;
    this.offset = offset || 0;
    length = typeof length === "number" ? length : buffer.length;
    this.endPosition = this.offset + length;
    this.setBigEndian(bigEndian);
  }
  BufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.bigEndian = !!bigEndian;
    },
    nextUInt8: function() {
      var value = this.buffer.readUInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.buffer.readInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.endPosition - this.offset;
    },
    nextString: function(length) {
      var value = this.buffer.toString("utf8", this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
        },
        offset: this.offset
      };
    },
    offsetFrom: function(marker) {
      return this.offset - marker.offset;
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
      return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
    }
  };
  module2.exports = BufferStream;
});

// node_modules/exif-parser/index.js
var require_exif_parser = __commonJS((exports2, module2) => {
  var Parser = require_parser();
  function getGlobal() {
    return (1, eval)("this");
  }
  module2.exports = {
    create: function(buffer, global) {
      global = global || getGlobal();
      if (buffer instanceof global.ArrayBuffer) {
        var DOMBufferStream = require_dom_bufferstream();
        return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
      } else {
        var NodeBufferStream = require_bufferstream();
        return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
      }
    }
  };
});

// node_modules/@jimp/core/dist/utils/image-bitmap.js
var require_image_bitmap = __commonJS((exports2) => {
  "use strict";
  var _interopRequireWildcard = require_interopRequireWildcard();
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.parseBitmap = parseBitmap;
  exports2.getBuffer = getBuffer;
  exports2.getBufferAsync = getBufferAsync;
  var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
  var _fileType = _interopRequireDefault(require_file_type());
  var _exifParser = _interopRequireDefault(require_exif_parser());
  var _utils = require_dist();
  var constants = _interopRequireWildcard(require_constants());
  var MIME = _interopRequireWildcard(require_mime());
  var _promisify = _interopRequireDefault(require_promisify());
  function getMIMEFromBuffer(buffer, path) {
    var fileTypeFromBuffer = (0, _fileType["default"])(buffer);
    if (fileTypeFromBuffer) {
      return fileTypeFromBuffer.mime;
    }
    if (path) {
      return MIME.getType(path);
    }
    return null;
  }
  function getExifOrientation(img) {
    return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
  }
  function getExifOrientationTransformation(img) {
    var w = img.getWidth();
    var h = img.getHeight();
    switch (getExifOrientation(img)) {
      case 1:
        return null;
      case 2:
        return function(x, y) {
          return [w - x - 1, y];
        };
      case 3:
        return function(x, y) {
          return [w - x - 1, h - y - 1];
        };
      case 4:
        return function(x, y) {
          return [x, h - y - 1];
        };
      case 5:
        return function(x, y) {
          return [y, x];
        };
      case 6:
        return function(x, y) {
          return [y, h - x - 1];
        };
      case 7:
        return function(x, y) {
          return [w - y - 1, h - x - 1];
        };
      case 8:
        return function(x, y) {
          return [w - y - 1, x];
        };
      default:
        return null;
    }
  }
  function transformBitmap(img, width, height, transformation) {
    var _data = img.bitmap.data;
    var _width = img.bitmap.width;
    var data = Buffer.alloc(_data.length);
    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        var _transformation = transformation(x, y), _transformation2 = (0, _slicedToArray2["default"])(_transformation, 2), _x = _transformation2[0], _y = _transformation2[1];
        var idx = width * y + x << 2;
        var _idx = _width * _y + _x << 2;
        var pixel = _data.readUInt32BE(_idx);
        data.writeUInt32BE(pixel, idx);
      }
    }
    img.bitmap.data = data;
    img.bitmap.width = width;
    img.bitmap.height = height;
  }
  function exifRotate(img) {
    if (getExifOrientation(img) < 2)
      return;
    var transformation = getExifOrientationTransformation(img);
    var swapDimensions = getExifOrientation(img) > 4;
    var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
    var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
    transformBitmap(img, newWidth, newHeight, transformation);
  }
  function parseBitmap(data, path, cb) {
    var mime = getMIMEFromBuffer(data, path);
    if (typeof mime !== "string") {
      return cb(new Error("Could not find MIME for Buffer <" + path + ">"));
    }
    this._originalMime = mime.toLowerCase();
    try {
      var _mime = this.getMIME();
      if (this.constructor.decoders[_mime]) {
        this.bitmap = this.constructor.decoders[_mime](data);
      } else {
        return _utils.throwError.call(this, "Unsupported MIME type: " + _mime, cb);
      }
    } catch (error) {
      return cb.call(this, error, this);
    }
    try {
      this._exif = _exifParser["default"].create(data).parse();
      exifRotate(this);
    } catch (error) {
    }
    cb.call(this, null, this);
    return this;
  }
  function compositeBitmapOverBackground(Jimp2, image) {
    return new Jimp2(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
  }
  function getBuffer(mime, cb) {
    if (mime === constants.AUTO) {
      mime = this.getMIME();
    }
    if (typeof mime !== "string") {
      return _utils.throwError.call(this, "mime must be a string", cb);
    }
    if (typeof cb !== "function") {
      return _utils.throwError.call(this, "cb must be a function", cb);
    }
    mime = mime.toLowerCase();
    if (this._rgba && this.constructor.hasAlpha[mime]) {
      this.bitmap.data = Buffer.from(this.bitmap.data);
    } else {
      this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
    }
    if (this.constructor.encoders[mime]) {
      var buffer = this.constructor.encoders[mime](this);
      cb.call(this, null, buffer);
    } else {
      cb.call(this, "Unsupported MIME type: " + mime);
    }
    return this;
  }
  function getBufferAsync(mime) {
    return (0, _promisify["default"])(getBuffer, this, mime);
  }
});

// node_modules/@jimp/core/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  "use strict";
  var _interopRequireWildcard = require_interopRequireWildcard();
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.addConstants = addConstants;
  exports2.addJimpMethods = addJimpMethods;
  exports2.jimpEvMethod = jimpEvMethod;
  exports2.jimpEvChange = jimpEvChange;
  Object.defineProperty(exports2, "addType", {
    enumerable: true,
    get: function get() {
      return MIME.addType;
    }
  });
  exports2["default"] = void 0;
  var _construct2 = _interopRequireDefault(require_construct());
  var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
  var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _fs = _interopRequireDefault(require("fs"));
  var _path = _interopRequireDefault(require("path"));
  var _events = _interopRequireDefault(require("events"));
  var _utils = require_dist();
  var _anyBase = _interopRequireDefault(require_any_base());
  var _mkdirp = _interopRequireDefault(require_mkdirp());
  var _pixelmatch = _interopRequireDefault(require_pixelmatch());
  var _tinycolor = _interopRequireDefault(require_tinycolor());
  var _phash = _interopRequireDefault(require_phash());
  var _request = _interopRequireDefault(require_request());
  var _composite = _interopRequireDefault(require_composite());
  var _promisify = _interopRequireDefault(require_promisify());
  var MIME = _interopRequireWildcard(require_mime());
  var _imageBitmap = require_image_bitmap();
  var constants = _interopRequireWildcard(require_constants());
  var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
  var maxHashLength = [NaN, NaN];
  for (var i = 2; i < 65; i++) {
    maxHash = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
    maxHashLength.push(maxHash.length);
  }
  var maxHash;
  function noop() {
  }
  function isArrayBuffer(test) {
    return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
  }
  function bufferFromArrayBuffer(arrayBuffer) {
    var buffer = Buffer.alloc(arrayBuffer.byteLength);
    var view = new Uint8Array(arrayBuffer);
    for (var _i = 0; _i < buffer.length; ++_i) {
      buffer[_i] = view[_i];
    }
    return buffer;
  }
  function loadFromURL(options, cb) {
    (0, _request["default"])(options, function(err, response, data) {
      if (err) {
        return cb(err);
      }
      if ("headers" in response && "location" in response.headers) {
        options.url = response.headers.location;
        return loadFromURL(options, cb);
      }
      if ((0, _typeof2["default"])(data) === "object" && Buffer.isBuffer(data)) {
        return cb(null, data);
      }
      var msg = "Could not load Buffer from <" + options.url + "> (HTTP: " + response.statusCode + ")";
      return new Error(msg);
    });
  }
  function loadBufferFromPath(src, cb) {
    if (_fs["default"] && typeof _fs["default"].readFile === "function" && !src.match(/^(http|ftp)s?:\/\/./)) {
      _fs["default"].readFile(src, cb);
    } else {
      loadFromURL({
        url: src
      }, cb);
    }
  }
  function isRawRGBAData(obj) {
    return obj && (0, _typeof2["default"])(obj) === "object" && typeof obj.width === "number" && typeof obj.height === "number" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === "function" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
  }
  function makeRGBABufferFromRGB(buffer) {
    if (buffer.length % 3 !== 0) {
      throw new Error("Buffer length is incorrect");
    }
    var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
    var j = 0;
    for (var _i2 = 0; _i2 < buffer.length; _i2++) {
      rgbaBuffer[j] = buffer[_i2];
      if ((_i2 + 1) % 3 === 0) {
        rgbaBuffer[++j] = 255;
      }
      j++;
    }
    return rgbaBuffer;
  }
  var emptyBitmap = {
    data: null,
    width: null,
    height: null
  };
  var Jimp2 = /* @__PURE__ */ function(_EventEmitter) {
    (0, _inherits2["default"])(Jimp3, _EventEmitter);
    function Jimp3() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (0, _classCallCheck2["default"])(this, Jimp3);
      _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Jimp3).call(this));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "bitmap", emptyBitmap);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_background", 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_originalMime", Jimp3.MIME_PNG);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_exif", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rgba", true);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "writeAsync", function(path2) {
        return (0, _promisify["default"])(_this.write, (0, _assertThisInitialized2["default"])(_this), path2);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBase64Async", function(mime) {
        return (0, _promisify["default"])(_this.getBase64, (0, _assertThisInitialized2["default"])(_this), mime);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBuffer", _imageBitmap.getBuffer);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBufferAsync", _imageBitmap.getBufferAsync);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getPixelColour", _this.getPixelColor);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setPixelColour", _this.setPixelColor);
      var jimpInstance = (0, _assertThisInitialized2["default"])(_this);
      var cb = noop;
      if (isArrayBuffer(args[0])) {
        args[0] = bufferFromArrayBuffer(args[0]);
      }
      function finish() {
        for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args2[_key2] = arguments[_key2];
        }
        var err = args2[0];
        var evData = err || {};
        evData.methodName = "constructor";
        setTimeout(function() {
          var _cb;
          if (err && cb === noop) {
            jimpInstance.emitError("constructor", err);
          } else if (!err) {
            jimpInstance.emitMulti("constructor", "initialized");
          }
          (_cb = cb).call.apply(_cb, [jimpInstance].concat(args2));
        }, 1);
      }
      if (typeof args[0] === "number" && typeof args[1] === "number" || parseInt(args[0], 10) && parseInt(args[1], 10)) {
        var w = parseInt(args[0], 10);
        var h = parseInt(args[1], 10);
        cb = args[2];
        if (typeof args[2] === "number") {
          _this._background = args[2];
          cb = args[3];
        }
        if (typeof args[2] === "string") {
          _this._background = Jimp3.cssColorToHex(args[2]);
          cb = args[3];
        }
        if (typeof cb === "undefined") {
          cb = noop;
        }
        if (typeof cb !== "function") {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
        }
        _this.bitmap = {
          data: Buffer.alloc(w * h * 4),
          width: w,
          height: h
        };
        for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {
          _this.bitmap.data.writeUInt32BE(_this._background, _i3);
        }
        finish(null, (0, _assertThisInitialized2["default"])(_this));
      } else if ((0, _typeof2["default"])(args[0]) === "object" && args[0].url) {
        cb = args[1] || noop;
        if (typeof cb !== "function") {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
        }
        loadFromURL(args[0], function(err, data2) {
          if (err) {
            return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
          }
          _this.parseBitmap(data2, args[0].url, finish);
        });
      } else if (args[0] instanceof Jimp3) {
        var original = args[0];
        cb = args[1];
        if (typeof cb === "undefined") {
          cb = noop;
        }
        if (typeof cb !== "function") {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
        }
        _this.bitmap = {
          data: Buffer.from(original.bitmap.data),
          width: original.bitmap.width,
          height: original.bitmap.height
        };
        _this._quality = original._quality;
        _this._deflateLevel = original._deflateLevel;
        _this._deflateStrategy = original._deflateStrategy;
        _this._filterType = original._filterType;
        _this._rgba = original._rgba;
        _this._background = original._background;
        _this._originalMime = original._originalMime;
        finish(null, (0, _assertThisInitialized2["default"])(_this));
      } else if (isRawRGBAData(args[0])) {
        var imageData = args[0];
        cb = args[1] || noop;
        var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
        var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
        _this.bitmap = {
          data: buffer,
          width: imageData.width,
          height: imageData.height
        };
        finish(null, (0, _assertThisInitialized2["default"])(_this));
      } else if (typeof args[0] === "string") {
        var path = args[0];
        cb = args[1];
        if (typeof cb === "undefined") {
          cb = noop;
        }
        if (typeof cb !== "function") {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
        }
        loadBufferFromPath(path, function(err, data2) {
          if (err) {
            return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
          }
          _this.parseBitmap(data2, path, finish);
        });
      } else if ((0, _typeof2["default"])(args[0]) === "object" && Buffer.isBuffer(args[0])) {
        var data = args[0];
        cb = args[1];
        if (typeof cb !== "function") {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
        }
        _this.parseBitmap(data, null, finish);
      } else {
        cb = args[args.length - 1];
        if (typeof cb !== "function") {
          cb = args[args.length - 2];
          if (typeof cb !== "function") {
            cb = noop;
          }
        }
        var extraConstructor = Jimp3.__extraConstructors.find(function(c) {
          return c.test.apply(c, args);
        });
        if (extraConstructor) {
          new Promise(function(resolve, reject) {
            var _extraConstructor$run;
            return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2["default"])(_this), resolve, reject].concat(args));
          }).then(function() {
            return finish(null, (0, _assertThisInitialized2["default"])(_this));
          })["catch"](finish);
        } else {
          return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish));
        }
      }
      return _this;
    }
    (0, _createClass2["default"])(Jimp3, [{
      key: "parseBitmap",
      value: function parseBitmap(data, path, finish) {
        _imageBitmap.parseBitmap.call(this, data, null, finish);
      }
    }, {
      key: "rgba",
      value: function rgba(bool, cb) {
        if (typeof bool !== "boolean") {
          return _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb);
        }
        this._rgba = bool;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    }, {
      key: "emitMulti",
      value: function emitMulti(methodName, eventName) {
        var data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        data = Object.assign(data, {
          methodName,
          eventName
        });
        this.emit("any", data);
        if (methodName) {
          this.emit(methodName, data);
        }
        this.emit(eventName, data);
      }
    }, {
      key: "emitError",
      value: function emitError(methodName, err) {
        this.emitMulti(methodName, "error", err);
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.bitmap.height;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.bitmap.width;
      }
    }, {
      key: "inspect",
      value: function inspect() {
        return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
      }
    }, {
      key: "toString",
      value: function toString() {
        return "[object Jimp]";
      }
    }, {
      key: "getMIME",
      value: function getMIME() {
        var mime = this._originalMime || Jimp3.MIME_PNG;
        return mime;
      }
    }, {
      key: "getExtension",
      value: function getExtension() {
        var mime = this.getMIME();
        return MIME.getExtension(mime);
      }
    }, {
      key: "write",
      value: function write(path, cb) {
        var _this2 = this;
        if (!_fs["default"] || !_fs["default"].createWriteStream) {
          throw new Error("Cant access the filesystem. You can use the getBase64 method.");
        }
        if (typeof path !== "string") {
          return _utils.throwError.call(this, "path must be a string", cb);
        }
        if (typeof cb === "undefined") {
          cb = noop;
        }
        if (typeof cb !== "function") {
          return _utils.throwError.call(this, "cb must be a function", cb);
        }
        var mime = MIME.getType(path) || this.getMIME();
        var pathObj = _path["default"].parse(path);
        if (pathObj.dir) {
          _mkdirp["default"].sync(pathObj.dir);
        }
        this.getBuffer(mime, function(err, buffer) {
          if (err) {
            return _utils.throwError.call(_this2, err, cb);
          }
          var stream = _fs["default"].createWriteStream(path);
          stream.on("open", function() {
            stream.write(buffer);
            stream.end();
          }).on("error", function(err2) {
            return _utils.throwError.call(_this2, err2, cb);
          });
          stream.on("finish", function() {
            cb.call(_this2, null, _this2);
          });
        });
        return this;
      }
    }, {
      key: "getBase64",
      value: function getBase64(mime, cb) {
        if (mime === Jimp3.AUTO) {
          mime = this.getMIME();
        }
        if (typeof mime !== "string") {
          return _utils.throwError.call(this, "mime must be a string", cb);
        }
        if (typeof cb !== "function") {
          return _utils.throwError.call(this, "cb must be a function", cb);
        }
        this.getBuffer(mime, function(err, data) {
          if (err) {
            return _utils.throwError.call(this, err, cb);
          }
          var src = "data:" + mime + ";base64," + data.toString("base64");
          cb.call(this, null, src);
        });
        return this;
      }
    }, {
      key: "hash",
      value: function hash(base, cb) {
        base = base || 64;
        if (typeof base === "function") {
          cb = base;
          base = 64;
        }
        if (typeof base !== "number") {
          return _utils.throwError.call(this, "base must be a number", cb);
        }
        if (base < 2 || base > 64) {
          return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
        }
        var hash2 = this.pHash();
        hash2 = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, base))(hash2);
        while (hash2.length < maxHashLength[base]) {
          hash2 = "0" + hash2;
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, hash2);
        }
        return hash2;
      }
    }, {
      key: "pHash",
      value: function pHash() {
        var pHash2 = new _phash["default"]();
        return pHash2.getHash(this);
      }
    }, {
      key: "distanceFromHash",
      value: function distanceFromHash(compareHash) {
        var pHash = new _phash["default"]();
        var currentHash = pHash.getHash(this);
        return pHash.distance(currentHash, compareHash);
      }
    }, {
      key: "getPixelIndex",
      value: function getPixelIndex(x, y, edgeHandling, cb) {
        var xi;
        var yi;
        if (typeof edgeHandling === "function" && typeof cb === "undefined") {
          cb = edgeHandling;
          edgeHandling = null;
        }
        if (!edgeHandling) {
          edgeHandling = Jimp3.EDGE_EXTEND;
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        xi = x;
        yi = y;
        if (edgeHandling === Jimp3.EDGE_EXTEND) {
          if (x < 0)
            xi = 0;
          if (x >= this.bitmap.width)
            xi = this.bitmap.width - 1;
          if (y < 0)
            yi = 0;
          if (y >= this.bitmap.height)
            yi = this.bitmap.height - 1;
        }
        if (edgeHandling === Jimp3.EDGE_WRAP) {
          if (x < 0) {
            xi = this.bitmap.width + x;
          }
          if (x >= this.bitmap.width) {
            xi = x % this.bitmap.width;
          }
          if (y < 0) {
            xi = this.bitmap.height + y;
          }
          if (y >= this.bitmap.height) {
            yi = y % this.bitmap.height;
          }
        }
        var i2 = this.bitmap.width * yi + xi << 2;
        if (xi < 0 || xi >= this.bitmap.width) {
          i2 = -1;
        }
        if (yi < 0 || yi >= this.bitmap.height) {
          i2 = -1;
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, i2);
        }
        return i2;
      }
    }, {
      key: "getPixelColor",
      value: function getPixelColor(x, y, cb) {
        if (typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        var idx = this.getPixelIndex(x, y);
        var hex = this.bitmap.data.readUInt32BE(idx);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, hex);
        }
        return hex;
      }
    }, {
      key: "setPixelColor",
      value: function setPixelColor(hex, x, y, cb) {
        if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        var idx = this.getPixelIndex(x, y);
        this.bitmap.data.writeUInt32BE(hex, idx);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    }, {
      key: "hasAlpha",
      value: function hasAlpha() {
        for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
          for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
            var idx = this.bitmap.width * yIndex + xIndex << 2;
            var alpha = this.bitmap.data[idx + 3];
            if (alpha !== 255) {
              return true;
            }
          }
        }
        return false;
      }
    }, {
      key: "scanIterator",
      value: function scanIterator(x, y, w, h) {
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers");
        }
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers");
        }
        return (0, _utils.scanIterator)(this, x, y, w, h);
      }
    }]);
    return Jimp3;
  }(_events["default"]);
  function addConstants(constants2) {
    var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp2;
    Object.entries(constants2).forEach(function(_ref) {
      var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), name = _ref2[0], value = _ref2[1];
      jimpInstance[name] = value;
    });
  }
  function addJimpMethods(methods) {
    var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp2;
    Object.entries(methods).forEach(function(_ref3) {
      var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2), name = _ref4[0], value = _ref4[1];
      jimpInstance.prototype[name] = value;
    });
  }
  addConstants(constants);
  addJimpMethods({
    composite: _composite["default"]
  });
  Jimp2.__extraConstructors = [];
  Jimp2.appendConstructorOption = function(name, test, run) {
    Jimp2.__extraConstructors.push({
      name,
      test,
      run
    });
  };
  Jimp2.read = function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return new Promise(function(resolve, reject) {
      (0, _construct2["default"])(Jimp2, args.concat([function(err, image) {
        if (err)
          reject(err);
        else
          resolve(image);
      }]));
    });
  };
  Jimp2.create = Jimp2.read;
  Jimp2.rgbaToInt = function(r, g, b, a, cb) {
    if (typeof r !== "number" || typeof g !== "number" || typeof b !== "number" || typeof a !== "number") {
      return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
    }
    if (r < 0 || r > 255) {
      return _utils.throwError.call(this, "r must be between 0 and 255", cb);
    }
    if (g < 0 || g > 255) {
      _utils.throwError.call(this, "g must be between 0 and 255", cb);
    }
    if (b < 0 || b > 255) {
      return _utils.throwError.call(this, "b must be between 0 and 255", cb);
    }
    if (a < 0 || a > 255) {
      return _utils.throwError.call(this, "a must be between 0 and 255", cb);
    }
    r = Math.round(r);
    b = Math.round(b);
    g = Math.round(g);
    a = Math.round(a);
    var i2 = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, i2);
    }
    return i2;
  };
  Jimp2.intToRGBA = function(i2, cb) {
    if (typeof i2 !== "number") {
      return _utils.throwError.call(this, "i must be a number", cb);
    }
    var rgba = {};
    rgba.r = Math.floor(i2 / Math.pow(256, 3));
    rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
    rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
    rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, rgba);
    }
    return rgba;
  };
  Jimp2.cssColorToHex = function(cssColor) {
    cssColor = cssColor || 0;
    if (typeof cssColor === "number")
      return Number(cssColor);
    return parseInt((0, _tinycolor["default"])(cssColor).toHex8(), 16);
  };
  Jimp2.limit255 = function(n) {
    n = Math.max(n, 0);
    n = Math.min(n, 255);
    return n;
  };
  Jimp2.diff = function(img1, img2) {
    var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
    if (!(img1 instanceof Jimp2) || !(img2 instanceof Jimp2))
      return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
    var bmp1 = img1.bitmap;
    var bmp2 = img2.bitmap;
    if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
      if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
        img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
      } else {
        img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
      }
    }
    if (typeof threshold !== "number" || threshold < 0 || threshold > 1) {
      return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
    }
    var diff = new Jimp2(bmp1.width, bmp1.height, 4294967295);
    var numDiffPixels = (0, _pixelmatch["default"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
      threshold
    });
    return {
      percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
      image: diff
    };
  };
  Jimp2.distance = function(img1, img2) {
    var phash = new _phash["default"]();
    var hash1 = phash.getHash(img1);
    var hash2 = phash.getHash(img2);
    return phash.distance(hash1, hash2);
  };
  Jimp2.compareHashes = function(hash1, hash2) {
    var phash = new _phash["default"]();
    return phash.distance(hash1, hash2);
  };
  Jimp2.colorDiff = function(rgba1, rgba2) {
    var pow = function pow2(n) {
      return Math.pow(n, 2);
    };
    var max = Math.max;
    var maxVal = 255 * 255 * 3;
    if (rgba1.a !== 0 && !rgba1.a) {
      rgba1.a = 255;
    }
    if (rgba2.a !== 0 && !rgba2.a) {
      rgba2.a = 255;
    }
    return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
  };
  function jimpEvMethod(methodName, evName, method) {
    var evNameBefore = "before-" + evName;
    var evNameAfter = evName.replace(/e$/, "") + "ed";
    Jimp2.prototype[methodName] = function() {
      var wrappedCb;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      var cb = args[method.length - 1];
      var jimpInstance = this;
      if (typeof cb === "function") {
        wrappedCb = function wrappedCb2() {
          for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args2[_key5] = arguments[_key5];
          }
          var err = args2[0], data = args2[1];
          if (err) {
            jimpInstance.emitError(methodName, err);
          } else {
            jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, data));
          }
          cb.apply(this, args2);
        };
        args[args.length - 1] = wrappedCb;
      } else {
        wrappedCb = false;
      }
      this.emitMulti(methodName, evNameBefore);
      var result;
      try {
        result = method.apply(this, args);
        if (!wrappedCb) {
          this.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, result));
        }
      } catch (error) {
        error.methodName = methodName;
        this.emitError(methodName, error);
      }
      return result;
    };
    Jimp2.prototype[methodName + "Quiet"] = method;
  }
  jimpEvMethod("clone", "clone", function(cb) {
    var clone = new Jimp2(this);
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(clone, null, clone);
    }
    return clone;
  });
  function jimpEvChange(methodName, method) {
    jimpEvMethod(methodName, "change", method);
  }
  jimpEvChange("background", function(hex, cb) {
    if (typeof hex !== "number") {
      return _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb);
    }
    this._background = hex;
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  });
  jimpEvChange("scan", function(x, y, w, h, f, cb) {
    if (typeof x !== "number" || typeof y !== "number") {
      return _utils.throwError.call(this, "x and y must be numbers", cb);
    }
    if (typeof w !== "number" || typeof h !== "number") {
      return _utils.throwError.call(this, "w and h must be numbers", cb);
    }
    if (typeof f !== "function") {
      return _utils.throwError.call(this, "f must be a function", cb);
    }
    var result = (0, _utils.scan)(this, x, y, w, h, f);
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, result);
    }
    return result;
  });
  if (process.env.ENVIRONMENT === "BROWSER") {
    if (typeof window !== "undefined" && (typeof window === "undefined" ? "undefined" : (0, _typeof2["default"])(window)) === "object") {
      gl = window;
    }
    if (typeof self !== "undefined" && (typeof self === "undefined" ? "undefined" : (0, _typeof2["default"])(self)) === "object") {
      gl = self;
    }
    gl.Jimp = Jimp2;
    gl.Buffer = Buffer;
  }
  var gl;
  var _default = Jimp2;
  exports2["default"] = _default;
});

// node_modules/@jimp/custom/dist/index.js
var require_dist3 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireWildcard = require_interopRequireWildcard();
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = configure;
  var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
  var _core = _interopRequireWildcard(require_dist2());
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(source, true).forEach(function(key) {
          (0, _defineProperty2["default"])(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function configure(configuration) {
    var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _core["default"];
    var jimpConfig = {
      hasAlpha: {},
      encoders: {},
      decoders: {},
      class: {},
      constants: {}
    };
    function addToConfig(newConfig) {
      Object.entries(newConfig).forEach(function(_ref) {
        var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), key = _ref2[0], value = _ref2[1];
        jimpConfig[key] = _objectSpread({}, jimpConfig[key], {}, value);
      });
    }
    function addImageType(typeModule) {
      var type = typeModule();
      if (Array.isArray(type.mime)) {
        _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(type.mime));
      } else {
        Object.entries(type.mime).forEach(function(mimeType) {
          return _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(mimeType));
        });
      }
      delete type.mime;
      addToConfig(type);
    }
    function addPlugin(pluginModule) {
      var plugin = pluginModule(_core.jimpEvChange) || {};
      if (!plugin["class"] && !plugin.constants) {
        addToConfig({
          class: plugin
        });
      } else {
        addToConfig(plugin);
      }
    }
    if (configuration.types) {
      configuration.types.forEach(addImageType);
      jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, {}, jimpConfig.decoders);
      jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, {}, jimpConfig.encoders);
      jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, {}, jimpConfig.hasAlpha);
    }
    if (configuration.plugins) {
      configuration.plugins.forEach(addPlugin);
    }
    (0, _core.addJimpMethods)(jimpConfig["class"], jimpInstance);
    (0, _core.addConstants)(jimpConfig.constants, jimpInstance);
    return _core["default"];
  }
  module2.exports = exports2.default;
});

// node_modules/timm/lib/timm.js
var require_timm = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.clone = clone;
  exports2.addLast = addLast;
  exports2.addFirst = addFirst;
  exports2.removeLast = removeLast;
  exports2.removeFirst = removeFirst;
  exports2.insert = insert;
  exports2.removeAt = removeAt;
  exports2.replaceAt = replaceAt;
  exports2.getIn = getIn;
  exports2.set = set;
  exports2.setIn = setIn;
  exports2.update = update;
  exports2.updateIn = updateIn;
  exports2.merge = merge;
  exports2.mergeDeep = mergeDeep;
  exports2.mergeIn = mergeIn;
  exports2.omit = omit;
  exports2.addDefaults = addDefaults;
  exports2.default = void 0;
  /*!
   * Timm
   *
   * Immutability helpers with fast reads and acceptable writes.
   *
   * @copyright Guillermo Grau Panea 2016
   * @license MIT
   */
  var INVALID_ARGS = "INVALID_ARGS";
  var IS_DEV = process.env.NODE_ENV !== "production";
  function throwStr(msg) {
    throw new Error(msg);
  }
  function getKeysAndSymbols(obj) {
    const keys = Object.keys(obj);
    if (Object.getOwnPropertySymbols) {
      return keys.concat(Object.getOwnPropertySymbols(obj));
    }
    return keys;
  }
  var hasOwnProperty = {}.hasOwnProperty;
  function clone(obj0) {
    if (Array.isArray(obj0))
      return obj0.slice();
    const obj = obj0;
    const keys = getKeysAndSymbols(obj);
    const out = {};
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      out[key] = obj[key];
    }
    return out;
  }
  function isObject(o) {
    return o != null && typeof o === "object";
  }
  function addLast(array, val) {
    if (Array.isArray(val))
      return array.concat(val);
    return array.concat([val]);
  }
  function addFirst(array, val) {
    if (Array.isArray(val))
      return val.concat(array);
    return [val].concat(array);
  }
  function removeLast(array) {
    if (!array.length)
      return array;
    return array.slice(0, array.length - 1);
  }
  function removeFirst(array) {
    if (!array.length)
      return array;
    return array.slice(1);
  }
  function insert(array, idx, val) {
    return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
  }
  function removeAt(array, idx) {
    if (idx >= array.length || idx < 0)
      return array;
    return array.slice(0, idx).concat(array.slice(idx + 1));
  }
  function replaceAt(array, idx, newItem) {
    if (array[idx] === newItem)
      return array;
    const len = array.length;
    const result = Array(len);
    for (let i = 0; i < len; i++) {
      result[i] = array[i];
    }
    result[idx] = newItem;
    return result;
  }
  function getIn(obj, path) {
    if (!Array.isArray(path)) {
      throwStr(IS_DEV ? "A path array should be provided when calling getIn()" : INVALID_ARGS);
    }
    if (obj == null)
      return void 0;
    let ptr = obj;
    for (let i = 0; i < path.length; i++) {
      const key = path[i];
      ptr = ptr != null ? ptr[key] : void 0;
      if (ptr === void 0)
        return ptr;
    }
    return ptr;
  }
  function set(obj0, key, val) {
    let obj = obj0;
    if (obj == null)
      obj = typeof key === "number" ? [] : {};
    if (obj[key] === val)
      return obj;
    const obj2 = clone(obj);
    obj2[key] = val;
    return obj2;
  }
  function setIn(obj, path, val) {
    if (!path.length)
      return val;
    return doSetIn(obj, path, val, 0);
  }
  function doSetIn(obj, path, val, idx) {
    let newValue;
    const key = path[idx];
    if (idx === path.length - 1) {
      newValue = val;
    } else {
      const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === "number" ? [] : {};
      newValue = doSetIn(nestedObj, path, val, idx + 1);
    }
    return set(obj, key, newValue);
  }
  function update(obj, key, fnUpdate) {
    const prevVal = obj == null ? void 0 : obj[key];
    const nextVal = fnUpdate(prevVal);
    return set(obj, key, nextVal);
  }
  function updateIn(obj, path, fnUpdate) {
    const prevVal = getIn(obj, path);
    const nextVal = fnUpdate(prevVal);
    return setIn(obj, path, nextVal);
  }
  function merge(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);
  }
  function mergeDeep(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);
  }
  function mergeIn(a, path, b, c, d, e, f, ...rest) {
    let prevVal = getIn(a, path);
    if (prevVal == null)
      prevVal = {};
    let nextVal;
    if (rest.length) {
      nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);
    } else {
      nextVal = doMerge(false, false, prevVal, b, c, d, e, f);
    }
    return setIn(a, path, nextVal);
  }
  function omit(obj, attrs) {
    const omitList = Array.isArray(attrs) ? attrs : [attrs];
    let fDoSomething = false;
    for (let i = 0; i < omitList.length; i++) {
      if (hasOwnProperty.call(obj, omitList[i])) {
        fDoSomething = true;
        break;
      }
    }
    if (!fDoSomething)
      return obj;
    const out = {};
    const keys = getKeysAndSymbols(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (omitList.indexOf(key) >= 0)
        continue;
      out[key] = obj[key];
    }
    return out;
  }
  function addDefaults(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);
  }
  function doMerge(fAddDefaults, fDeep, first, ...rest) {
    let out = first;
    if (!(out != null)) {
      throwStr(IS_DEV ? "At least one object should be provided to merge()" : INVALID_ARGS);
    }
    let fChanged = false;
    for (let idx = 0; idx < rest.length; idx++) {
      const obj = rest[idx];
      if (obj == null)
        continue;
      const keys = getKeysAndSymbols(obj);
      if (!keys.length)
        continue;
      for (let j = 0; j <= keys.length; j++) {
        const key = keys[j];
        if (fAddDefaults && out[key] !== void 0)
          continue;
        let nextVal = obj[key];
        if (fDeep && isObject(out[key]) && isObject(nextVal)) {
          nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
        }
        if (nextVal === void 0 || nextVal === out[key])
          continue;
        if (!fChanged) {
          fChanged = true;
          out = clone(out);
        }
        out[key] = nextVal;
      }
    }
    return out;
  }
  var timm = {
    clone,
    addLast,
    addFirst,
    removeLast,
    removeFirst,
    insert,
    removeAt,
    replaceAt,
    getIn,
    set,
    setIn,
    update,
    updateIn,
    merge,
    mergeDeep,
    mergeIn,
    omit,
    addDefaults
  };
  var _default = timm;
  exports2.default = _default;
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS((exports2, module2) => {
  var btoa = btoa || function(buf) {
    return Buffer.from(buf).toString("base64");
  };
  function JPEGEncoder(quality) {
    var self2 = this;
    var fround = Math.round;
    var ffloor = Math.floor;
    var YTable = new Array(64);
    var UVTable = new Array(64);
    var fdtbl_Y = new Array(64);
    var fdtbl_UV = new Array(64);
    var YDC_HT;
    var UVDC_HT;
    var YAC_HT;
    var UVAC_HT;
    var bitcode = new Array(65535);
    var category = new Array(65535);
    var outputfDCTQuant = new Array(64);
    var DU = new Array(64);
    var byteout = [];
    var bytenew = 0;
    var bytepos = 7;
    var YDU = new Array(64);
    var UDU = new Array(64);
    var VDU = new Array(64);
    var clt = new Array(256);
    var RGB_YUV_TABLE = new Array(2048);
    var currentQuality;
    var ZigZag = [
      0,
      1,
      5,
      6,
      14,
      15,
      27,
      28,
      2,
      4,
      7,
      13,
      16,
      26,
      29,
      42,
      3,
      8,
      12,
      17,
      25,
      30,
      41,
      43,
      9,
      11,
      18,
      24,
      31,
      40,
      44,
      53,
      10,
      19,
      23,
      32,
      39,
      45,
      52,
      54,
      20,
      22,
      33,
      38,
      46,
      51,
      55,
      60,
      21,
      34,
      37,
      47,
      50,
      56,
      59,
      61,
      35,
      36,
      48,
      49,
      57,
      58,
      62,
      63
    ];
    var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
    var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
    var std_ac_luminance_values = [
      1,
      2,
      3,
      0,
      4,
      17,
      5,
      18,
      33,
      49,
      65,
      6,
      19,
      81,
      97,
      7,
      34,
      113,
      20,
      50,
      129,
      145,
      161,
      8,
      35,
      66,
      177,
      193,
      21,
      82,
      209,
      240,
      36,
      51,
      98,
      114,
      130,
      9,
      10,
      22,
      23,
      24,
      25,
      26,
      37,
      38,
      39,
      40,
      41,
      42,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
    var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
    var std_ac_chrominance_values = [
      0,
      1,
      2,
      3,
      17,
      4,
      5,
      33,
      49,
      6,
      18,
      65,
      81,
      7,
      97,
      113,
      19,
      34,
      50,
      129,
      8,
      20,
      66,
      145,
      161,
      177,
      193,
      9,
      35,
      51,
      82,
      240,
      21,
      98,
      114,
      209,
      10,
      22,
      36,
      52,
      225,
      37,
      241,
      23,
      24,
      25,
      26,
      38,
      39,
      40,
      41,
      42,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    function initQuantTables(sf) {
      var YQT = [
        16,
        11,
        10,
        16,
        24,
        40,
        51,
        61,
        12,
        12,
        14,
        19,
        26,
        58,
        60,
        55,
        14,
        13,
        16,
        24,
        40,
        57,
        69,
        56,
        14,
        17,
        22,
        29,
        51,
        87,
        80,
        62,
        18,
        22,
        37,
        56,
        68,
        109,
        103,
        77,
        24,
        35,
        55,
        64,
        81,
        104,
        113,
        92,
        49,
        64,
        78,
        87,
        103,
        121,
        120,
        101,
        72,
        92,
        95,
        98,
        112,
        100,
        103,
        99
      ];
      for (var i = 0; i < 64; i++) {
        var t = ffloor((YQT[i] * sf + 50) / 100);
        if (t < 1) {
          t = 1;
        } else if (t > 255) {
          t = 255;
        }
        YTable[ZigZag[i]] = t;
      }
      var UVQT = [
        17,
        18,
        24,
        47,
        99,
        99,
        99,
        99,
        18,
        21,
        26,
        66,
        99,
        99,
        99,
        99,
        24,
        26,
        56,
        99,
        99,
        99,
        99,
        99,
        47,
        66,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99
      ];
      for (var j = 0; j < 64; j++) {
        var u = ffloor((UVQT[j] * sf + 50) / 100);
        if (u < 1) {
          u = 1;
        } else if (u > 255) {
          u = 255;
        }
        UVTable[ZigZag[j]] = u;
      }
      var aasf = [
        1,
        1.387039845,
        1.306562965,
        1.175875602,
        1,
        0.785694958,
        0.5411961,
        0.275899379
      ];
      var k = 0;
      for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
          fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          k++;
        }
      }
    }
    function computeHuffmanTbl(nrcodes, std_table) {
      var codevalue = 0;
      var pos_in_table = 0;
      var HT = new Array();
      for (var k = 1; k <= 16; k++) {
        for (var j = 1; j <= nrcodes[k]; j++) {
          HT[std_table[pos_in_table]] = [];
          HT[std_table[pos_in_table]][0] = codevalue;
          HT[std_table[pos_in_table]][1] = k;
          pos_in_table++;
          codevalue++;
        }
        codevalue *= 2;
      }
      return HT;
    }
    function initHuffmanTbl() {
      YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
      UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
      YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
      UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
    }
    function initCategoryNumber() {
      var nrlower = 1;
      var nrupper = 2;
      for (var cat = 1; cat <= 15; cat++) {
        for (var nr = nrlower; nr < nrupper; nr++) {
          category[32767 + nr] = cat;
          bitcode[32767 + nr] = [];
          bitcode[32767 + nr][1] = cat;
          bitcode[32767 + nr][0] = nr;
        }
        for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
          category[32767 + nrneg] = cat;
          bitcode[32767 + nrneg] = [];
          bitcode[32767 + nrneg][1] = cat;
          bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
        }
        nrlower <<= 1;
        nrupper <<= 1;
      }
    }
    function initRGBYUVTable() {
      for (var i = 0; i < 256; i++) {
        RGB_YUV_TABLE[i] = 19595 * i;
        RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
        RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
        RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
        RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
        RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
        RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
        RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
      }
    }
    function writeBits(bs) {
      var value = bs[0];
      var posval = bs[1] - 1;
      while (posval >= 0) {
        if (value & 1 << posval) {
          bytenew |= 1 << bytepos;
        }
        posval--;
        bytepos--;
        if (bytepos < 0) {
          if (bytenew == 255) {
            writeByte(255);
            writeByte(0);
          } else {
            writeByte(bytenew);
          }
          bytepos = 7;
          bytenew = 0;
        }
      }
    }
    function writeByte(value) {
      byteout.push(value);
    }
    function writeWord(value) {
      writeByte(value >> 8 & 255);
      writeByte(value & 255);
    }
    function fDCTQuant(data, fdtbl) {
      var d0, d1, d2, d3, d4, d5, d6, d7;
      var dataOff = 0;
      var i;
      var I8 = 8;
      var I64 = 64;
      for (i = 0; i < I8; ++i) {
        d0 = data[dataOff];
        d1 = data[dataOff + 1];
        d2 = data[dataOff + 2];
        d3 = data[dataOff + 3];
        d4 = data[dataOff + 4];
        d5 = data[dataOff + 5];
        d6 = data[dataOff + 6];
        d7 = data[dataOff + 7];
        var tmp0 = d0 + d7;
        var tmp7 = d0 - d7;
        var tmp1 = d1 + d6;
        var tmp6 = d1 - d6;
        var tmp2 = d2 + d5;
        var tmp5 = d2 - d5;
        var tmp3 = d3 + d4;
        var tmp4 = d3 - d4;
        var tmp10 = tmp0 + tmp3;
        var tmp13 = tmp0 - tmp3;
        var tmp11 = tmp1 + tmp2;
        var tmp12 = tmp1 - tmp2;
        data[dataOff] = tmp10 + tmp11;
        data[dataOff + 4] = tmp10 - tmp11;
        var z1 = (tmp12 + tmp13) * 0.707106781;
        data[dataOff + 2] = tmp13 + z1;
        data[dataOff + 6] = tmp13 - z1;
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        var z5 = (tmp10 - tmp12) * 0.382683433;
        var z2 = 0.5411961 * tmp10 + z5;
        var z4 = 1.306562965 * tmp12 + z5;
        var z3 = tmp11 * 0.707106781;
        var z11 = tmp7 + z3;
        var z13 = tmp7 - z3;
        data[dataOff + 5] = z13 + z2;
        data[dataOff + 3] = z13 - z2;
        data[dataOff + 1] = z11 + z4;
        data[dataOff + 7] = z11 - z4;
        dataOff += 8;
      }
      dataOff = 0;
      for (i = 0; i < I8; ++i) {
        d0 = data[dataOff];
        d1 = data[dataOff + 8];
        d2 = data[dataOff + 16];
        d3 = data[dataOff + 24];
        d4 = data[dataOff + 32];
        d5 = data[dataOff + 40];
        d6 = data[dataOff + 48];
        d7 = data[dataOff + 56];
        var tmp0p2 = d0 + d7;
        var tmp7p2 = d0 - d7;
        var tmp1p2 = d1 + d6;
        var tmp6p2 = d1 - d6;
        var tmp2p2 = d2 + d5;
        var tmp5p2 = d2 - d5;
        var tmp3p2 = d3 + d4;
        var tmp4p2 = d3 - d4;
        var tmp10p2 = tmp0p2 + tmp3p2;
        var tmp13p2 = tmp0p2 - tmp3p2;
        var tmp11p2 = tmp1p2 + tmp2p2;
        var tmp12p2 = tmp1p2 - tmp2p2;
        data[dataOff] = tmp10p2 + tmp11p2;
        data[dataOff + 32] = tmp10p2 - tmp11p2;
        var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
        data[dataOff + 16] = tmp13p2 + z1p2;
        data[dataOff + 48] = tmp13p2 - z1p2;
        tmp10p2 = tmp4p2 + tmp5p2;
        tmp11p2 = tmp5p2 + tmp6p2;
        tmp12p2 = tmp6p2 + tmp7p2;
        var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
        var z2p2 = 0.5411961 * tmp10p2 + z5p2;
        var z4p2 = 1.306562965 * tmp12p2 + z5p2;
        var z3p2 = tmp11p2 * 0.707106781;
        var z11p2 = tmp7p2 + z3p2;
        var z13p2 = tmp7p2 - z3p2;
        data[dataOff + 40] = z13p2 + z2p2;
        data[dataOff + 24] = z13p2 - z2p2;
        data[dataOff + 8] = z11p2 + z4p2;
        data[dataOff + 56] = z11p2 - z4p2;
        dataOff++;
      }
      var fDCTQuant2;
      for (i = 0; i < I64; ++i) {
        fDCTQuant2 = data[i] * fdtbl[i];
        outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
      }
      return outputfDCTQuant;
    }
    function writeAPP0() {
      writeWord(65504);
      writeWord(16);
      writeByte(74);
      writeByte(70);
      writeByte(73);
      writeByte(70);
      writeByte(0);
      writeByte(1);
      writeByte(1);
      writeByte(0);
      writeWord(1);
      writeWord(1);
      writeByte(0);
      writeByte(0);
    }
    function writeAPP1(exifBuffer) {
      if (!exifBuffer)
        return;
      writeWord(65505);
      if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
        writeWord(exifBuffer.length + 2);
      } else {
        writeWord(exifBuffer.length + 5 + 2);
        writeByte(69);
        writeByte(120);
        writeByte(105);
        writeByte(102);
        writeByte(0);
      }
      for (var i = 0; i < exifBuffer.length; i++) {
        writeByte(exifBuffer[i]);
      }
    }
    function writeSOF0(width, height) {
      writeWord(65472);
      writeWord(17);
      writeByte(8);
      writeWord(height);
      writeWord(width);
      writeByte(3);
      writeByte(1);
      writeByte(17);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(1);
      writeByte(3);
      writeByte(17);
      writeByte(1);
    }
    function writeDQT() {
      writeWord(65499);
      writeWord(132);
      writeByte(0);
      for (var i = 0; i < 64; i++) {
        writeByte(YTable[i]);
      }
      writeByte(1);
      for (var j = 0; j < 64; j++) {
        writeByte(UVTable[j]);
      }
    }
    function writeDHT() {
      writeWord(65476);
      writeWord(418);
      writeByte(0);
      for (var i = 0; i < 16; i++) {
        writeByte(std_dc_luminance_nrcodes[i + 1]);
      }
      for (var j = 0; j <= 11; j++) {
        writeByte(std_dc_luminance_values[j]);
      }
      writeByte(16);
      for (var k = 0; k < 16; k++) {
        writeByte(std_ac_luminance_nrcodes[k + 1]);
      }
      for (var l = 0; l <= 161; l++) {
        writeByte(std_ac_luminance_values[l]);
      }
      writeByte(1);
      for (var m = 0; m < 16; m++) {
        writeByte(std_dc_chrominance_nrcodes[m + 1]);
      }
      for (var n = 0; n <= 11; n++) {
        writeByte(std_dc_chrominance_values[n]);
      }
      writeByte(17);
      for (var o = 0; o < 16; o++) {
        writeByte(std_ac_chrominance_nrcodes[o + 1]);
      }
      for (var p = 0; p <= 161; p++) {
        writeByte(std_ac_chrominance_values[p]);
      }
    }
    function writeSOS() {
      writeWord(65498);
      writeWord(12);
      writeByte(3);
      writeByte(1);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(3);
      writeByte(17);
      writeByte(0);
      writeByte(63);
      writeByte(0);
    }
    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
      var EOB = HTAC[0];
      var M16zeroes = HTAC[240];
      var pos;
      var I16 = 16;
      var I63 = 63;
      var I64 = 64;
      var DU_DCT = fDCTQuant(CDU, fdtbl);
      for (var j = 0; j < I64; ++j) {
        DU[ZigZag[j]] = DU_DCT[j];
      }
      var Diff = DU[0] - DC;
      DC = DU[0];
      if (Diff == 0) {
        writeBits(HTDC[0]);
      } else {
        pos = 32767 + Diff;
        writeBits(HTDC[category[pos]]);
        writeBits(bitcode[pos]);
      }
      var end0pos = 63;
      for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
      }
      ;
      if (end0pos == 0) {
        writeBits(EOB);
        return DC;
      }
      var i = 1;
      var lng;
      while (i <= end0pos) {
        var startpos = i;
        for (; DU[i] == 0 && i <= end0pos; ++i) {
        }
        var nrzeroes = i - startpos;
        if (nrzeroes >= I16) {
          lng = nrzeroes >> 4;
          for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
            writeBits(M16zeroes);
          nrzeroes = nrzeroes & 15;
        }
        pos = 32767 + DU[i];
        writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
        writeBits(bitcode[pos]);
        i++;
      }
      if (end0pos != I63) {
        writeBits(EOB);
      }
      return DC;
    }
    function initCharLookupTable() {
      var sfcc = String.fromCharCode;
      for (var i = 0; i < 256; i++) {
        clt[i] = sfcc(i);
      }
    }
    this.encode = function(image, quality2) {
      var time_start = new Date().getTime();
      if (quality2)
        setQuality(quality2);
      byteout = new Array();
      bytenew = 0;
      bytepos = 7;
      writeWord(65496);
      writeAPP0();
      writeAPP1(image.exifBuffer);
      writeDQT();
      writeSOF0(image.width, image.height);
      writeDHT();
      writeSOS();
      var DCY = 0;
      var DCU = 0;
      var DCV = 0;
      bytenew = 0;
      bytepos = 7;
      this.encode.displayName = "_encode_";
      var imageData = image.data;
      var width = image.width;
      var height = image.height;
      var quadWidth = width * 4;
      var tripleWidth = width * 3;
      var x, y = 0;
      var r, g, b;
      var start, p, col, row, pos;
      while (y < height) {
        x = 0;
        while (x < quadWidth) {
          start = quadWidth * y + x;
          p = start;
          col = -1;
          row = 0;
          for (pos = 0; pos < 64; pos++) {
            row = pos >> 3;
            col = (pos & 7) * 4;
            p = start + row * quadWidth + col;
            if (y + row >= height) {
              p -= quadWidth * (y + 1 + row - height);
            }
            if (x + col >= quadWidth) {
              p -= x + col - quadWidth + 4;
            }
            r = imageData[p++];
            g = imageData[p++];
            b = imageData[p++];
            YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
            UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
            VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
          }
          DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
          DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
          DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
          x += 32;
        }
        y += 8;
      }
      if (bytepos >= 0) {
        var fillbits = [];
        fillbits[1] = bytepos + 1;
        fillbits[0] = (1 << bytepos + 1) - 1;
        writeBits(fillbits);
      }
      writeWord(65497);
      if (typeof module2 === "undefined")
        return new Uint8Array(byteout);
      return Buffer.from(byteout);
      var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
      byteout = [];
      var duration = new Date().getTime() - time_start;
      return jpegDataUri;
    };
    function setQuality(quality2) {
      if (quality2 <= 0) {
        quality2 = 1;
      }
      if (quality2 > 100) {
        quality2 = 100;
      }
      if (currentQuality == quality2)
        return;
      var sf = 0;
      if (quality2 < 50) {
        sf = Math.floor(5e3 / quality2);
      } else {
        sf = Math.floor(200 - quality2 * 2);
      }
      initQuantTables(sf);
      currentQuality = quality2;
    }
    function init() {
      var time_start = new Date().getTime();
      if (!quality)
        quality = 50;
      initCharLookupTable();
      initHuffmanTbl();
      initCategoryNumber();
      initRGBYUVTable();
      setQuality(quality);
      var duration = new Date().getTime() - time_start;
    }
    init();
  }
  if (typeof module2 !== "undefined") {
    module2.exports = encode;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].encode = encode;
  }
  function encode(imgData, qu) {
    if (typeof qu === "undefined")
      qu = 50;
    var encoder = new JPEGEncoder(qu);
    var data = encoder.encode(imgData, qu);
    return {
      data,
      width: imgData.width,
      height: imgData.height
    };
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS((exports2, module2) => {
  var JpegImage = function jpegImage() {
    "use strict";
    var dctZigZag = new Int32Array([
      0,
      1,
      8,
      16,
      9,
      2,
      3,
      10,
      17,
      24,
      32,
      25,
      18,
      11,
      4,
      5,
      12,
      19,
      26,
      33,
      40,
      48,
      41,
      34,
      27,
      20,
      13,
      6,
      7,
      14,
      21,
      28,
      35,
      42,
      49,
      56,
      57,
      50,
      43,
      36,
      29,
      22,
      15,
      23,
      30,
      37,
      44,
      51,
      58,
      59,
      52,
      45,
      38,
      31,
      39,
      46,
      53,
      60,
      61,
      54,
      47,
      55,
      62,
      63
    ]);
    var dctCos1 = 4017;
    var dctSin1 = 799;
    var dctCos3 = 3406;
    var dctSin3 = 2276;
    var dctCos6 = 1567;
    var dctSin6 = 3784;
    var dctSqrt2 = 5793;
    var dctSqrt1d2 = 2896;
    function constructor() {
    }
    function buildHuffmanTable(codeLengths, values) {
      var k = 0, code = [], i, j, length = 16;
      while (length > 0 && !codeLengths[length - 1])
        length--;
      code.push({children: [], index: 0});
      var p = code[0], q;
      for (i = 0; i < length; i++) {
        for (j = 0; j < codeLengths[i]; j++) {
          p = code.pop();
          p.children[p.index] = values[k];
          while (p.index > 0) {
            if (code.length === 0)
              throw new Error("Could not recreate Huffman Table");
            p = code.pop();
          }
          p.index++;
          code.push(p);
          while (code.length <= i) {
            code.push(q = {children: [], index: 0});
            p.children[p.index] = q.children;
            p = q;
          }
          k++;
        }
        if (i + 1 < length) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
      }
      return code[0].children;
    }
    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
      var precision = frame.precision;
      var samplesPerLine = frame.samplesPerLine;
      var scanLines = frame.scanLines;
      var mcusPerLine = frame.mcusPerLine;
      var progressive = frame.progressive;
      var maxH = frame.maxH, maxV = frame.maxV;
      var startOffset = offset, bitsData = 0, bitsCount = 0;
      function readBit() {
        if (bitsCount > 0) {
          bitsCount--;
          return bitsData >> bitsCount & 1;
        }
        bitsData = data[offset++];
        if (bitsData == 255) {
          var nextByte = data[offset++];
          if (nextByte) {
            throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
          }
        }
        bitsCount = 7;
        return bitsData >>> 7;
      }
      function decodeHuffman(tree) {
        var node = tree, bit;
        while ((bit = readBit()) !== null) {
          node = node[bit];
          if (typeof node === "number")
            return node;
          if (typeof node !== "object")
            throw new Error("invalid huffman sequence");
        }
        return null;
      }
      function receive(length) {
        var n2 = 0;
        while (length > 0) {
          var bit = readBit();
          if (bit === null)
            return;
          n2 = n2 << 1 | bit;
          length--;
        }
        return n2;
      }
      function receiveAndExtend(length) {
        var n2 = receive(length);
        if (n2 >= 1 << length - 1)
          return n2;
        return n2 + (-1 << length) + 1;
      }
      function decodeBaseline(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t);
        zz[0] = component2.pred += diff;
        var k2 = 1;
        while (k2 < 64) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15)
              break;
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s);
          k2++;
        }
      }
      function decodeDCFirst(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
        zz[0] = component2.pred += diff;
      }
      function decodeDCSuccessive(component2, zz) {
        zz[0] |= readBit() << successive;
      }
      var eobrun = 0;
      function decodeACFirst(component2, zz) {
        if (eobrun > 0) {
          eobrun--;
          return;
        }
        var k2 = spectralStart, e = spectralEnd;
        while (k2 <= e) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r) - 1;
              break;
            }
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s) * (1 << successive);
          k2++;
        }
      }
      var successiveACState = 0, successiveACNextValue;
      function decodeACSuccessive(component2, zz) {
        var k2 = spectralStart, e = spectralEnd, r = 0;
        while (k2 <= e) {
          var z = dctZigZag[k2];
          var direction = zz[z] < 0 ? -1 : 1;
          switch (successiveACState) {
            case 0:
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r = rs >> 4;
              if (s === 0) {
                if (r < 15) {
                  eobrun = receive(r) + (1 << r);
                  successiveACState = 4;
                } else {
                  r = 16;
                  successiveACState = 1;
                }
              } else {
                if (s !== 1)
                  throw new Error("invalid ACn encoding");
                successiveACNextValue = receiveAndExtend(s);
                successiveACState = r ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                r--;
                if (r === 0)
                  successiveACState = successiveACState == 2 ? 3 : 0;
              }
              break;
            case 3:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                zz[z] = successiveACNextValue << successive;
                successiveACState = 0;
              }
              break;
            case 4:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              break;
          }
          k2++;
        }
        if (successiveACState === 4) {
          eobrun--;
          if (eobrun === 0)
            successiveACState = 0;
        }
      }
      function decodeMcu(component2, decode2, mcu2, row, col) {
        var mcuRow = mcu2 / mcusPerLine | 0;
        var mcuCol = mcu2 % mcusPerLine;
        var blockRow = mcuRow * component2.v + row;
        var blockCol = mcuCol * component2.h + col;
        if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
          return;
        decode2(component2, component2.blocks[blockRow][blockCol]);
      }
      function decodeBlock(component2, decode2, mcu2) {
        var blockRow = mcu2 / component2.blocksPerLine | 0;
        var blockCol = mcu2 % component2.blocksPerLine;
        if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
          return;
        decode2(component2, component2.blocks[blockRow][blockCol]);
      }
      var componentsLength = components.length;
      var component, i, j, k, n;
      var decodeFn;
      if (progressive) {
        if (spectralStart === 0)
          decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
        else
          decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      } else {
        decodeFn = decodeBaseline;
      }
      var mcu = 0, marker;
      var mcuExpected;
      if (componentsLength == 1) {
        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
      } else {
        mcuExpected = mcusPerLine * frame.mcusPerColumn;
      }
      if (!resetInterval)
        resetInterval = mcuExpected;
      var h, v;
      while (mcu < mcuExpected) {
        for (i = 0; i < componentsLength; i++)
          components[i].pred = 0;
        eobrun = 0;
        if (componentsLength == 1) {
          component = components[0];
          for (n = 0; n < resetInterval; n++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n = 0; n < resetInterval; n++) {
            for (i = 0; i < componentsLength; i++) {
              component = components[i];
              h = component.h;
              v = component.v;
              for (j = 0; j < v; j++) {
                for (k = 0; k < h; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }
            mcu++;
            if (mcu === mcuExpected)
              break;
          }
        }
        if (mcu === mcuExpected) {
          do {
            if (data[offset] === 255) {
              if (data[offset + 1] !== 0) {
                break;
              }
            }
            offset += 1;
          } while (offset < data.length - 2);
        }
        bitsCount = 0;
        marker = data[offset] << 8 | data[offset + 1];
        if (marker < 65280) {
          throw new Error("marker was not found");
        }
        if (marker >= 65488 && marker <= 65495) {
          offset += 2;
        } else
          break;
      }
      return offset - startOffset;
    }
    function buildComponentData(frame, component) {
      var lines = [];
      var blocksPerLine = component.blocksPerLine;
      var blocksPerColumn = component.blocksPerColumn;
      var samplesPerLine = blocksPerLine << 3;
      var R = new Int32Array(64), r = new Uint8Array(64);
      function quantizeAndInverse(zz, dataOut, dataIn) {
        var qt = component.quantizationTable;
        var v0, v1, v2, v3, v4, v5, v6, v7, t;
        var p = dataIn;
        var i2;
        for (i2 = 0; i2 < 64; i2++)
          p[i2] = zz[i2] * qt[i2];
        for (i2 = 0; i2 < 8; ++i2) {
          var row = 8 * i2;
          if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
            t = dctSqrt2 * p[0 + row] + 512 >> 10;
            p[0 + row] = t;
            p[1 + row] = t;
            p[2 + row] = t;
            p[3 + row] = t;
            p[4 + row] = t;
            p[5 + row] = t;
            p[6 + row] = t;
            p[7 + row] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
          v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
          v2 = p[2 + row];
          v3 = p[6 + row];
          v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
          v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
          v5 = p[3 + row] << 4;
          v6 = p[5 + row] << 4;
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 + row] = v0 + v7;
          p[7 + row] = v0 - v7;
          p[1 + row] = v1 + v6;
          p[6 + row] = v1 - v6;
          p[2 + row] = v2 + v5;
          p[5 + row] = v2 - v5;
          p[3 + row] = v3 + v4;
          p[4 + row] = v3 - v4;
        }
        for (i2 = 0; i2 < 8; ++i2) {
          var col = i2;
          if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
            t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
            p[0 * 8 + col] = t;
            p[1 * 8 + col] = t;
            p[2 * 8 + col] = t;
            p[3 * 8 + col] = t;
            p[4 * 8 + col] = t;
            p[5 * 8 + col] = t;
            p[6 * 8 + col] = t;
            p[7 * 8 + col] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
          v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
          v2 = p[2 * 8 + col];
          v3 = p[6 * 8 + col];
          v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
          v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
          v5 = p[3 * 8 + col];
          v6 = p[5 * 8 + col];
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 * 8 + col] = v0 + v7;
          p[7 * 8 + col] = v0 - v7;
          p[1 * 8 + col] = v1 + v6;
          p[6 * 8 + col] = v1 - v6;
          p[2 * 8 + col] = v2 + v5;
          p[5 * 8 + col] = v2 - v5;
          p[3 * 8 + col] = v3 + v4;
          p[4 * 8 + col] = v3 - v4;
        }
        for (i2 = 0; i2 < 64; ++i2) {
          var sample2 = 128 + (p[i2] + 8 >> 4);
          dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
        }
      }
      requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
      var i, j;
      for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
        var scanLine = blockRow << 3;
        for (i = 0; i < 8; i++)
          lines.push(new Uint8Array(samplesPerLine));
        for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
          quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
          var offset = 0, sample = blockCol << 3;
          for (j = 0; j < 8; j++) {
            var line = lines[scanLine + j];
            for (i = 0; i < 8; i++)
              line[sample + i] = r[offset++];
          }
        }
      }
      return lines;
    }
    function clampTo8bit(a) {
      return a < 0 ? 0 : a > 255 ? 255 : a;
    }
    constructor.prototype = {
      load: function load(path) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          this.parse(data);
          if (this.onload)
            this.onload();
        }.bind(this);
        xhr.send(null);
      },
      parse: function parse(data) {
        var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
        var offset = 0, length = data.length;
        function readUint16() {
          var value = data[offset] << 8 | data[offset + 1];
          offset += 2;
          return value;
        }
        function readDataBlock() {
          var length2 = readUint16();
          var array = data.subarray(offset, offset + length2 - 2);
          offset += array.length;
          return array;
        }
        function prepareComponents(frame2) {
          var maxH2 = 0, maxV2 = 0;
          var component2, componentId2;
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              if (maxH2 < component2.h)
                maxH2 = component2.h;
              if (maxV2 < component2.v)
                maxV2 = component2.v;
            }
          }
          var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
          var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
              var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
              var blocksPerLineForMcu = mcusPerLine * component2.h;
              var blocksPerColumnForMcu = mcusPerColumn * component2.v;
              var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
              var blocks = [];
              requestMemoryAllocation(blocksToAllocate * 256);
              for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                var row = [];
                for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                  row.push(new Int32Array(64));
                blocks.push(row);
              }
              component2.blocksPerLine = blocksPerLine;
              component2.blocksPerColumn = blocksPerColumn;
              component2.blocks = blocks;
            }
          }
          frame2.maxH = maxH2;
          frame2.maxV = maxV2;
          frame2.mcusPerLine = mcusPerLine;
          frame2.mcusPerColumn = mcusPerColumn;
        }
        var jfif = null;
        var adobe = null;
        var pixels = null;
        var frame, resetInterval;
        var quantizationTables = [], frames = [];
        var huffmanTablesAC = [], huffmanTablesDC = [];
        var fileMarker = readUint16();
        this.comments = [];
        if (fileMarker != 65496) {
          throw new Error("SOI not found");
        }
        fileMarker = readUint16();
        while (fileMarker != 65497) {
          var i, j, l;
          switch (fileMarker) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var appData = readDataBlock();
              if (fileMarker === 65534) {
                var comment = String.fromCharCode.apply(null, appData);
                this.comments.push(comment);
              }
              if (fileMarker === 65504) {
                if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                  jfif = {
                    version: {major: appData[5], minor: appData[6]},
                    densityUnits: appData[7],
                    xDensity: appData[8] << 8 | appData[9],
                    yDensity: appData[10] << 8 | appData[11],
                    thumbWidth: appData[12],
                    thumbHeight: appData[13],
                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                  };
                }
              }
              if (fileMarker === 65505) {
                if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                  this.exifBuffer = appData.subarray(5, appData.length);
                }
              }
              if (fileMarker === 65518) {
                if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                  adobe = {
                    version: appData[6],
                    flags0: appData[7] << 8 | appData[8],
                    flags1: appData[9] << 8 | appData[10],
                    transformCode: appData[11]
                  };
                }
              }
              break;
            case 65499:
              var quantizationTablesLength = readUint16();
              var quantizationTablesEnd = quantizationTablesLength + offset - 2;
              while (offset < quantizationTablesEnd) {
                var quantizationTableSpec = data[offset++];
                requestMemoryAllocation(64 * 4);
                var tableData = new Int32Array(64);
                if (quantizationTableSpec >> 4 === 0) {
                  for (j = 0; j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = data[offset++];
                  }
                } else if (quantizationTableSpec >> 4 === 1) {
                  for (j = 0; j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = readUint16();
                  }
                } else
                  throw new Error("DQT: invalid table spec");
                quantizationTables[quantizationTableSpec & 15] = tableData;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              readUint16();
              frame = {};
              frame.extended = fileMarker === 65473;
              frame.progressive = fileMarker === 65474;
              frame.precision = data[offset++];
              frame.scanLines = readUint16();
              frame.samplesPerLine = readUint16();
              frame.components = {};
              frame.componentsOrder = [];
              var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
              if (pixelsInFrame > maxResolutionInPixels) {
                var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
              }
              var componentsCount = data[offset++], componentId;
              var maxH = 0, maxV = 0;
              for (i = 0; i < componentsCount; i++) {
                componentId = data[offset];
                var h = data[offset + 1] >> 4;
                var v = data[offset + 1] & 15;
                var qId = data[offset + 2];
                frame.componentsOrder.push(componentId);
                frame.components[componentId] = {
                  h,
                  v,
                  quantizationIdx: qId
                };
                offset += 3;
              }
              prepareComponents(frame);
              frames.push(frame);
              break;
            case 65476:
              var huffmanLength = readUint16();
              for (i = 2; i < huffmanLength; ) {
                var huffmanTableSpec = data[offset++];
                var codeLengths = new Uint8Array(16);
                var codeLengthSum = 0;
                for (j = 0; j < 16; j++, offset++) {
                  codeLengthSum += codeLengths[j] = data[offset];
                }
                requestMemoryAllocation(16 + codeLengthSum);
                var huffmanValues = new Uint8Array(codeLengthSum);
                for (j = 0; j < codeLengthSum; j++, offset++)
                  huffmanValues[j] = data[offset];
                i += 17 + codeLengthSum;
                (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              }
              break;
            case 65501:
              readUint16();
              resetInterval = readUint16();
              break;
            case 65500:
              readUint16();
              readUint16();
              break;
            case 65498:
              var scanLength = readUint16();
              var selectorsCount = data[offset++];
              var components = [], component;
              for (i = 0; i < selectorsCount; i++) {
                component = frame.components[data[offset++]];
                var tableSpec = data[offset++];
                component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                components.push(component);
              }
              var spectralStart = data[offset++];
              var spectralEnd = data[offset++];
              var successiveApproximation = data[offset++];
              var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
              offset += processed;
              break;
            case 65535:
              if (data[offset] !== 255) {
                offset--;
              }
              break;
            default:
              if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                offset -= 3;
                break;
              }
              throw new Error("unknown JPEG marker " + fileMarker.toString(16));
          }
          fileMarker = readUint16();
        }
        if (frames.length != 1)
          throw new Error("only single frame JPEGs supported");
        for (var i = 0; i < frames.length; i++) {
          var cp = frames[i].components;
          for (var j in cp) {
            cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
            delete cp[j].quantizationIdx;
          }
        }
        this.width = frame.samplesPerLine;
        this.height = frame.scanLines;
        this.jfif = jfif;
        this.adobe = adobe;
        this.components = [];
        for (var i = 0; i < frame.componentsOrder.length; i++) {
          var component = frame.components[frame.componentsOrder[i]];
          this.components.push({
            lines: buildComponentData(frame, component),
            scaleX: component.h / frame.maxH,
            scaleY: component.v / frame.maxV
          });
        }
      },
      getData: function getData(width, height) {
        var scaleX = this.width / width, scaleY = this.height / height;
        var component1, component2, component3, component4;
        var component1Line, component2Line, component3Line, component4Line;
        var x, y;
        var offset = 0;
        var Y, Cb, Cr, K, C, M, Ye, R, G, B;
        var colorTransform;
        var dataLength = width * height * this.components.length;
        requestMemoryAllocation(dataLength);
        var data = new Uint8Array(dataLength);
        switch (this.components.length) {
          case 1:
            component1 = this.components[0];
            for (y = 0; y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              for (x = 0; x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data[offset++] = Y;
              }
            }
            break;
          case 2:
            component1 = this.components[0];
            component2 = this.components[1];
            for (y = 0; y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              for (x = 0; x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data[offset++] = Y;
                Y = component2Line[0 | x * component2.scaleX * scaleX];
                data[offset++] = Y;
              }
            }
            break;
          case 3:
            colorTransform = true;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            for (y = 0; y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              for (x = 0; x < width; x++) {
                if (!colorTransform) {
                  R = component1Line[0 | x * component1.scaleX * scaleX];
                  G = component2Line[0 | x * component2.scaleX * scaleX];
                  B = component3Line[0 | x * component3.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  R = clampTo8bit(Y + 1.402 * (Cr - 128));
                  G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  B = clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data[offset++] = R;
                data[offset++] = G;
                data[offset++] = B;
              }
            }
            break;
          case 4:
            if (!this.adobe)
              throw new Error("Unsupported color mode (4 components)");
            colorTransform = false;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            component4 = this.components[3];
            for (y = 0; y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
              for (x = 0; x < width; x++) {
                if (!colorTransform) {
                  C = component1Line[0 | x * component1.scaleX * scaleX];
                  M = component2Line[0 | x * component2.scaleX * scaleX];
                  Ye = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                  C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                  M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data[offset++] = 255 - C;
                data[offset++] = 255 - M;
                data[offset++] = 255 - Ye;
                data[offset++] = 255 - K;
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return data;
      },
      copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
        var width = imageData.width, height = imageData.height;
        var imageDataArray = imageData.data;
        var data = this.getData(width, height);
        var i = 0, j = 0, x, y;
        var Y, K, C, M, R, G, B;
        switch (this.components.length) {
          case 1:
            for (y = 0; y < height; y++) {
              for (x = 0; x < width; x++) {
                Y = data[i++];
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 3:
            for (y = 0; y < height; y++) {
              for (x = 0; x < width; x++) {
                R = data[i++];
                G = data[i++];
                B = data[i++];
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 4:
            for (y = 0; y < height; y++) {
              for (x = 0; x < width; x++) {
                C = data[i++];
                M = data[i++];
                Y = data[i++];
                K = data[i++];
                R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      }
    };
    var totalBytesAllocated = 0;
    var maxMemoryUsageBytes = 0;
    function requestMemoryAllocation(increaseAmount = 0) {
      var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
      if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
        var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
        throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
      }
      totalBytesAllocated = totalMemoryImpactBytes;
    }
    constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
      totalBytesAllocated = 0;
      maxMemoryUsageBytes = maxMemoryUsageBytes_;
    };
    constructor.getBytesAllocated = function() {
      return totalBytesAllocated;
    };
    constructor.requestMemoryAllocation = requestMemoryAllocation;
    return constructor;
  }();
  if (typeof module2 !== "undefined") {
    module2.exports = decode;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].decode = decode;
  }
  function decode(jpegData, userOpts = {}) {
    var defaultOpts = {
      colorTransform: void 0,
      useTArray: false,
      formatAsRGBA: true,
      tolerantDecoding: true,
      maxResolutionInMP: 100,
      maxMemoryUsageInMB: 512
    };
    var opts = {...defaultOpts, ...userOpts};
    var arr = new Uint8Array(jpegData);
    var decoder = new JpegImage();
    decoder.opts = opts;
    JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
    decoder.parse(arr);
    var channels = opts.formatAsRGBA ? 4 : 3;
    var bytesNeeded = decoder.width * decoder.height * channels;
    try {
      JpegImage.requestMemoryAllocation(bytesNeeded);
      var image = {
        width: decoder.width,
        height: decoder.height,
        exifBuffer: decoder.exifBuffer,
        data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
      };
      if (decoder.comments.length > 0) {
        image["comments"] = decoder.comments;
      }
    } catch (err) {
      if (err instanceof RangeError) {
        throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
      } else {
        throw err;
      }
    }
    decoder.copyToImageData(image, opts.formatAsRGBA);
    return image;
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS((exports2, module2) => {
  var encode = require_encoder();
  var decode = require_decoder();
  module2.exports = {
    encode,
    decode
  };
});

// node_modules/@jimp/jpeg/dist/index.js
var require_dist4 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _jpegJs = _interopRequireDefault(require_jpeg_js());
  var _utils = require_dist();
  var MIME_TYPE = "image/jpeg";
  var _default = function _default2() {
    return {
      mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["jpeg", "jpg", "jpe"]),
      constants: {
        MIME_JPEG: MIME_TYPE
      },
      decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _jpegJs["default"].decode),
      encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image) {
        return _jpegJs["default"].encode(image.bitmap, image._quality).data;
      }),
      class: {
        _quality: 100,
        quality: function quality(n, cb) {
          if (typeof n !== "number") {
            return _utils.throwError.call(this, "n must be a number", cb);
          }
          if (n < 0 || n > 100) {
            return _utils.throwError.call(this, "n must be a number 0 - 100", cb);
          }
          this._quality = Math.round(n);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var Stream = require("stream");
  var ChunkStream = module2.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(function() {
      this._process();
      if (this._paused && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }.bind(this));
  };
  ChunkStream.prototype.write = function(data, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    var dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = new Buffer(data, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding) {
    if (data) {
      this.write(data, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    var smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    var pos = 0;
    var count = 0;
    var data = new Buffer(read.length);
    while (pos < read.length) {
      var buf = this._buffers[count++];
      var len = Math.min(buf.length, read.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        var read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS((exports2) => {
  "use strict";
  var imagePasses = [
    {
      x: [0],
      y: [0]
    },
    {
      x: [4],
      y: [0]
    },
    {
      x: [0, 4],
      y: [4]
    },
    {
      x: [2, 6],
      y: [0, 4]
    },
    {
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  exports2.getImagePasses = function(width, height) {
    var images = [];
    var xLeftOver = width % 8;
    var yLeftOver = height % 8;
    var xRepeats = (width - xLeftOver) / 8;
    var yRepeats = (height - yLeftOver) / 8;
    for (var i = 0; i < imagePasses.length; i++) {
      var pass = imagePasses[i];
      var passWidth = xRepeats * pass.x.length;
      var passHeight = yRepeats * pass.y.length;
      for (var j = 0; j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (j = 0; j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({width: passWidth, height: passHeight, index: i});
      }
    }
    return images;
  };
  exports2.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      var outerXLeftOver = x % imagePasses[pass].x.length;
      var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      var outerYLeftOver = y % imagePasses[pass].y.length;
      var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function paethPredictor(left, above, upLeft) {
    var paeth = left + above - upLeft;
    var pLeft = Math.abs(paeth - left);
    var pAbove = Math.abs(paeth - above);
    var pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS((exports2, module2) => {
  "use strict";
  var interlaceUtils = require_interlace();
  var paethPredictor = require_paeth_predictor();
  function getByteWidth(width, bpp, depth) {
    var byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  var Filter = module2.exports = function(bitmapInfo, dependencies) {
    var width = bitmapInfo.width;
    var height = bitmapInfo.height;
    var interlace = bitmapInfo.interlace;
    var bpp = bitmapInfo.bpp;
    var depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace) {
      var passes = interlaceUtils.getImagePasses(width, height);
      for (var i = 0; i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f3Up = lastLine ? lastLine[x] : 0;
      var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      var f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f4Up = lastLine ? lastLine[x] : 0;
      var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    var filter = rawData[0];
    var unfilteredLine;
    var currentImage = this._images[this._imageIndex];
    var byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = new Buffer(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var ChunkStream = require_chunkstream();
  var Filter = require_filter_parse();
  var FilterAsync = module2.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    var buffers = [];
    var that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util.inherits(FilterAsync, ChunkStream);
});

// node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS((exports2, module2) => {
  "use strict";
  var crcTable = [];
  (function() {
    for (var i = 0; i < 256; i++) {
      var currentCrc = i;
      for (var j = 0; j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  var CrcCalculator = module2.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (var i = 0; i < data.length; i++) {
      this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    var crc = -1;
    for (var i = 0; i < buf.length; i++) {
      crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  var CrcCalculator = require_crc();
  var Parser = module2.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {
    };
  };
  Parser.prototype.start = function() {
    this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data) {
    var signature = constants.PNG_SIGNATURE;
    for (var i = 0; i < signature.length; i++) {
      if (data[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data) {
    var length = data.readUInt32BE(0);
    var type = data.readUInt32BE(4);
    var name = "";
    for (var i = 4; i < 8; i++) {
      name += String.fromCharCode(data[i]);
    }
    var ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator();
    this._crc.write(new Buffer(name));
    if (this._chunks[type]) {
      return this._chunks[type](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data) {
    var fileCrc = data.readInt32BE(0);
    var calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    var width = data.readUInt32BE(0);
    var height = data.readUInt32BE(4);
    var depth = data[8];
    var colorType = data[9];
    var compr = data[10];
    var filter = data[11];
    var interlace = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace !== 0 && interlace !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace),
      palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    var entries = Math.floor(data.length / 3);
    for (var i = 0; i < entries; i++) {
      this._palette.push([
        data[i * 3],
        data[i * 3 + 1],
        data[i * 3 + 2],
        255
      ]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (var i = 0; i < data.length; i++) {
        this._palette[i][3] = data[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants.COLORTYPE_COLOR) {
      this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    var leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS((exports2) => {
  "use strict";
  var interlaceUtils = require_interlace();
  var pixelBppMapper = [
    function() {
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      var pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      var pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    function() {
    },
    function(pxData, pixelData, pxPos, maxBit) {
      var pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      var pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    var leftOver = [];
    var i = 0;
    function split() {
      if (i === data.length) {
        throw new Error("Ran out of data");
      }
      var byte = data[i];
      i++;
      var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        var returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i !== data.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    var imageWidth = image.width;
    var imageHeight = image.height;
    var imagePass = image.index;
    for (var y = 0; y < imageHeight; y++) {
      for (var x = 0; x < imageWidth; x++) {
        var pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    var imageWidth = image.width;
    var imageHeight = image.height;
    var imagePass = image.index;
    for (var y = 0; y < imageHeight; y++) {
      for (var x = 0; x < imageWidth; x++) {
        var pixelData = bits.get(bpp);
        var pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  exports2.dataToBitMap = function(data, bitmapInfo) {
    var width = bitmapInfo.width;
    var height = bitmapInfo.height;
    var depth = bitmapInfo.depth;
    var bpp = bitmapInfo.bpp;
    var interlace = bitmapInfo.interlace;
    if (depth !== 8) {
      var bits = bitRetriever(data, depth);
    }
    var pxData;
    if (depth <= 8) {
      pxData = new Buffer(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    var maxBit = Math.pow(2, depth) - 1;
    var rawPos = 0;
    var images;
    var getPxPos;
    if (interlace) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      var nonInterlacedPxPos = 0;
      getPxPos = function() {
        var returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{width, height}];
    }
    for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS((exports2, module2) => {
  "use strict";
  function dePalette(indata, outdata, width, height, palette) {
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    var maxOutSample = 255;
    var maxInSample = Math.pow(2, depth) - 1;
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  }
  module2.exports = function(indata, imageData) {
    var depth = imageData.depth;
    var width = imageData.width;
    var height = imageData.height;
    var colorType = imageData.colorType;
    var transColor = imageData.transColor;
    var palette = imageData.palette;
    var outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8) {
        if (depth === 16) {
          outdata = new Buffer(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var zlib = require("zlib");
  var ChunkStream = require_chunkstream();
  var FilterAsync = require_filter_parse_async();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  var ParserAsync = module2.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        var imageSize = rowSize * this._bitmapInfo.height;
        var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({chunkSize});
        var leftToInflate = imageSize;
        var emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        var filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
    this.destroySoon();
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    try {
      var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
      var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  module2.exports = function(dataIn, width, height, options) {
    var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      var bigEndian = function() {
        var buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(0, 256, true);
        return new Int16Array(buffer)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    var maxValue = 255;
    var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    var outData = new Buffer(width * height * outBpp);
    var inIndex = 0;
    var outIndex = 0;
    var bgColor = options.bgColor || {};
    if (bgColor.red === void 0) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === void 0) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === void 0) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      var red;
      var green;
      var blue;
      var alpha = maxValue;
      switch (options.inputColorType) {
        case constants.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_COLOR:
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        case constants.COLORTYPE_GRAYSCALE:
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
        }
      }
      return {red, green, blue, alpha};
    }
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var rgba = getRGBA(data, inIndex);
        switch (options.colorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
          case constants.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants.COLORTYPE_ALPHA:
          case constants.COLORTYPE_GRAYSCALE:
            var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS((exports2, module2) => {
  "use strict";
  var paethPredictor = require_paeth_predictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (var x = 0; x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    var sum = 0;
    var length = pxPos + byteWidth;
    for (var i = pxPos; i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (var x = 0; x < byteWidth; x++) {
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    var sum = 0;
    var length = pxPos + byteWidth;
    for (var x = pxPos; x < length; x++) {
      var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      var val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  module2.exports = function(pxData, width, height, options, bpp) {
    var filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    var byteWidth = width * bpp;
    var rawPos = 0;
    var pxPos = 0;
    var rawData = new Buffer((byteWidth + 1) * height);
    var sel = filterTypes[0];
    for (var y = 0; y < height; y++) {
      if (filterTypes.length > 1) {
        var min = Infinity;
        for (var i = 0; i < filterTypes.length; i++) {
          var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  var CrcStream = require_crc();
  var bitPacker = require_bitpacker();
  var filter = require_filter_pack();
  var zlib = require("zlib");
  var Packer = module2.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    var packedData = bitPacker(data, width, height, this._options);
    var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    var filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type, data) {
    var len = data ? data.length : 0;
    var buf = new Buffer(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    var buf = new Buffer(4);
    buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
    return this._packChunk(constants.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    var buf = new Buffer(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants.TYPE_IEND, null);
  };
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var Stream = require("stream");
  var constants = require_constants2();
  var Packer = require_packer();
  var PackerAsync = module2.exports = function(opt) {
    Stream.call(this);
    var options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", new Buffer(constants.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    var filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this));
    this._deflate.on("end", function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this));
    this._deflate.end(filteredData);
  };
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert").ok;
  var zlib = require("zlib");
  var util = require("util");
  var kMaxLength = require("buffer").kMaxLength;
  function Inflate(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
      opts.chunkSize = zlib.Z_MIN_CHUNK;
    }
    zlib.Inflate.call(this, opts);
    this._offset = this._offset === void 0 ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  }
  function createInflate(opts) {
    return new Inflate(opts);
  }
  function _close(engine, callback) {
    if (callback) {
      process.nextTick(callback);
    }
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  }
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    var self2 = this;
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var leftToInflate = this._maxLength;
    var inOff = 0;
    var buffers = [];
    var nread = 0;
    var error;
    this.on("error", function(err) {
      error = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      var have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    do {
      var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
    }
    var buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util.inherits(Inflate, zlib.Inflate);
  function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    var flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  }
  function inflateSync(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  }
  module2.exports = exports2 = inflateSync;
  exports2.Inflate = Inflate;
  exports2.createInflate = createInflate;
  exports2.inflateSync = inflateSync;
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS((exports2, module2) => {
  "use strict";
  var SyncReader = module2.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      var read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        var buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      return new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      return new Error("unrecognised content at end of stream");
    }
  };
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS((exports2) => {
  "use strict";
  var SyncReader = require_sync_reader();
  var Filter = require_filter_parse();
  exports2.process = function(inBuffer, bitmapInfo) {
    var outBuffers = [];
    var reader = new SyncReader(inBuffer);
    var filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {
      }
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS((exports2, module2) => {
  "use strict";
  var hasSyncZlib = true;
  var zlib = require("zlib");
  var inflateSync = require_sync_inflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = require_sync_reader();
  var FilterSync = require_filter_parse_sync();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  module2.exports = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    var err;
    function handleError(_err_) {
      err = _err_;
    }
    var metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    var gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    var inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    var reader = new SyncReader(buffer);
    var parser = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser.start();
    reader.process();
    if (err) {
      throw err;
    }
    var inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    var inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      var imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {chunkSize: imageSize, maxLength: imageSize});
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    var unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS((exports2, module2) => {
  "use strict";
  var hasSyncZlib = true;
  var zlib = require("zlib");
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants = require_constants2();
  var Packer = require_packer();
  module2.exports = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    var options = opt || {};
    var packer = new Packer(options);
    var chunks = [];
    chunks.push(new Buffer(constants.PNG_SIGNATURE));
    chunks.push(packer.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer.packGAMA(metaData.gamma));
    }
    var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
    var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer.packIDAT(compressedData));
    chunks.push(packer.packIEND());
    return Buffer.concat(chunks);
  };
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS((exports2) => {
  "use strict";
  var parse = require_parser_sync();
  var pack = require_packer_sync();
  exports2.read = function(buffer, options) {
    return parse(buffer, options || {});
  };
  exports2.write = function(png, options) {
    return pack(png, options);
  };
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS((exports2) => {
  "use strict";
  var util = require("util");
  var Stream = require("stream");
  var Parser = require_parser_async();
  var Packer = require_packer_async();
  var PNGSync = require_png_sync();
  var PNG = exports2.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", function(data) {
      this.data = data;
      this.emit("parsed", data);
    }.bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this));
    return this;
  };
  PNG.prototype.parse = function(data, callback) {
    if (callback) {
      var onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (var y = 0; y < height; y++) {
      src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (var y = 0; y < src.height; y++) {
        for (var x = 0; x < src.width; x++) {
          var idx = src.width * y + x << 2;
          for (var i = 0; i < 3; i++) {
            var sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
});

// node_modules/@jimp/png/dist/index.js
var require_dist5 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _pngjs = require_png();
  var _utils = require_dist();
  var MIME_TYPE = "image/png";
  var PNG_FILTER_AUTO = -1;
  var PNG_FILTER_NONE = 0;
  var PNG_FILTER_SUB = 1;
  var PNG_FILTER_UP = 2;
  var PNG_FILTER_AVERAGE = 3;
  var PNG_FILTER_PATH = 4;
  var _default = function _default2() {
    return {
      mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["png"]),
      constants: {
        MIME_PNG: MIME_TYPE,
        PNG_FILTER_AUTO,
        PNG_FILTER_NONE,
        PNG_FILTER_SUB,
        PNG_FILTER_UP,
        PNG_FILTER_AVERAGE,
        PNG_FILTER_PATH
      },
      hasAlpha: (0, _defineProperty2["default"])({}, MIME_TYPE, true),
      decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _pngjs.PNG.sync.read),
      encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
        var png = new _pngjs.PNG({
          width: data.bitmap.width,
          height: data.bitmap.height
        });
        png.data = data.bitmap.data;
        return _pngjs.PNG.sync.write(png, {
          width: data.bitmap.width,
          height: data.bitmap.height,
          deflateLevel: data._deflateLevel,
          deflateStrategy: data._deflateStrategy,
          filterType: data._filterType,
          colorType: typeof data._colorType === "number" ? data._colorType : data._rgba ? 6 : 2,
          inputHasAlpha: data._rgba
        });
      }),
      class: {
        _deflateLevel: 9,
        _deflateStrategy: 3,
        _filterType: PNG_FILTER_AUTO,
        _colorType: null,
        deflateLevel: function deflateLevel(l, cb) {
          if (typeof l !== "number") {
            return _utils.throwError.call(this, "l must be a number", cb);
          }
          if (l < 0 || l > 9) {
            return _utils.throwError.call(this, "l must be a number 0 - 9", cb);
          }
          this._deflateLevel = Math.round(l);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        deflateStrategy: function deflateStrategy(s, cb) {
          if (typeof s !== "number") {
            return _utils.throwError.call(this, "s must be a number", cb);
          }
          if (s < 0 || s > 3) {
            return _utils.throwError.call(this, "s must be a number 0 - 3", cb);
          }
          this._deflateStrategy = Math.round(s);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        filterType: function filterType(f, cb) {
          if (typeof f !== "number") {
            return _utils.throwError.call(this, "n must be a number", cb);
          }
          if (f < -1 || f > 4) {
            return _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb);
          }
          this._filterType = Math.round(f);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        colorType: function colorType(s, cb) {
          if (typeof s !== "number") {
            return _utils.throwError.call(this, "s must be a number", cb);
          }
          if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {
            return _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb);
          }
          this._colorType = Math.round(s);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/bmp-js/lib/encoder.js
var require_encoder2 = __commonJS((exports2, module2) => {
  function BmpEncoder(imgData) {
    this.buffer = imgData.data;
    this.width = imgData.width;
    this.height = imgData.height;
    this.extraBytes = this.width % 4;
    this.rgbSize = this.height * (3 * this.width + this.extraBytes);
    this.headerInfoSize = 40;
    this.data = [];
    this.flag = "BM";
    this.reserved = 0;
    this.offset = 54;
    this.fileSize = this.rgbSize + this.offset;
    this.planes = 1;
    this.bitPP = 24;
    this.compress = 0;
    this.hr = 0;
    this.vr = 0;
    this.colors = 0;
    this.importantColors = 0;
  }
  BmpEncoder.prototype.encode = function() {
    var tempBuffer = new Buffer(this.offset + this.rgbSize);
    this.pos = 0;
    tempBuffer.write(this.flag, this.pos, 2);
    this.pos += 2;
    tempBuffer.writeUInt32LE(this.fileSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.reserved, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.offset, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.width, this.pos);
    this.pos += 4;
    tempBuffer.writeInt32LE(-this.height, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt16LE(this.planes, this.pos);
    this.pos += 2;
    tempBuffer.writeUInt16LE(this.bitPP, this.pos);
    this.pos += 2;
    tempBuffer.writeUInt32LE(this.compress, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.rgbSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.hr, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.vr, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.colors, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.importantColors, this.pos);
    this.pos += 4;
    var i = 0;
    var rowBytes = 3 * this.width + this.extraBytes;
    for (var y = 0; y < this.height; y++) {
      for (var x = 0; x < this.width; x++) {
        var p = this.pos + y * rowBytes + x * 3;
        i++;
        tempBuffer[p] = this.buffer[i++];
        tempBuffer[p + 1] = this.buffer[i++];
        tempBuffer[p + 2] = this.buffer[i++];
      }
      if (this.extraBytes > 0) {
        var fillOffset = this.pos + y * rowBytes + this.width * 3;
        tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
      }
    }
    return tempBuffer;
  };
  module2.exports = function(imgData, quality) {
    if (typeof quality === "undefined")
      quality = 100;
    var encoder = new BmpEncoder(imgData);
    var data = encoder.encode();
    return {
      data,
      width: imgData.width,
      height: imgData.height
    };
  };
});

// node_modules/bmp-js/lib/decoder.js
var require_decoder2 = __commonJS((exports2, module2) => {
  function BmpDecoder(buffer, is_with_alpha) {
    this.pos = 0;
    this.buffer = buffer;
    this.is_with_alpha = !!is_with_alpha;
    this.bottom_up = true;
    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
    if (this.flag != "BM")
      throw new Error("Invalid BMP File");
    this.parseHeader();
    this.parseRGBA();
  }
  BmpDecoder.prototype.parseHeader = function() {
    this.fileSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.reserved = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.offset = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.headerSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.width = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.height = this.buffer.readInt32LE(this.pos);
    this.pos += 4;
    this.planes = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.bitPP = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.compress = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.rawSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.hr = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.vr = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.colors = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.importantColors = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    if (this.bitPP === 16 && this.is_with_alpha) {
      this.bitPP = 15;
    }
    if (this.bitPP < 15) {
      var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(len);
      for (var i = 0; i < len; i++) {
        var blue = this.buffer.readUInt8(this.pos++);
        var green = this.buffer.readUInt8(this.pos++);
        var red = this.buffer.readUInt8(this.pos++);
        var quad = this.buffer.readUInt8(this.pos++);
        this.palette[i] = {
          red,
          green,
          blue,
          quad
        };
      }
    }
    if (this.height < 0) {
      this.height *= -1;
      this.bottom_up = false;
    }
  };
  BmpDecoder.prototype.parseRGBA = function() {
    var bitn = "bit" + this.bitPP;
    var len = this.width * this.height * 4;
    this.data = new Buffer(len);
    this[bitn]();
  };
  BmpDecoder.prototype.bit1 = function() {
    var xlen = Math.ceil(this.width / 8);
    var mode = xlen % 4;
    var y = this.height >= 0 ? this.height - 1 : -this.height;
    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0; x < xlen; x++) {
        var b = this.buffer.readUInt8(this.pos++);
        var location = line * this.width * 4 + x * 8 * 4;
        for (var i = 0; i < 8; i++) {
          if (x * 8 + i < this.width) {
            var rgb = this.palette[b >> 7 - i & 1];
            this.data[location + i * 4] = 0;
            this.data[location + i * 4 + 1] = rgb.blue;
            this.data[location + i * 4 + 2] = rgb.green;
            this.data[location + i * 4 + 3] = rgb.red;
          } else {
            break;
          }
        }
      }
      if (mode != 0) {
        this.pos += 4 - mode;
      }
    }
  };
  BmpDecoder.prototype.bit4 = function() {
    if (this.compress == 2) {
      let setPixelData2 = function(rgbIndex) {
        var rgb2 = this.palette[rgbIndex];
        this.data[location] = 0;
        this.data[location + 1] = rgb2.blue;
        this.data[location + 2] = rgb2.green;
        this.data[location + 3] = rgb2.red;
        location += 4;
      };
      var setPixelData = setPixelData2;
      this.data.fill(255);
      var location = 0;
      var lines = this.bottom_up ? this.height - 1 : 0;
      var low_nibble = false;
      while (location < this.data.length) {
        var a = this.buffer.readUInt8(this.pos++);
        var b = this.buffer.readUInt8(this.pos++);
        if (a == 0) {
          if (b == 0) {
            if (this.bottom_up) {
              lines--;
            } else {
              lines++;
            }
            location = lines * this.width * 4;
            low_nibble = false;
            continue;
          } else if (b == 1) {
            break;
          } else if (b == 2) {
            var x = this.buffer.readUInt8(this.pos++);
            var y = this.buffer.readUInt8(this.pos++);
            if (this.bottom_up) {
              lines -= y;
            } else {
              lines += y;
            }
            location += y * this.width * 4 + x * 4;
          } else {
            var c = this.buffer.readUInt8(this.pos++);
            for (var i = 0; i < b; i++) {
              if (low_nibble) {
                setPixelData2.call(this, c & 15);
              } else {
                setPixelData2.call(this, (c & 240) >> 4);
              }
              if (i & 1 && i + 1 < b) {
                c = this.buffer.readUInt8(this.pos++);
              }
              low_nibble = !low_nibble;
            }
            if ((b + 1 >> 1 & 1) == 1) {
              this.pos++;
            }
          }
        } else {
          for (var i = 0; i < a; i++) {
            if (low_nibble) {
              setPixelData2.call(this, b & 15);
            } else {
              setPixelData2.call(this, (b & 240) >> 4);
            }
            low_nibble = !low_nibble;
          }
        }
      }
    } else {
      var xlen = Math.ceil(this.width / 2);
      var mode = xlen % 4;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < xlen; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 2 * 4;
          var before = b >> 4;
          var after = b & 15;
          var rgb = this.palette[before];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;
          if (x * 2 + 1 >= this.width)
            break;
          rgb = this.palette[after];
          this.data[location + 4] = 0;
          this.data[location + 4 + 1] = rgb.blue;
          this.data[location + 4 + 2] = rgb.green;
          this.data[location + 4 + 3] = rgb.red;
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    }
  };
  BmpDecoder.prototype.bit8 = function() {
    if (this.compress == 1) {
      let setPixelData2 = function(rgbIndex) {
        var rgb2 = this.palette[rgbIndex];
        this.data[location] = 0;
        this.data[location + 1] = rgb2.blue;
        this.data[location + 2] = rgb2.green;
        this.data[location + 3] = rgb2.red;
        location += 4;
      };
      var setPixelData = setPixelData2;
      this.data.fill(255);
      var location = 0;
      var lines = this.bottom_up ? this.height - 1 : 0;
      while (location < this.data.length) {
        var a = this.buffer.readUInt8(this.pos++);
        var b = this.buffer.readUInt8(this.pos++);
        if (a == 0) {
          if (b == 0) {
            if (this.bottom_up) {
              lines--;
            } else {
              lines++;
            }
            location = lines * this.width * 4;
            continue;
          } else if (b == 1) {
            break;
          } else if (b == 2) {
            var x = this.buffer.readUInt8(this.pos++);
            var y = this.buffer.readUInt8(this.pos++);
            if (this.bottom_up) {
              lines -= y;
            } else {
              lines += y;
            }
            location += y * this.width * 4 + x * 4;
          } else {
            for (var i = 0; i < b; i++) {
              var c = this.buffer.readUInt8(this.pos++);
              setPixelData2.call(this, c);
            }
            if (b & true) {
              this.pos++;
            }
          }
        } else {
          for (var i = 0; i < a; i++) {
            setPixelData2.call(this, b);
          }
        }
      }
    } else {
      var mode = this.width % 4;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          if (b < this.palette.length) {
            var rgb = this.palette[b];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
          } else {
            this.data[location] = 0;
            this.data[location + 1] = 255;
            this.data[location + 2] = 255;
            this.data[location + 3] = 255;
          }
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    }
  };
  BmpDecoder.prototype.bit15 = function() {
    var dif_w = this.width % 3;
    var _11111 = parseInt("11111", 2), _1_5 = _11111;
    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0; x < this.width; x++) {
        var B = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        var blue = (B & _1_5) / _1_5 * 255 | 0;
        var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
        var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
        var alpha = B >> 15 ? 255 : 0;
        var location = line * this.width * 4 + x * 4;
        this.data[location] = alpha;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += dif_w;
    }
  };
  BmpDecoder.prototype.bit16 = function() {
    var dif_w = this.width % 2 * 2;
    this.maskRed = 31744;
    this.maskGreen = 992;
    this.maskBlue = 31;
    this.mask0 = 0;
    if (this.compress == 3) {
      this.maskRed = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskGreen = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskBlue = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.mask0 = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
    }
    var ns = [0, 0, 0];
    for (var i = 0; i < 16; i++) {
      if (this.maskRed >> i & 1)
        ns[0]++;
      if (this.maskGreen >> i & 1)
        ns[1]++;
      if (this.maskBlue >> i & 1)
        ns[2]++;
    }
    ns[1] += ns[0];
    ns[2] += ns[1];
    ns[0] = 8 - ns[0];
    ns[1] -= 8;
    ns[2] -= 8;
    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0; x < this.width; x++) {
        var B = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        var blue = (B & this.maskBlue) << ns[0];
        var green = (B & this.maskGreen) >> ns[1];
        var red = (B & this.maskRed) >> ns[2];
        var location = line * this.width * 4 + x * 4;
        this.data[location] = 0;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += dif_w;
    }
  };
  BmpDecoder.prototype.bit24 = function() {
    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0; x < this.width; x++) {
        var blue = this.buffer.readUInt8(this.pos++);
        var green = this.buffer.readUInt8(this.pos++);
        var red = this.buffer.readUInt8(this.pos++);
        var location = line * this.width * 4 + x * 4;
        this.data[location] = 0;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += this.width % 4;
    }
  };
  BmpDecoder.prototype.bit32 = function() {
    if (this.compress == 3) {
      this.maskRed = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskGreen = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskBlue = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.mask0 = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var alpha = this.buffer.readUInt8(this.pos++);
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
      }
    } else {
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var alpha = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
      }
    }
  };
  BmpDecoder.prototype.getData = function() {
    return this.data;
  };
  module2.exports = function(bmpData) {
    var decoder = new BmpDecoder(bmpData);
    return decoder;
  };
});

// node_modules/bmp-js/index.js
var require_bmp_js = __commonJS((exports2, module2) => {
  var encode = require_encoder2();
  var decode = require_decoder2();
  module2.exports = {
    encode,
    decode
  };
});

// node_modules/@jimp/bmp/dist/index.js
var require_dist6 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _bmpJs = _interopRequireDefault(require_bmp_js());
  var _utils = require_dist();
  var MIME_TYPE = "image/bmp";
  var MIME_TYPE_SECOND = "image/x-ms-bmp";
  function toAGBR(image) {
    return (0, _utils.scan)(image, 0, 0, image.bitmap.width, image.bitmap.height, function(x, y, index) {
      var red = this.bitmap.data[index + 0];
      var green = this.bitmap.data[index + 1];
      var blue = this.bitmap.data[index + 2];
      var alpha = this.bitmap.data[index + 3];
      this.bitmap.data[index + 0] = alpha;
      this.bitmap.data[index + 1] = blue;
      this.bitmap.data[index + 2] = green;
      this.bitmap.data[index + 3] = red;
    }).bitmap;
  }
  function fromAGBR(bitmap) {
    return (0, _utils.scan)({
      bitmap
    }, 0, 0, bitmap.width, bitmap.height, function(x, y, index) {
      var alpha = this.bitmap.data[index + 0];
      var blue = this.bitmap.data[index + 1];
      var green = this.bitmap.data[index + 2];
      var red = this.bitmap.data[index + 3];
      this.bitmap.data[index + 0] = red;
      this.bitmap.data[index + 1] = green;
      this.bitmap.data[index + 2] = blue;
      this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 255;
    }).bitmap;
  }
  var decode = function decode2(data) {
    return fromAGBR(_bmpJs["default"].decode(data));
  };
  var encode = function encode2(image) {
    return _bmpJs["default"].encode(toAGBR(image)).data;
  };
  var _default = function _default2() {
    var _decoders, _encoders;
    return {
      mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["bmp"]),
      constants: {
        MIME_BMP: MIME_TYPE,
        MIME_X_MS_BMP: MIME_TYPE_SECOND
      },
      decoders: (_decoders = {}, (0, _defineProperty2["default"])(_decoders, MIME_TYPE, decode), (0, _defineProperty2["default"])(_decoders, MIME_TYPE_SECOND, decode), _decoders),
      encoders: (_encoders = {}, (0, _defineProperty2["default"])(_encoders, MIME_TYPE, encode), (0, _defineProperty2["default"])(_encoders, MIME_TYPE_SECOND, encode), _encoders)
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS((exports2) => {
  "use strict";
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports2.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports2.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports2.setTyped = function(on) {
    if (on) {
      exports2.Buf8 = Uint8Array;
      exports2.Buf16 = Uint16Array;
      exports2.Buf32 = Int32Array;
      exports2.assign(exports2, fnTyped);
    } else {
      exports2.Buf8 = Array;
      exports2.Buf16 = Array;
      exports2.Buf32 = Array;
      exports2.assign(exports2, fnUntyped);
    }
  };
  exports2.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports2) => {
  "use strict";
  var utils = require_common();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  exports2._tr_init = _tr_init;
  exports2._tr_stored_block = _tr_stored_block;
  exports2._tr_flush_block = _tr_flush_block;
  exports2._tr_tally = _tr_tally;
  exports2._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports2, module2) => {
  "use strict";
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module2.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS((exports2, module2) => {
  "use strict";
  function makeTable() {
    var c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  module2.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports2) => {
  "use strict";
  var utils = require_common();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  exports2.deflateInit = deflateInit;
  exports2.deflateInit2 = deflateInit2;
  exports2.deflateReset = deflateReset;
  exports2.deflateResetKeep = deflateResetKeep;
  exports2.deflateSetHeader = deflateSetHeader;
  exports2.deflate = deflate;
  exports2.deflateEnd = deflateEnd;
  exports2.deflateSetDictionary = deflateSetDictionary;
  exports2.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports2) => {
  "use strict";
  var utils = require_common();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  exports2.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  exports2.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports2.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i = 0, len = buf.length; i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  exports2.buf2string = function(buf, max) {
    var i, out, c, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports2.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports2, module2) => {
  "use strict";
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module2.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports2) => {
  "use strict";
  var zlib_deflate = require_deflate();
  var utils = require_common();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports2.Deflate = Deflate;
  exports2.deflate = deflate;
  exports2.deflateRaw = deflateRaw;
  exports2.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports2, module2) => {
  "use strict";
  var BAD = 30;
  var TYPE = 12;
  module2.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_common();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports2) => {
  "use strict";
  var utils = require_common();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports2.inflateReset = inflateReset;
  exports2.inflateReset2 = inflateReset2;
  exports2.inflateResetKeep = inflateResetKeep;
  exports2.inflateInit = inflateInit;
  exports2.inflateInit2 = inflateInit2;
  exports2.inflate = inflate;
  exports2.inflateEnd = inflateEnd;
  exports2.inflateGetHeader = inflateGetHeader;
  exports2.inflateSetDictionary = inflateSetDictionary;
  exports2.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports2, module2) => {
  "use strict";
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module2.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports2) => {
  "use strict";
  var zlib_inflate = require_inflate();
  var utils = require_common();
  var strings = require_strings();
  var c = require_constants3();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }
  exports2.Inflate = Inflate;
  exports2.inflate = inflate;
  exports2.inflateRaw = inflateRaw;
  exports2.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports2, module2) => {
  "use strict";
  var assign = require_common().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants = require_constants3();
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module2.exports = pako;
});

// node_modules/utif/UTIF.js
var require_UTIF = __commonJS((exports2, module2) => {
  (function() {
    var UTIF = {};
    if (typeof module2 == "object") {
      module2.exports = UTIF;
    } else {
      self.UTIF = UTIF;
    }
    var pako;
    if (true) {
      pako = require_pako();
    } else {
      pako = self.pako;
    }
    function log() {
      if (typeof process == "undefined" || process.env.NODE_ENV == "development")
        console.log.apply(console, arguments);
    }
    (function(UTIF2, pako2) {
      (function() {
        var V = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(g) {
          return typeof g;
        } : function(g) {
          return g && typeof Symbol === "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
        }, D = function() {
          function g(g2) {
            this.message = "JPEG error: " + g2;
          }
          g.prototype = Error();
          g.prototype.name = "JpegError";
          return g.constructor = g;
        }(), P = function() {
          function g(g2, D2) {
            this.message = g2;
            this.g = D2;
          }
          g.prototype = Error();
          g.prototype.name = "DNLMarkerError";
          return g.constructor = g;
        }();
        (function() {
          function g() {
            this.M = null;
            this.B = -1;
          }
          function W(a, d) {
            for (var f = 0, e = [], b, B, k = 16; 0 < k && !a[k - 1]; )
              k--;
            e.push({children: [], index: 0});
            var l = e[0], r;
            for (b = 0; b < k; b++) {
              for (B = 0; B < a[b]; B++) {
                l = e.pop();
                for (l.children[l.index] = d[f]; 0 < l.index; )
                  l = e.pop();
                l.index++;
                for (e.push(l); e.length <= b; )
                  e.push(r = {children: [], index: 0}), l.children[l.index] = r.children, l = r;
                f++;
              }
              b + 1 < k && (e.push(r = {children: [], index: 0}), l.children[l.index] = r.children, l = r);
            }
            return e[0].children;
          }
          function X(a, d, f, e, b, B, k, l, r) {
            function n() {
              if (0 < x)
                return x--, z >> x & 1;
              z = a[d++];
              if (z === 255) {
                var c2 = a[d++];
                if (c2) {
                  if (c2 === 220 && g2) {
                    d += 2;
                    var b2 = a[d++] << 8 | a[d++];
                    if (0 < b2 && b2 !== f.g)
                      throw new P("Found DNL marker (0xFFDC) while parsing scan data", b2);
                  }
                  throw new D("unexpected marker " + (z << 8 | c2).toString(16));
                }
              }
              x = 7;
              return z >>> 7;
            }
            function q(a2) {
              for (; ; ) {
                a2 = a2[n()];
                if (typeof a2 === "number")
                  return a2;
                if ((typeof a2 === "undefined" ? "undefined" : V(a2)) !== "object")
                  throw new D("invalid huffman sequence");
              }
            }
            function h(a2) {
              for (var c2 = 0; 0 < a2; )
                c2 = c2 << 1 | n(), a2--;
              return c2;
            }
            function c(a2) {
              if (a2 === 1)
                return n() === 1 ? 1 : -1;
              var c2 = h(a2);
              return c2 >= 1 << a2 - 1 ? c2 : c2 + (-1 << a2) + 1;
            }
            function C(a2, b2) {
              var d2 = q(a2.D);
              d2 = d2 === 0 ? 0 : c(d2);
              a2.a[b2] = a2.m += d2;
              for (d2 = 1; 64 > d2; ) {
                var h2 = q(a2.o), k2 = h2 & 15;
                h2 >>= 4;
                if (k2 === 0) {
                  if (15 > h2)
                    break;
                  d2 += 16;
                } else
                  d2 += h2, a2.a[b2 + J[d2]] = c(k2), d2++;
              }
            }
            function w(a2, d2) {
              var b2 = q(a2.D);
              b2 = b2 === 0 ? 0 : c(b2) << r;
              a2.a[d2] = a2.m += b2;
            }
            function p(a2, c2) {
              a2.a[c2] |= n() << r;
            }
            function m(a2, b2) {
              if (0 < A)
                A--;
              else
                for (var d2 = B; d2 <= k; ) {
                  var e2 = q(a2.o), f2 = e2 & 15;
                  e2 >>= 4;
                  if (f2 === 0) {
                    if (15 > e2) {
                      A = h(e2) + (1 << e2) - 1;
                      break;
                    }
                    d2 += 16;
                  } else
                    d2 += e2, a2.a[b2 + J[d2]] = c(f2) * (1 << r), d2++;
                }
            }
            function t(a2, d2) {
              for (var b2 = B, e2 = 0, f2; b2 <= k; ) {
                f2 = d2 + J[b2];
                var l2 = 0 > a2.a[f2] ? -1 : 1;
                switch (E) {
                  case 0:
                    e2 = q(a2.o);
                    f2 = e2 & 15;
                    e2 >>= 4;
                    if (f2 === 0)
                      15 > e2 ? (A = h(e2) + (1 << e2), E = 4) : (e2 = 16, E = 1);
                    else {
                      if (f2 !== 1)
                        throw new D("invalid ACn encoding");
                      Q = c(f2);
                      E = e2 ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (e2--, e2 === 0 && (E = E === 2 ? 3 : 0));
                    break;
                  case 3:
                    a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (a2.a[f2] = Q << r, E = 0);
                    break;
                  case 4:
                    a2.a[f2] && (a2.a[f2] += l2 * (n() << r));
                }
                b2++;
              }
              E === 4 && (A--, A === 0 && (E = 0));
            }
            var g2 = 9 < arguments.length && arguments[9] !== void 0 ? arguments[9] : false, u = f.P, v = d, z = 0, x = 0, A = 0, E = 0, Q, K = e.length, F, L, M, I;
            var R = f.S ? B === 0 ? l === 0 ? w : p : l === 0 ? m : t : C;
            var G = 0;
            var O = K === 1 ? e[0].c * e[0].l : u * f.O;
            for (var S, T; G < O; ) {
              var U = b ? Math.min(O - G, b) : O;
              for (F = 0; F < K; F++)
                e[F].m = 0;
              A = 0;
              if (K === 1) {
                var y = e[0];
                for (I = 0; I < U; I++)
                  R(y, 64 * ((y.c + 1) * (G / y.c | 0) + G % y.c)), G++;
              } else
                for (I = 0; I < U; I++) {
                  for (F = 0; F < K; F++)
                    for (y = e[F], S = y.h, T = y.j, L = 0; L < T; L++)
                      for (M = 0; M < S; M++)
                        R(y, 64 * ((y.c + 1) * ((G / u | 0) * y.j + L) + (G % u * y.h + M)));
                  G++;
                }
              x = 0;
              (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + y.f), d = y.offset);
              y = y && y.F;
              if (!y || 65280 >= y)
                throw new D("marker was not found");
              if (65488 <= y && 65495 >= y)
                d += 2;
              else
                break;
            }
            (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + y.f), d = y.offset);
            return d - v;
          }
          function Y(a, d) {
            for (var f = d.c, e = d.l, b = new Int16Array(64), B = 0; B < e; B++)
              for (var k = 0; k < f; k++) {
                var l = 64 * ((d.c + 1) * B + k), r = b, n = d.G, q = d.a;
                if (!n)
                  throw new D("missing required Quantization Table.");
                for (var h = 0; 64 > h; h += 8) {
                  var c = q[l + h];
                  var C = q[l + h + 1];
                  var w = q[l + h + 2];
                  var p = q[l + h + 3];
                  var m = q[l + h + 4];
                  var t = q[l + h + 5];
                  var g2 = q[l + h + 6];
                  var u = q[l + h + 7];
                  c *= n[h];
                  if ((C | w | p | m | t | g2 | u) === 0)
                    c = 5793 * c + 512 >> 10, r[h] = c, r[h + 1] = c, r[h + 2] = c, r[h + 3] = c, r[h + 4] = c, r[h + 5] = c, r[h + 6] = c, r[h + 7] = c;
                  else {
                    C *= n[h + 1];
                    w *= n[h + 2];
                    p *= n[h + 3];
                    m *= n[h + 4];
                    t *= n[h + 5];
                    g2 *= n[h + 6];
                    u *= n[h + 7];
                    var v = 5793 * c + 128 >> 8;
                    var z = 5793 * m + 128 >> 8;
                    var x = w;
                    var A = g2;
                    m = 2896 * (C - u) + 128 >> 8;
                    u = 2896 * (C + u) + 128 >> 8;
                    p <<= 4;
                    t <<= 4;
                    v = v + z + 1 >> 1;
                    z = v - z;
                    c = 3784 * x + 1567 * A + 128 >> 8;
                    x = 1567 * x - 3784 * A + 128 >> 8;
                    A = c;
                    m = m + t + 1 >> 1;
                    t = m - t;
                    u = u + p + 1 >> 1;
                    p = u - p;
                    v = v + A + 1 >> 1;
                    A = v - A;
                    z = z + x + 1 >> 1;
                    x = z - x;
                    c = 2276 * m + 3406 * u + 2048 >> 12;
                    m = 3406 * m - 2276 * u + 2048 >> 12;
                    u = c;
                    c = 799 * p + 4017 * t + 2048 >> 12;
                    p = 4017 * p - 799 * t + 2048 >> 12;
                    t = c;
                    r[h] = v + u;
                    r[h + 7] = v - u;
                    r[h + 1] = z + t;
                    r[h + 6] = z - t;
                    r[h + 2] = x + p;
                    r[h + 5] = x - p;
                    r[h + 3] = A + m;
                    r[h + 4] = A - m;
                  }
                }
                for (n = 0; 8 > n; ++n)
                  c = r[n], C = r[n + 8], w = r[n + 16], p = r[n + 24], m = r[n + 32], t = r[n + 40], g2 = r[n + 48], u = r[n + 56], (C | w | p | m | t | g2 | u) === 0 ? (c = 5793 * c + 8192 >> 14, c = -2040 > c ? 0 : 2024 <= c ? 255 : c + 2056 >> 4, q[l + n] = c, q[l + n + 8] = c, q[l + n + 16] = c, q[l + n + 24] = c, q[l + n + 32] = c, q[l + n + 40] = c, q[l + n + 48] = c, q[l + n + 56] = c) : (v = 5793 * c + 2048 >> 12, z = 5793 * m + 2048 >> 12, x = w, A = g2, m = 2896 * (C - u) + 2048 >> 12, u = 2896 * (C + u) + 2048 >> 12, v = (v + z + 1 >> 1) + 4112, z = v - z, c = 3784 * x + 1567 * A + 2048 >> 12, x = 1567 * x - 3784 * A + 2048 >> 12, A = c, m = m + t + 1 >> 1, t = m - t, u = u + p + 1 >> 1, p = u - p, v = v + A + 1 >> 1, A = v - A, z = z + x + 1 >> 1, x = z - x, c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, u = c, c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, t = c, c = v + u, u = v - u, C = z + t, g2 = z - t, w = x + p, t = x - p, p = A + m, m = A - m, c = 16 > c ? 0 : 4080 <= c ? 255 : c >> 4, C = 16 > C ? 0 : 4080 <= C ? 255 : C >> 4, w = 16 > w ? 0 : 4080 <= w ? 255 : w >> 4, p = 16 > p ? 0 : 4080 <= p ? 255 : p >> 4, m = 16 > m ? 0 : 4080 <= m ? 255 : m >> 4, t = 16 > t ? 0 : 4080 <= t ? 255 : t >> 4, g2 = 16 > g2 ? 0 : 4080 <= g2 ? 255 : g2 >> 4, u = 16 > u ? 0 : 4080 <= u ? 255 : u >> 4, q[l + n] = c, q[l + n + 8] = C, q[l + n + 16] = w, q[l + n + 24] = p, q[l + n + 32] = m, q[l + n + 40] = t, q[l + n + 48] = g2, q[l + n + 56] = u);
              }
            return d.a;
          }
          function N(a, d) {
            var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : d, e = a.length - 1;
            f = f < d ? f : d;
            if (d >= e)
              return null;
            var b = a[d] << 8 | a[d + 1];
            if (65472 <= b && 65534 >= b)
              return {f: null, F: b, offset: d};
            for (var B = a[f] << 8 | a[f + 1]; !(65472 <= B && 65534 >= B); ) {
              if (++f >= e)
                return null;
              B = a[f] << 8 | a[f + 1];
            }
            return {f: b.toString(16), F: B, offset: f};
          }
          var J = new Uint8Array([
            0,
            1,
            8,
            16,
            9,
            2,
            3,
            10,
            17,
            24,
            32,
            25,
            18,
            11,
            4,
            5,
            12,
            19,
            26,
            33,
            40,
            48,
            41,
            34,
            27,
            20,
            13,
            6,
            7,
            14,
            21,
            28,
            35,
            42,
            49,
            56,
            57,
            50,
            43,
            36,
            29,
            22,
            15,
            23,
            30,
            37,
            44,
            51,
            58,
            59,
            52,
            45,
            38,
            31,
            39,
            46,
            53,
            60,
            61,
            54,
            47,
            55,
            62,
            63
          ]);
          g.prototype = {parse: function(a) {
            function d() {
              var d2 = a[k] << 8 | a[k + 1];
              k += 2;
              return d2;
            }
            function f() {
              var b2 = d();
              b2 = k + b2 - 2;
              var c2 = N(a, b2, k);
              c2 && c2.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + c2.f), b2 = c2.offset);
              b2 = a.subarray(k, b2);
              k += b2.length;
              return b2;
            }
            function e(a2) {
              for (var b2 = Math.ceil(a2.v / 8 / a2.s), c2 = Math.ceil(a2.g / 8 / a2.u), d2 = 0; d2 < a2.b.length; d2++) {
                v = a2.b[d2];
                var e2 = Math.ceil(Math.ceil(a2.v / 8) * v.h / a2.s), f2 = Math.ceil(Math.ceil(a2.g / 8) * v.j / a2.u);
                v.a = new Int16Array(64 * c2 * v.j * (b2 * v.h + 1));
                v.c = e2;
                v.l = f2;
              }
              a2.P = b2;
              a2.O = c2;
            }
            var b = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).N, B = b === void 0 ? null : b, k = 0, l = null, r = 0;
            b = [];
            var n = [], q = [], h = d();
            if (h !== 65496)
              throw new D("SOI not found");
            for (h = d(); h !== 65497; ) {
              switch (h) {
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  var c = f();
                  h === 65518 && c[0] === 65 && c[1] === 100 && c[2] === 111 && c[3] === 98 && c[4] === 101 && (l = {version: c[5] << 8 | c[6], Y: c[7] << 8 | c[8], Z: c[9] << 8 | c[10], W: c[11]});
                  break;
                case 65499:
                  h = d() + k - 2;
                  for (var g2; k < h; ) {
                    var w = a[k++], p = new Uint16Array(64);
                    if (w >> 4 === 0)
                      for (c = 0; 64 > c; c++)
                        g2 = J[c], p[g2] = a[k++];
                    else if (w >> 4 === 1)
                      for (c = 0; 64 > c; c++)
                        g2 = J[c], p[g2] = d();
                    else
                      throw new D("DQT - invalid table spec");
                    b[w & 15] = p;
                  }
                  break;
                case 65472:
                case 65473:
                case 65474:
                  if (m)
                    throw new D("Only single frame JPEGs supported");
                  d();
                  var m = {};
                  m.X = h === 65473;
                  m.S = h === 65474;
                  m.precision = a[k++];
                  h = d();
                  m.g = B || h;
                  m.v = d();
                  m.b = [];
                  m.C = {};
                  c = a[k++];
                  for (h = p = w = 0; h < c; h++) {
                    g2 = a[k];
                    var t = a[k + 1] >> 4;
                    var H = a[k + 1] & 15;
                    w < t && (w = t);
                    p < H && (p = H);
                    t = m.b.push({h: t, j: H, T: a[k + 2], G: null});
                    m.C[g2] = t - 1;
                    k += 3;
                  }
                  m.s = w;
                  m.u = p;
                  e(m);
                  break;
                case 65476:
                  g2 = d();
                  for (h = 2; h < g2; ) {
                    w = a[k++];
                    p = new Uint8Array(16);
                    for (c = t = 0; 16 > c; c++, k++)
                      t += p[c] = a[k];
                    H = new Uint8Array(t);
                    for (c = 0; c < t; c++, k++)
                      H[c] = a[k];
                    h += 17 + t;
                    (w >> 4 === 0 ? q : n)[w & 15] = W(p, H);
                  }
                  break;
                case 65501:
                  d();
                  var u = d();
                  break;
                case 65498:
                  c = ++r === 1 && !B;
                  d();
                  w = a[k++];
                  g2 = [];
                  for (h = 0; h < w; h++) {
                    p = m.C[a[k++]];
                    var v = m.b[p];
                    p = a[k++];
                    v.D = q[p >> 4];
                    v.o = n[p & 15];
                    g2.push(v);
                  }
                  h = a[k++];
                  w = a[k++];
                  p = a[k++];
                  try {
                    var z = X(a, k, m, g2, u, h, w, p >> 4, p & 15, c);
                    k += z;
                  } catch (x) {
                    if (x instanceof P)
                      return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(a, {N: x.g});
                    throw x;
                  }
                  break;
                case 65500:
                  k += 4;
                  break;
                case 65535:
                  a[k] !== 255 && k--;
                  break;
                default:
                  if (a[k - 3] === 255 && 192 <= a[k - 2] && 254 >= a[k - 2])
                    k -= 3;
                  else if ((c = N(a, k - 2)) && c.f)
                    (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + c.f), k = c.offset;
                  else
                    throw new D("unknown marker " + h.toString(16));
              }
              h = d();
            }
            this.width = m.v;
            this.height = m.g;
            this.A = l;
            this.b = [];
            for (h = 0; h < m.b.length; h++) {
              v = m.b[h];
              if (u = b[v.T])
                v.G = u;
              this.b.push({R: Y(m, v), U: v.h / m.s, V: v.j / m.u, c: v.c, l: v.l});
            }
            this.i = this.b.length;
          }, L: function(a, d) {
            var f = this.width / a, e = this.height / d, b, g2, k = this.b.length, l = a * d * k, r = new Uint8ClampedArray(l), n = new Uint32Array(a);
            for (g2 = 0; g2 < k; g2++) {
              var q = this.b[g2];
              var h = q.U * f;
              var c = q.V * e;
              var C = g2;
              var w = q.R;
              var p = q.c + 1 << 3;
              for (b = 0; b < a; b++)
                q = 0 | b * h, n[b] = (q & 4294967288) << 3 | q & 7;
              for (h = 0; h < d; h++)
                for (q = 0 | h * c, q = p * (q & 4294967288) | (q & 7) << 3, b = 0; b < a; b++)
                  r[C] = w[q + n[b]], C += k;
            }
            if (e = this.M)
              for (g2 = 0; g2 < l; )
                for (f = q = 0; q < k; q++, g2++, f += 2)
                  r[g2] = (r[g2] * e[f] >> 8) + e[f + 1];
            return r;
          }, w: function() {
            return this.A ? !!this.A.W : this.i === 3 ? this.B === 0 ? false : true : this.B === 1 ? true : false;
          }, I: function(a) {
            for (var d, f, e, b = 0, g2 = a.length; b < g2; b += 3)
              d = a[b], f = a[b + 1], e = a[b + 2], a[b] = d - 179.456 + 1.402 * e, a[b + 1] = d + 135.459 - 0.344 * f - 0.714 * e, a[b + 2] = d - 226.816 + 1.772 * f;
            return a;
          }, K: function(a) {
            for (var d, f, e, b, g2 = 0, k = 0, l = a.length; k < l; k += 4)
              d = a[k], f = a[k + 1], e = a[k + 2], b = a[k + 3], a[g2++] = -122.67195406894 + f * (-660635669420364e-19 * f + 437130475926232e-18 * e - 54080610064599e-18 * d + 48449797120281e-17 * b - 0.154362151871126) + e * (-957964378445773e-18 * e + 817076911346625e-18 * d - 0.00477271405408747 * b + 1.53380253221734) + d * (961250184130688e-18 * d - 0.00266257332283933 * b + 0.48357088451265) + b * (-336197177618394e-18 * b + 0.484791561490776), a[g2++] = 107.268039397724 + f * (219927104525741e-19 * f - 640992018297945e-18 * e + 659397001245577e-18 * d + 426105652938837e-18 * b - 0.176491792462875) + e * (-778269941513683e-18 * e + 0.00130872261408275 * d + 770482631801132e-18 * b - 0.151051492775562) + d * (0.00126935368114843 * d - 0.00265090189010898 * b + 0.25802910206845) + b * (-318913117588328e-18 * b - 0.213742400323665), a[g2++] = -20.810012546947 + f * (-570115196973677e-18 * f - 263409051004589e-19 * e + 0.0020741088115012 * d - 0.00288260236853442 * b + 0.814272968359295) + e * (-153496057440975e-19 * e - 132689043961446e-18 * d + 560833691242812e-18 * b - 0.195152027534049) + d * (0.00174418132927582 * d - 0.00255243321439347 * b + 0.116935020465145) + b * (-343531996510555e-18 * b + 0.24165260232407);
            return a.subarray(0, g2);
          }, J: function(a) {
            for (var d, f, e, b = 0, g2 = a.length; b < g2; b += 4)
              d = a[b], f = a[b + 1], e = a[b + 2], a[b] = 434.456 - d - 1.402 * e, a[b + 1] = 119.541 - d + 0.344 * f + 0.714 * e, a[b + 2] = 481.816 - d - 1.772 * f;
            return a;
          }, H: function(a) {
            for (var d, f, e, b, g2 = 0, k = 1 / 255, l = 0, r = a.length; l < r; l += 4)
              d = a[l] * k, f = a[l + 1] * k, e = a[l + 2] * k, b = a[l + 3] * k, a[g2++] = 255 + d * (-4.387332384609988 * d + 54.48615194189176 * f + 18.82290502165302 * e + 212.25662451639585 * b - 285.2331026137004) + f * (1.7149763477362134 * f - 5.6096736904047315 * e - 17.873870861415444 * b - 5.497006427196366) + e * (-2.5217340131683033 * e - 21.248923337353073 * b + 17.5119270841813) - b * (21.86122147463605 * b + 189.48180835922747), a[g2++] = 255 + d * (8.841041422036149 * d + 60.118027045597366 * f + 6.871425592049007 * e + 31.159100130055922 * b - 79.2970844816548) + f * (-15.310361306967817 * f + 17.575251261109482 * e + 131.35250912493976 * b - 190.9453302588951) + e * (4.444339102852739 * e + 9.8632861493405 * b - 24.86741582555878) - b * (20.737325471181034 * b + 187.80453709719578), a[g2++] = 255 + d * (0.8842522430003296 * d + 8.078677503112928 * f + 30.89978309703729 * e - 0.23883238689178934 * b - 14.183576799673286) + f * (10.49593273432072 * f + 63.02378494754052 * e + 50.606957656360734 * b - 112.23884253719248) + e * (0.03296041114873217 * e + 115.60384449646641 * b - 193.58209356861505) - b * (22.33816807309886 * b + 180.12613974708367);
            return a.subarray(0, g2);
          }, getData: function(a, d, f) {
            if (4 < this.i)
              throw new D("Unsupported color mode");
            a = this.L(a, d);
            if (this.i === 1 && f) {
              f = a.length;
              d = new Uint8ClampedArray(3 * f);
              for (var e = 0, b = 0; b < f; b++) {
                var g2 = a[b];
                d[e++] = g2;
                d[e++] = g2;
                d[e++] = g2;
              }
              return d;
            }
            if (this.i === 3 && this.w())
              return this.I(a);
            if (this.i === 4) {
              if (this.w())
                return f ? this.K(a) : this.J(a);
              if (f)
                return this.H(a);
            }
            return a;
          }};
          UTIF2.JpegDecoder = g;
        })();
      })();
      UTIF2.encodeImage = function(rgba, w, h, metadata) {
        var idf = {
          t256: [w],
          t257: [h],
          t258: [8, 8, 8, 8],
          t259: [1],
          t262: [2],
          t273: [1e3],
          t277: [4],
          t278: [h],
          t279: [w * h * 4],
          t282: [1],
          t283: [1],
          t284: [1],
          t286: [0],
          t287: [0],
          t296: [1],
          t305: ["Photopea (UTIF.js)"],
          t338: [1]
        };
        if (metadata)
          for (var i in metadata)
            idf[i] = metadata[i];
        var prfx = new Uint8Array(UTIF2.encode([idf]));
        var img = new Uint8Array(rgba);
        var data = new Uint8Array(1e3 + w * h * 4);
        for (var i = 0; i < prfx.length; i++)
          data[i] = prfx[i];
        for (var i = 0; i < img.length; i++)
          data[1e3 + i] = img[i];
        return data.buffer;
      };
      UTIF2.encode = function(ifds) {
        var data = new Uint8Array(2e4), offset = 4, bin = UTIF2._binBE;
        data[0] = 77;
        data[1] = 77;
        data[3] = 42;
        var ifdo = 8;
        bin.writeUint(data, offset, ifdo);
        offset += 4;
        for (var i = 0; i < ifds.length; i++) {
          var noffs = UTIF2._writeIFD(bin, data, ifdo, ifds[i]);
          ifdo = noffs[1];
          if (i < ifds.length - 1)
            bin.writeUint(data, noffs[0], ifdo);
        }
        return data.slice(0, ifdo).buffer;
      };
      UTIF2.decode = function(buff) {
        UTIF2.decode._decodeG3.allow2D = null;
        var data = new Uint8Array(buff), offset = 0;
        var id = UTIF2._binBE.readASCII(data, offset, 2);
        offset += 2;
        var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
        var num = bin.readUshort(data, offset);
        offset += 2;
        var ifdo = bin.readUint(data, offset);
        offset += 4;
        var ifds = [];
        while (true) {
          var noff = UTIF2._readIFD(bin, data, ifdo, ifds);
          ifdo = bin.readUint(data, noff);
          if (ifdo == 0)
            break;
        }
        return ifds;
      };
      UTIF2.decodeImages = function(buff, ifds) {
        var data = new Uint8Array(buff);
        var id = UTIF2._binBE.readASCII(data, 0, 2);
        for (var ii = 0; ii < ifds.length; ii++) {
          var img = ifds[ii];
          if (img["t256"] == null)
            continue;
          img.isLE = id == "II";
          img.width = img["t256"][0];
          img.height = img["t257"][0];
          var cmpr = img["t259"] ? img["t259"][0] : 1;
          var fo = img["t266"] ? img["t266"][0] : 1;
          if (img["t284"] && img["t284"][0] == 2)
            log("PlanarConfiguration 2 should not be used!");
          var bipp = (img["t258"] ? Math.min(32, img["t258"][0]) : 1) * (img["t277"] ? img["t277"][0] : 1);
          var bipl = Math.ceil(img.width * bipp / 8) * 8;
          var soff = img["t273"];
          if (soff == null)
            soff = img["t324"];
          var bcnt = img["t279"];
          if (cmpr == 1 && soff.length == 1)
            bcnt = [img.height * (bipl >>> 3)];
          if (bcnt == null)
            bcnt = img["t325"];
          var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
          if (img["t322"] != null) {
            var tw = img["t322"][0], th = img["t323"][0];
            var tx = Math.floor((img.width + tw - 1) / tw);
            var ty = Math.floor((img.height + th - 1) / th);
            var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
            for (var y = 0; y < ty; y++)
              for (var x = 0; x < tx; x++) {
                var i = y * tx + x;
                for (var j = 0; j < tbuff.length; j++)
                  tbuff[j] = 0;
                UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo);
                if (cmpr == 6)
                  bytes = tbuff;
                else
                  UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
              }
            bilen = bytes.length * 8;
          } else {
            var rps = img["t278"] ? img["t278"][0] : img.height;
            rps = Math.min(rps, img.height);
            for (var i = 0; i < soff.length; i++) {
              UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo);
              bilen += bipl * rps;
            }
            bilen = Math.min(bilen, bytes.length * 8);
          }
          img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
        }
      };
      UTIF2.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo) {
        if (false) {
        } else if (cmpr == 1)
          for (var j = 0; j < len; j++)
            tgt[toff + j] = data[off + j];
        else if (cmpr == 3)
          UTIF2.decode._decodeG3(data, off, len, tgt, toff, img.width, fo);
        else if (cmpr == 4)
          UTIF2.decode._decodeG4(data, off, len, tgt, toff, img.width, fo);
        else if (cmpr == 5)
          UTIF2.decode._decodeLZW(data, off, tgt, toff);
        else if (cmpr == 6)
          UTIF2.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 7)
          UTIF2.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 8) {
          var src = new Uint8Array(data.buffer, off, len);
          var bin = pako2["inflate"](src);
          for (var i = 0; i < bin.length; i++)
            tgt[toff + i] = bin[i];
        } else if (cmpr == 32773)
          UTIF2.decode._decodePackBits(data, off, len, tgt, toff);
        else if (cmpr == 32809)
          UTIF2.decode._decodeThunder(data, off, len, tgt, toff);
        else
          log("Unknown compression", cmpr);
        if (img["t317"] && img["t317"][0] == 2) {
          var noc = img["t277"] ? img["t277"][0] : 1, h = img["t278"] ? img["t278"][0] : img.height, bpr = img.width * noc;
          for (var y = 0; y < h; y++) {
            var ntoff = toff + y * bpr;
            if (noc == 3)
              for (var j = 3; j < bpr; j += 3) {
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
              }
            else
              for (var j = noc; j < bpr; j++)
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - noc] & 255;
          }
        }
      };
      UTIF2.decode._decodeNikon = function(data, off, len, tgt, toff) {
        var nikon_tree = [
          [
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            3,
            6,
            2,
            7,
            1,
            0,
            8,
            9,
            11,
            10,
            12
          ],
          [
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            57,
            90,
            56,
            39,
            22,
            5,
            4,
            3,
            2,
            1,
            0,
            11,
            12,
            12
          ],
          [
            0,
            1,
            4,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            6,
            3,
            7,
            2,
            8,
            1,
            9,
            0,
            10,
            11,
            12
          ],
          [
            0,
            1,
            4,
            3,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            6,
            4,
            7,
            8,
            3,
            9,
            2,
            1,
            0,
            10,
            11,
            12,
            13,
            14
          ],
          [
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            8,
            92,
            75,
            58,
            41,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            0,
            13,
            14
          ],
          [
            0,
            1,
            4,
            2,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            7,
            6,
            8,
            5,
            9,
            4,
            10,
            3,
            11,
            12,
            2,
            0,
            1,
            13,
            14
          ]
        ];
        var ver0, ver1, vpred, hpred, csize;
        var i, min, max, step = 0, huff = 0, split = 0, row, col, len, shl, diff;
        log(data.slice(off, off + 100));
        ver0 = data[off];
        off++;
        ver1 = data[off];
        off++;
        log(ver0.toString(16), ver1.toString(16), len);
      };
      UTIF2.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
        var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
        if (tables) {
          var SOI = 216, EOI2 = 217, boff = 0;
          for (var i = 0; i < tlen - 1; i++) {
            if (tables[i] == 255 && tables[i + 1] == EOI2)
              break;
            buff[boff++] = tables[i];
          }
          var byte1 = data[off], byte2 = data[off + 1];
          if (byte1 != 255 || byte2 != SOI) {
            buff[boff++] = byte1;
            buff[boff++] = byte2;
          }
          for (var i = 2; i < len; i++)
            buff[boff++] = data[off + i];
        } else
          for (var i = 0; i < len; i++)
            buff[i] = data[off + i];
        if (img["t262"] == 32803) {
          var bps = img["t258"][0], dcdr = new LosslessJpegDecoder();
          var out = dcdr.decode(buff), olen = out.length;
          if (false) {
          } else if (bps == 16)
            for (var i = 0; i < olen; i++) {
              tgt[toff++] = out[i] & 255;
              tgt[toff++] = out[i] >>> 8;
            }
          else if (bps == 12)
            for (var i = 0; i < olen; i += 2) {
              tgt[toff++] = out[i] >>> 4;
              tgt[toff++] = (out[i] << 4 | out[i + 1] >>> 8) & 255;
              tgt[toff++] = out[i + 1] & 255;
            }
          else
            throw new Error("unsupported bit depth " + bps);
        } else {
          var parser = new UTIF2.JpegDecoder();
          parser.parse(buff);
          var decoded = parser.getData(parser.width, parser.height);
          for (var i = 0; i < decoded.length; i++)
            tgt[toff + i] = decoded[i];
        }
        if (img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodeOldJPEGInit = function(img, data, off, len) {
        var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
        var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i, j, k;
        var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
        var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
        var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
        var ycbcrss = img["t530"], ssx = 0, ssy = 0;
        var spp = img["t277"] ? img["t277"][0] : 1;
        var jpgresint = img["t515"];
        if (soffTag) {
          soff = soffTag[0];
          isTiled = soffTag.length > 1;
        }
        if (!isTiled) {
          if (data[off] == 255 && data[off + 1] == SOI)
            return {jpegOffset: off};
          if (jpgIchgFmt != null) {
            if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI)
              joff = off + jifoff;
            else
              log("JPEGInterchangeFormat does not point to SOI");
            if (jpgIchgFmtLen == null)
              log("JPEGInterchangeFormatLength field is missing");
            else if (jifoff >= soff || jifoff + jiflen <= soff)
              log("JPEGInterchangeFormatLength field value is invalid");
            if (joff != null)
              return {jpegOffset: joff};
          }
        }
        if (ycbcrss != null) {
          ssx = ycbcrss[0];
          ssy = ycbcrss[1];
        }
        if (jpgIchgFmt != null) {
          if (jpgIchgFmtLen != null)
            if (jiflen >= 2 && jifoff + jiflen <= soff) {
              if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI)
                tables = new Uint8Array(jiflen - 2);
              else
                tables = new Uint8Array(jiflen);
              for (i = 0; i < tables.length; i++)
                tables[i] = data[off + jifoff + i];
              log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else
              log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        }
        if (tables == null) {
          var ooff = 0, out = [];
          out[ooff++] = 255;
          out[ooff++] = SOI;
          var qtables = img["t519"];
          if (qtables == null)
            throw new Error("JPEGQTables tag is missing");
          for (i = 0; i < qtables.length; i++) {
            out[ooff++] = 255;
            out[ooff++] = DQT;
            out[ooff++] = 0;
            out[ooff++] = 67;
            out[ooff++] = i;
            for (j = 0; j < 64; j++)
              out[ooff++] = data[off + qtables[i] + j];
          }
          for (k = 0; k < 2; k++) {
            var htables = img[k == 0 ? "t520" : "t521"];
            if (htables == null)
              throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (i = 0; i < htables.length; i++) {
              out[ooff++] = 255;
              out[ooff++] = DHT;
              var nc = 19;
              for (j = 0; j < 16; j++)
                nc += data[off + htables[i] + j];
              out[ooff++] = nc >>> 8;
              out[ooff++] = nc & 255;
              out[ooff++] = i | k << 4;
              for (j = 0; j < 16; j++)
                out[ooff++] = data[off + htables[i] + j];
              for (j = 0; j < nc; j++)
                out[ooff++] = data[off + htables[i] + 16 + j];
            }
          }
          out[ooff++] = 255;
          out[ooff++] = SOF0;
          out[ooff++] = 0;
          out[ooff++] = 8 + 3 * spp;
          out[ooff++] = 8;
          out[ooff++] = img.height >>> 8 & 255;
          out[ooff++] = img.height & 255;
          out[ooff++] = img.width >>> 8 & 255;
          out[ooff++] = img.width & 255;
          out[ooff++] = spp;
          if (spp == 1) {
            out[ooff++] = 1;
            out[ooff++] = 17;
            out[ooff++] = 0;
          } else
            for (i = 0; i < 3; i++) {
              out[ooff++] = i + 1;
              out[ooff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              out[ooff++] = i;
            }
          if (jpgresint != null && jpgresint[0] != 0) {
            out[ooff++] = 255;
            out[ooff++] = DRI;
            out[ooff++] = 0;
            out[ooff++] = 4;
            out[ooff++] = jpgresint[0] >>> 8 & 255;
            out[ooff++] = jpgresint[0] & 255;
          }
          tables = new Uint8Array(out);
        }
        var sofpos = -1;
        i = 0;
        while (i < tables.length - 1) {
          if (tables[i] == 255 && tables[i + 1] == SOF0) {
            sofpos = i;
            break;
          }
          i++;
        }
        if (sofpos == -1) {
          var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
          tmptab.set(tables);
          var tmpoff = tables.length;
          sofpos = tables.length;
          tables = tmptab;
          tables[tmpoff++] = 255;
          tables[tmpoff++] = SOF0;
          tables[tmpoff++] = 0;
          tables[tmpoff++] = 8 + 3 * spp;
          tables[tmpoff++] = 8;
          tables[tmpoff++] = img.height >>> 8 & 255;
          tables[tmpoff++] = img.height & 255;
          tables[tmpoff++] = img.width >>> 8 & 255;
          tables[tmpoff++] = img.width & 255;
          tables[tmpoff++] = spp;
          if (spp == 1) {
            tables[tmpoff++] = 1;
            tables[tmpoff++] = 17;
            tables[tmpoff++] = 0;
          } else
            for (i = 0; i < 3; i++) {
              tables[tmpoff++] = i + 1;
              tables[tmpoff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              tables[tmpoff++] = i;
            }
        }
        if (data[soff] == 255 && data[soff + 1] == SOS2) {
          var soslen = data[soff + 2] << 8 | data[soff + 3];
          sosMarker2 = new Uint8Array(soslen + 2);
          sosMarker2[0] = data[soff];
          sosMarker2[1] = data[soff + 1];
          sosMarker2[2] = data[soff + 2];
          sosMarker2[3] = data[soff + 3];
          for (i = 0; i < soslen - 2; i++)
            sosMarker2[i + 4] = data[soff + i + 4];
        } else {
          sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
          var sosoff = 0;
          sosMarker2[sosoff++] = 255;
          sosMarker2[sosoff++] = SOS2;
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 6 + 2 * spp;
          sosMarker2[sosoff++] = spp;
          if (spp == 1) {
            sosMarker2[sosoff++] = 1;
            sosMarker2[sosoff++] = 0;
          } else
            for (i = 0; i < 3; i++) {
              sosMarker2[sosoff++] = i + 1;
              sosMarker2[sosoff++] = i << 4 | i;
            }
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 63;
          sosMarker2[sosoff++] = 0;
        }
        return {jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos};
      };
      UTIF2.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
        var i, dlen, tlen, buff, buffoff;
        var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data, off, len);
        if (jpegData.jpegOffset != null) {
          dlen = off + len - jpegData.jpegOffset;
          buff = new Uint8Array(dlen);
          for (i = 0; i < dlen; i++)
            buff[i] = data[jpegData.jpegOffset + i];
        } else {
          tlen = jpegData.tables.length;
          buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
          buff.set(jpegData.tables);
          buffoff = tlen;
          buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
          buff[jpegData.sofPosition + 6] = img.height & 255;
          buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
          buff[jpegData.sofPosition + 8] = img.width & 255;
          if (data[off] != 255 || data[off + 1] != SOS) {
            buff.set(jpegData.sosMarker, bufoff);
            bufoff += sosMarker.length;
          }
          for (i = 0; i < len; i++)
            buff[bufoff++] = data[off + i];
          buff[bufoff++] = 255;
          buff[bufoff++] = EOI;
        }
        var parser = new UTIF2.JpegDecoder();
        parser.parse(buff);
        var decoded = parser.getData(parser.width, parser.height);
        for (var i = 0; i < decoded.length; i++)
          tgt[toff + i] = decoded[i];
        if (img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodePackBits = function(data, off, len, tgt, toff) {
        var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
        while (off < lim) {
          var n = sa[off];
          off++;
          if (n >= 0 && n < 128)
            for (var i = 0; i < n + 1; i++) {
              ta[toff] = sa[off];
              toff++;
              off++;
            }
          if (n >= -127 && n < 0) {
            for (var i = 0; i < -n + 1; i++) {
              ta[toff] = sa[off];
              toff++;
            }
            off++;
          }
        }
      };
      UTIF2.decode._decodeThunder = function(data, off, len, tgt, toff) {
        var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
        var lim = off + len, qoff = toff * 2, px = 0;
        while (off < lim) {
          var b = data[off], msk = b >>> 6, n = b & 63;
          off++;
          if (msk == 3) {
            px = n & 15;
            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
            qoff++;
          }
          if (msk == 0)
            for (var i = 0; i < n; i++) {
              tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
              qoff++;
            }
          if (msk == 2)
            for (var i = 0; i < 2; i++) {
              var d = n >>> 3 * (1 - i) & 7;
              if (d != 4) {
                px += d3[d];
                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
          if (msk == 1)
            for (var i = 0; i < 3; i++) {
              var d = n >>> 2 * (2 - i) & 3;
              if (d != 2) {
                px += d2[d];
                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
        }
      };
      UTIF2.decode._dmap = {"1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3};
      UTIF2.decode._lens = function() {
        var addKeys = function(lens, arr, i0, inc) {
          for (var i = 0; i < arr.length; i++)
            lens[arr[i]] = i0 + i * inc;
        };
        var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
        var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
        var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
        var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
        var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        termW = termW.split(",");
        termB = termB.split(",");
        makeW = makeW.split(",");
        makeB = makeB.split(",");
        makeA = makeA.split(",");
        var lensW = {}, lensB = {};
        addKeys(lensW, termW, 0, 1);
        addKeys(lensW, makeW, 64, 64);
        addKeys(lensW, makeA, 1792, 64);
        addKeys(lensB, termB, 0, 1);
        addKeys(lensB, makeB, 64, 64);
        addKeys(lensB, makeA, 1792, 64);
        return [lensW, lensB];
      }();
      UTIF2.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i = 0; i < w; i++)
          pline.push(0);
        pline = U._makeDiff(pline);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = 0, mode = "", toRead = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (mode == "H") {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                a0 += len;
                clr = 1 - clr;
                len = 0;
                toRead--;
                if (toRead == 0)
                  mode = "";
              }
            }
          } else {
            if (wrd == "0001") {
              wrd = "";
              U._addNtimes(line, b2 - a0, clr);
              a0 = b2;
            }
            if (wrd == "001") {
              wrd = "";
              mode = "H";
              toRead = 2;
            }
            if (U._dmap[wrd] != null) {
              a1 = b1 + U._dmap[wrd];
              U._addNtimes(line, a1 - a0, clr);
              a0 = a1;
              wrd = "";
              clr = 1 - clr;
            }
          }
          if (line.length == w && mode == "") {
            U._writeBits(line, tgt, toff * 8 + y * bipl);
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
      };
      UTIF2.decode._findDiff = function(line, x, clr) {
        for (var i = 0; i < line.length; i += 2)
          if (line[i] >= x && line[i + 1] == clr)
            return line[i];
      };
      UTIF2.decode._makeDiff = function(line) {
        var out = [];
        if (line[0] == 1)
          out.push(0, 1);
        for (var i = 1; i < line.length; i++)
          if (line[i - 1] != line[i])
            out.push(i, line[i]);
        out.push(line.length, 0, line.length, 1);
        return out;
      };
      UTIF2.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i = 0; i < w; i++)
          line.push(0);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = -1, mode = "", toRead = 0, is1D = false;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (is1D) {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                clr = 1 - clr;
                len = 0;
              }
            }
          } else {
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0)
                    mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
          }
          if (wrd.endsWith("000000000001")) {
            if (y >= 0)
              U._writeBits(line, tgt, toff * 8 + y * bipl);
            if (fo == 1)
              is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
            if (fo == 2)
              is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
            boff++;
            if (U._decodeG3.allow2D == null)
              U._decodeG3.allow2D = is1D;
            if (!U._decodeG3.allow2D) {
              is1D = true;
              boff--;
            }
            wrd = "";
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
        if (line.length == w)
          U._writeBits(line, tgt, toff * 8 + y * bipl);
      };
      UTIF2.decode._addNtimes = function(arr, n, val) {
        for (var i = 0; i < n; i++)
          arr.push(val);
      };
      UTIF2.decode._writeBits = function(bits, tgt, boff) {
        for (var i = 0; i < bits.length; i++)
          tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
      };
      UTIF2.decode._decodeLZW = function(data, off, tgt, toff) {
        if (UTIF2.decode._lzwTab == null) {
          var tb = new Uint32Array(65535), tn = new Uint16Array(65535), chr = new Uint8Array(2e6);
          for (var i = 0; i < 256; i++) {
            chr[i << 2] = i;
            tb[i] = i << 2;
            tn[i] = 1;
          }
          UTIF2.decode._lzwTab = [tb, tn, chr];
        }
        var copy = UTIF2.decode._copyData;
        var tab = UTIF2.decode._lzwTab[0], tln = UTIF2.decode._lzwTab[1], chr = UTIF2.decode._lzwTab[2], totl = 258, chrl = 258 << 2;
        var bits = 9, boff = off << 3;
        var ClearCode = 256, EoiCode = 257;
        var v = 0, Code = 0, OldCode = 0;
        while (true) {
          v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
          Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
          boff += bits;
          if (Code == EoiCode)
            break;
          if (Code == ClearCode) {
            bits = 9;
            totl = 258;
            chrl = 258 << 2;
            v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
            Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
            boff += bits;
            if (Code == EoiCode)
              break;
            tgt[toff] = Code;
            toff++;
          } else if (Code < totl) {
            var cd = tab[Code], cl = tln[Code];
            copy(chr, cd, tgt, toff, cl);
            toff += cl;
            if (OldCode >= totl) {
              tab[totl] = chrl;
              chr[tab[totl]] = cd[0];
              tln[totl] = 1;
              chrl = chrl + 1 + 3 & ~3;
              totl++;
            } else {
              tab[totl] = chrl;
              var nit = tab[OldCode], nil = tln[OldCode];
              copy(chr, nit, chr, chrl, nil);
              chr[chrl + nil] = chr[cd];
              nil++;
              tln[totl] = nil;
              totl++;
              chrl = chrl + nil + 3 & ~3;
            }
            if (totl + 1 == 1 << bits)
              bits++;
          } else {
            if (OldCode >= totl) {
              tab[totl] = chrl;
              tln[totl] = 0;
              totl++;
            } else {
              tab[totl] = chrl;
              var nit = tab[OldCode], nil = tln[OldCode];
              copy(chr, nit, chr, chrl, nil);
              chr[chrl + nil] = chr[chrl];
              nil++;
              tln[totl] = nil;
              totl++;
              copy(chr, chrl, tgt, toff, nil);
              toff += nil;
              chrl = chrl + nil + 3 & ~3;
            }
            if (totl + 1 == 1 << bits)
              bits++;
          }
          OldCode = Code;
        }
      };
      UTIF2.decode._copyData = function(s, so, t, to, l) {
        for (var i = 0; i < l; i += 4) {
          t[to + i] = s[so + i];
          t[to + i + 1] = s[so + i + 1];
          t[to + i + 2] = s[so + i + 2];
          t[to + i + 3] = s[so + i + 3];
        }
      };
      UTIF2.tags = {
        254: "NewSubfileType",
        255: "SubfileType",
        256: "ImageWidth",
        257: "ImageLength",
        258: "BitsPerSample",
        259: "Compression",
        262: "PhotometricInterpretation",
        266: "FillOrder",
        269: "DocumentName",
        270: "ImageDescription",
        271: "Make",
        272: "Model",
        273: "StripOffset",
        274: "Orientation",
        277: "SamplesPerPixel",
        278: "RowsPerStrip",
        279: "StripByteCounts",
        280: "MinSampleValue",
        281: "MaxSampleValue",
        282: "XResolution",
        283: "YResolution",
        284: "PlanarConfiguration",
        285: "PageName",
        286: "XPosition",
        287: "YPosition",
        292: "T4Options",
        296: "ResolutionUnit",
        297: "PageNumber",
        305: "Software",
        306: "DateTime",
        315: "Artist",
        316: "HostComputer",
        317: "Predictor",
        318: "WhitePoint",
        319: "PrimaryChromaticities",
        320: "ColorMap",
        321: "HalftoneHints",
        322: "TileWidth",
        323: "TileLength",
        324: "TileOffset",
        325: "TileByteCounts",
        330: "SubIFDs",
        336: "DotRange",
        338: "ExtraSample",
        339: "SampleFormat",
        347: "JPEGTables",
        512: "JPEGProc",
        513: "JPEGInterchangeFormat",
        514: "JPEGInterchangeFormatLength",
        519: "JPEGQTables",
        520: "JPEGDCTables",
        521: "JPEGACTables",
        529: "YCbCrCoefficients",
        530: "YCbCrSubSampling",
        531: "YCbCrPositioning",
        532: "ReferenceBlackWhite",
        700: "XMP",
        33421: "CFARepeatPatternDim",
        33422: "CFAPattern",
        33432: "Copyright",
        33434: "ExposureTime",
        33437: "FNumber",
        33723: "IPTC/NAA",
        34377: "Photoshop",
        34665: "ExifIFD",
        34675: "ICC Profile",
        34850: "ExposureProgram",
        34853: "GPSInfo",
        34855: "ISOSpeedRatings",
        34858: "TimeZoneOffset",
        34859: "SelfTimeMode",
        36867: "DateTimeOriginal",
        36868: "DateTimeDigitized",
        37377: "ShutterSpeedValue",
        37378: "ApertureValue",
        37380: "ExposureBiasValue",
        37383: "MeteringMode",
        37385: "Flash",
        37386: "FocalLength",
        37390: "FocalPlaneXResolution",
        37391: "FocalPlaneYResolution",
        37392: "FocalPlaneResolutionUnit",
        37393: "ImageNumber",
        37398: "TIFF/EPStandardID",
        37399: "SensingMethod",
        37500: "MakerNote",
        37510: "UserComment",
        37724: "ImageSourceData",
        40092: "XPComment",
        40094: "XPKeywords",
        40961: "ColorSpace",
        40962: "PixelXDimension",
        40963: "PixelXDimension",
        41486: "FocalPlaneXResolution",
        41487: "FocalPlaneYResolution",
        41488: "FocalPlaneResolutionUnit",
        41985: "CustomRendered",
        41986: "ExposureMode",
        41987: "WhiteBalance",
        41990: "SceneCaptureType",
        50706: "DNGVersion",
        50707: "DNGBackwardVersion",
        50708: "UniqueCameraModel",
        50709: "LocalizedCameraModel",
        50710: "CFAPlaneColor",
        50711: "CFALayout",
        50712: "LinearizationTable",
        50713: "BlackLevelRepeatDim",
        50714: "BlackLevel",
        50716: "BlackLevelDeltaV",
        50717: "WhiteLevel",
        50718: "DefaultScale",
        50719: "DefaultCropOrigin",
        50720: "DefaultCropSize",
        50733: "BayerGreenSplit",
        50738: "AntiAliasStrength",
        50721: "ColorMatrix1",
        50722: "ColorMatrix2",
        50723: "CameraCalibration1",
        50724: "CameraCalibration2",
        50727: "AnalogBalance",
        50728: "AsShotNeutral",
        50730: "BaselineExposure",
        50731: "BaselineNoise",
        50732: "BaselineSharpness",
        50734: "LinearResponseLimit",
        50735: "CameraSerialNumber",
        50736: "LensInfo",
        50739: "ShadowScale",
        50740: "DNGPrivateData",
        50741: "MakerNoteSafety",
        50778: "CalibrationIlluminant1",
        50779: "CalibrationIlluminant2",
        50780: "BestQualityScale",
        50781: "RawDataUniqueID",
        50827: "OriginalRawFileName",
        50829: "ActiveArea",
        50830: "MaskedAreas",
        50931: "CameraCalibrationSignature",
        50932: "ProfileCalibrationSignature",
        50935: "NoiseReductionApplied",
        50936: "ProfileName",
        50937: "ProfileHueSatMapDims",
        50938: "ProfileHueSatMapData1",
        50939: "ProfileHueSatMapData2",
        50940: "ProfileToneCurve",
        50941: "ProfileEmbedPolicy",
        50942: "ProfileCopyright",
        50964: "ForwardMatrix1",
        50965: "ForwardMatrix2",
        50966: "PreviewApplicationName",
        50967: "PreviewApplicationVersion",
        50969: "PreviewSettingsDigest",
        50970: "PreviewColorSpace",
        50971: "PreviewDateTime",
        50972: "RawImageDigest",
        51008: "OpcodeList1",
        51009: "OpcodeList2",
        51022: "OpcodeList3",
        51041: "NoiseProfile",
        51089: "OriginalDefaultFinalSize",
        51090: "OriginalBestQualityFinalSize",
        51091: "OriginalDefaultCropSize",
        51125: "DefaultUserCrop"
      };
      UTIF2.ttypes = {256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4};
      UTIF2._readIFD = function(bin, data, offset, ifds) {
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        var ifd = {};
        ifds.push(ifd);
        for (var i = 0; i < cnt; i++) {
          var tag = bin.readUshort(data, offset);
          offset += 2;
          var type = bin.readUshort(data, offset);
          offset += 2;
          var num = bin.readUint(data, offset);
          offset += 4;
          var voff = bin.readUint(data, offset);
          offset += 4;
          var arr = [];
          ifd["t" + tag] = arr;
          if (type == 1 || type == 7) {
            for (var j = 0; j < num; j++)
              arr.push(data[(num < 5 ? offset - 4 : voff) + j]);
          }
          if (type == 2) {
            arr.push(bin.readASCII(data, num < 5 ? offset - 4 : voff, num - 1));
          }
          if (type == 3) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 4) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 5) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readUint(data, voff + j * 8) / bin.readUint(data, voff + j * 8 + 4));
          }
          if (type == 8) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 9) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 10) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readInt(data, voff + j * 8) / bin.readInt(data, voff + j * 8 + 4));
          }
          if (type == 11) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readFloat(data, voff + j * 4));
          }
          if (type == 12) {
            for (var j = 0; j < num; j++)
              arr.push(bin.readDouble(data, voff + j * 8));
          }
          if (num != 0 && arr.length == 0)
            log("unknown TIFF tag type: ", type, "num:", num);
          if (tag == 330)
            for (var j = 0; j < num; j++)
              UTIF2._readIFD(bin, data, arr[j], ifds);
        }
        return offset;
      };
      UTIF2._writeIFD = function(bin, data, offset, ifd) {
        var keys = Object.keys(ifd);
        bin.writeUshort(data, offset, keys.length);
        offset += 2;
        var eoff = offset + keys.length * 12 + 4;
        for (var ki = 0; ki < keys.length; ki++) {
          var key = keys[ki];
          var tag = parseInt(key.slice(1)), type = UTIF2.ttypes[tag];
          if (type == null)
            throw new Error("unknown type of tag: " + tag);
          var val = ifd[key];
          if (type == 2)
            val = val[0] + "\0";
          var num = val.length;
          bin.writeUshort(data, offset, tag);
          offset += 2;
          bin.writeUshort(data, offset, type);
          offset += 2;
          bin.writeUint(data, offset, num);
          offset += 4;
          var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][type] * num;
          var toff = offset;
          if (dlen > 4) {
            bin.writeUint(data, offset, eoff);
            toff = eoff;
          }
          if (type == 2) {
            bin.writeASCII(data, toff, val);
          }
          if (type == 3) {
            for (var i = 0; i < num; i++)
              bin.writeUshort(data, toff + 2 * i, val[i]);
          }
          if (type == 4) {
            for (var i = 0; i < num; i++)
              bin.writeUint(data, toff + 4 * i, val[i]);
          }
          if (type == 5) {
            for (var i = 0; i < num; i++) {
              bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 1e4));
              bin.writeUint(data, toff + 8 * i + 4, 1e4);
            }
          }
          if (type == 12) {
            for (var i = 0; i < num; i++)
              bin.writeDouble(data, toff + 8 * i, val[i]);
          }
          if (dlen > 4) {
            dlen += dlen & 1;
            eoff += dlen;
          }
          offset += 4;
        }
        return [offset, eoff];
      };
      UTIF2.toRGBA8 = function(out) {
        var w = out.width, h = out.height, area = w * h, qarea = area * 4, data = out.data;
        var img = new Uint8Array(area * 4);
        var intp = out["t262"][0], bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1, isLE = out.isLE ? 1 : 0;
        if (false) {
        } else if (intp == 0) {
          var bpl = Math.ceil(bps * w / 8);
          for (var y = 0; y < h; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;
                img[qi + 3] = 255;
              }
            if (bps == 4)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (i & 1) & 15;
                img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + i];
                img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 1) {
          var bpl = Math.ceil(bps * w / 8);
          for (var y = 0; y < h; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = px * 255;
                img[qi + 3] = 255;
              }
            if (bps == 2)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (i & 3) & 3;
                img[qi] = img[qi + 1] = img[qi + 2] = px * 85;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + i];
                img[qi] = img[qi + 1] = img[qi + 2] = px;
                img[qi + 3] = 255;
              }
            if (bps == 16)
              for (var i = 0; i < w; i++) {
                var qi = io + i << 2, px = data[off + (2 * i + isLE)];
                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, px);
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 2) {
          if (bps == 8) {
            if (out["t338"]) {
              if (out["t338"][0] > 0)
                for (var i = 0; i < qarea; i++)
                  img[i] = data[i];
              else
                for (var i = 0; i < qarea; i += 4) {
                  img[i] = data[i];
                  img[i + 1] = data[i + 1];
                  img[i + 2] = data[i + 2];
                  img[i + 3] = 255;
                }
            } else {
              var smpls = out["t258"] ? out["t258"].length : 3;
              if (smpls == 4)
                for (var i = 0; i < qarea; i++)
                  img[i] = data[i];
              if (smpls == 3)
                for (var i = 0; i < area; i++) {
                  var qi = i << 2, ti = i * 3;
                  img[qi] = data[ti];
                  img[qi + 1] = data[ti + 1];
                  img[qi + 2] = data[ti + 2];
                  img[qi + 3] = 255;
                }
            }
          } else
            for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 6;
              img[qi] = data[ti];
              img[qi + 1] = data[ti + 2];
              img[qi + 2] = data[ti + 4];
              img[qi + 3] = 255;
            }
        } else if (intp == 3) {
          var map = out["t320"];
          for (var i = 0; i < area; i++) {
            var qi = i << 2, mi = data[i];
            img[qi] = map[mi] >> 8;
            img[qi + 1] = map[256 + mi] >> 8;
            img[qi + 2] = map[512 + mi] >> 8;
            img[qi + 3] = 255;
          }
        } else if (intp == 5) {
          var smpls = out["t258"] ? out["t258"].length : 4;
          var gotAlpha = smpls > 4 ? 1 : 0;
          for (var i = 0; i < area; i++) {
            var qi = i << 2, si = i * smpls;
            var C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
            img[qi] = ~~(C * K + 0.5);
            img[qi + 1] = ~~(M * K + 0.5);
            img[qi + 2] = ~~(Y * K + 0.5);
            img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
          }
        } else
          log("Unknown Photometric interpretation: " + intp);
        return img;
      };
      UTIF2.replaceIMG = function() {
        var imgs = document.getElementsByTagName("img");
        for (var i = 0; i < imgs.length; i++) {
          var img = imgs[i], src = img.getAttribute("src");
          if (src == null)
            continue;
          var suff = src.split(".").pop().toLowerCase();
          if (suff != "tif" && suff != "tiff")
            continue;
          var xhr = new XMLHttpRequest();
          UTIF2._xhrs.push(xhr);
          UTIF2._imgs.push(img);
          xhr.open("GET", src);
          xhr.responseType = "arraybuffer";
          xhr.onload = UTIF2._imgLoaded;
          xhr.send();
        }
      };
      UTIF2._xhrs = [];
      UTIF2._imgs = [];
      UTIF2._imgLoaded = function(e) {
        var buff = e.target.response;
        var ifds = UTIF2.decode(buff), page = ifds[0];
        UTIF2.decodeImages(buff, ifds);
        var rgba = UTIF2.toRGBA8(page), w = page.width, h = page.height;
        var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
        UTIF2._xhrs.splice(ind, 1);
        UTIF2._imgs.splice(ind, 1);
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w, h);
        for (var i = 0; i < rgba.length; i++)
          imgd.data[i] = rgba[i];
        ctx.putImageData(imgd, 0, 0);
        var attr = ["style", "class", "id"];
        for (var i = 0; i < attr.length; i++)
          cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
        img.parentNode.replaceChild(cnv, img);
      };
      UTIF2._binBE = {
        nextZero: function(data, o) {
          while (data[o] != 0)
            o++;
          return o;
        },
        readUshort: function(buff, p) {
          return buff[p] << 8 | buff[p + 1];
        },
        readShort: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 1];
          a[1] = buff[p + 0];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: function(buff, p, l) {
          var s = "";
          for (var i = 0; i < l; i++)
            s += String.fromCharCode(buff[p + i]);
          return s;
        },
        readFloat: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i = 0; i < 4; i++)
            a[i] = buff[p + 3 - i];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i = 0; i < 8; i++)
            a[i] = buff[p + 7 - i];
          return UTIF2._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n) {
          buff[p] = n >> 8 & 255;
          buff[p + 1] = n & 255;
        },
        writeUint: function(buff, p, n) {
          buff[p] = n >> 24 & 255;
          buff[p + 1] = n >> 16 & 255;
          buff[p + 2] = n >> 8 & 255;
          buff[p + 3] = n >> 0 & 255;
        },
        writeASCII: function(buff, p, s) {
          for (var i = 0; i < s.length; i++)
            buff[p + i] = s.charCodeAt(i);
        },
        writeDouble: function(buff, p, n) {
          UTIF2._binBE.fl64[0] = n;
          for (var i = 0; i < 8; i++)
            buff[p + i] = UTIF2._binBE.ui8[7 - i];
        }
      };
      UTIF2._binBE.ui8 = new Uint8Array(8);
      UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binLE = {
        nextZero: UTIF2._binBE.nextZero,
        readUshort: function(buff, p) {
          return buff[p + 1] << 8 | buff[p];
        },
        readShort: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: UTIF2._binBE.readASCII,
        readFloat: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i = 0; i < 4; i++)
            a[i] = buff[p + i];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i = 0; i < 8; i++)
            a[i] = buff[p + i];
          return UTIF2._binBE.fl64[0];
        }
      };
      UTIF2._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
        var xlim = Math.min(tw, w - xoff);
        var ylim = Math.min(th, h - yoff);
        for (var y = 0; y < ylim; y++) {
          var tof = (yoff + y) * w + xoff;
          var sof = y * tw;
          for (var x = 0; x < xlim; x++)
            b[tof + x] = tb[sof + x];
        }
      };
    })(UTIF, pako);
  })();
});

// node_modules/@jimp/tiff/dist/index.js
var require_dist7 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _utif = _interopRequireDefault(require_UTIF());
  var MIME_TYPE = "image/tiff";
  var _default = function _default2() {
    return {
      mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["tiff", "tif"]),
      constants: {
        MIME_TIFF: MIME_TYPE
      },
      decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
        var ifds = _utif["default"].decode(data);
        var page = ifds[0];
        _utif["default"].decodeImages(data, ifds);
        var rgba = _utif["default"].toRGBA8(page);
        return {
          data: Buffer.from(rgba),
          width: page.t256[0],
          height: page.t257[0]
        };
      }),
      encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image) {
        var tiff = _utif["default"].encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);
        return Buffer.from(tiff);
      })
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS((exports2) => {
  "use strict";
  function GifWriter(buf, width, height, gopts) {
    var p = 0;
    var gopts = gopts === void 0 ? {} : gopts;
    var loop_count = gopts.loop === void 0 ? null : gopts.loop;
    var global_palette = gopts.palette === void 0 ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette) {
      var num_colors = palette.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
      }
      return num_colors;
    }
    buf[p++] = 71;
    buf[p++] = 73;
    buf[p++] = 70;
    buf[p++] = 56;
    buf[p++] = 57;
    buf[p++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1)
        ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== void 0) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p++] = width & 255;
    buf[p++] = width >> 8 & 255;
    buf[p++] = height & 255;
    buf[p++] = height >> 8 & 255;
    buf[p++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
    buf[p++] = background;
    buf[p++] = 0;
    if (global_palette !== null) {
      for (var i = 0, il = global_palette.length; i < il; ++i) {
        var rgb = global_palette[i];
        buf[p++] = rgb >> 16 & 255;
        buf[p++] = rgb >> 8 & 255;
        buf[p++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p++] = 33;
      buf[p++] = 255;
      buf[p++] = 11;
      buf[p++] = 78;
      buf[p++] = 69;
      buf[p++] = 84;
      buf[p++] = 83;
      buf[p++] = 67;
      buf[p++] = 65;
      buf[p++] = 80;
      buf[p++] = 69;
      buf[p++] = 50;
      buf[p++] = 46;
      buf[p++] = 48;
      buf[p++] = 3;
      buf[p++] = 1;
      buf[p++] = loop_count & 255;
      buf[p++] = loop_count >> 8 & 255;
      buf[p++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
      if (ended === true) {
        --p;
        ended = false;
      }
      opts = opts === void 0 ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette = opts.palette;
      if (palette === void 0 || palette === null) {
        using_local_palette = false;
        palette = global_palette;
      }
      if (palette === void 0 || palette === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette);
      var min_code_size = 0;
      while (num_colors >>= 1)
        ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === void 0 ? 0 : opts.delay;
      var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== void 0 && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p++] = 33;
        buf[p++] = 249;
        buf[p++] = 4;
        buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p++] = delay & 255;
        buf[p++] = delay >> 8 & 255;
        buf[p++] = transparent_index;
        buf[p++] = 0;
      }
      buf[p++] = 44;
      buf[p++] = x & 255;
      buf[p++] = x >> 8 & 255;
      buf[p++] = y & 255;
      buf[p++] = y >> 8 & 255;
      buf[p++] = w & 255;
      buf[p++] = w >> 8 & 255;
      buf[p++] = h & 255;
      buf[p++] = h >> 8 & 255;
      buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
          var rgb2 = palette[i2];
          buf[p++] = rgb2 >> 16 & 255;
          buf[p++] = rgb2 >> 8 & 255;
          buf[p++] = rgb2 & 255;
        }
      }
      p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
      return p;
    };
    this.end = function() {
      if (ended === false) {
        buf[p++] = 59;
        ended = true;
      }
      return p;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p;
    };
    this.setOutputBufferPosition = function(v) {
      p = v;
    };
  }
  function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
    buf[p++] = min_code_size;
    var cur_subblock = p++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }
    }
    function emit_code(c) {
      cur |= c << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i = 1, il = index_stream.length; i < il; ++i) {
      var k = index_stream[i] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === void 0) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size)
            ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p - cur_subblock - 1;
      buf[p++] = 0;
    }
    return p;
  }
  function GifReader(buf) {
    var p = 0;
    if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p++] | buf[p++] << 8;
    var height = buf[p++] | buf[p++] << 8;
    var pf0 = buf[p++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    var background = buf[p++];
    buf[p++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p;
      global_palette_size = num_global_colors;
      p += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p < buf.length) {
      switch (buf[p++]) {
        case 33:
          switch (buf[p++]) {
            case 255:
              if (buf[p] !== 11 || buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                p += 14;
                loop_count = buf[p++] | buf[p++] << 8;
                p++;
              } else {
                p += 12;
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
              }
              break;
            case 249:
              if (buf[p++] !== 4 || buf[p + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p++];
              delay = buf[p++] | buf[p++] << 8;
              transparent_index = buf[p++];
              if ((pf1 & 1) === 0)
                transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p++];
                if (!(block_size >= 0))
                  throw Error("Invalid block size");
                if (block_size === 0)
                  break;
                p += block_size;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
          }
          break;
        case 44:
          var x = buf[p++] | buf[p++] << 8;
          var y = buf[p++] | buf[p++] << 8;
          var w = buf[p++] | buf[p++] << 8;
          var h = buf[p++] | buf[p++] << 8;
          var pf2 = buf[p++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p;
            palette_size = num_local_colors;
            p += num_local_colors * 3;
          }
          var data_offset = p;
          p++;
          while (true) {
            var block_size = buf[p++];
            if (!(block_size >= 0))
              throw Error("Invalid block size");
            if (block_size === 0)
              break;
            p += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
          break;
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = b;
          pixels[op++] = g;
          pixels[op++] = r;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = r;
          pixels[op++] = g;
          pixels[op++] = b;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
  }
  function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    var min_code_size = code_stream[p++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0)
          break;
        cur |= code_stream[p++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code === eoi_code) {
        break;
      }
      var chase_code = code < next_code ? code : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output[op++] = k;
      op += chase_length;
      var b = op;
      if (chase_code !== code)
        output[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output[--b] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output;
  }
  try {
    exports2.GifWriter = GifWriter;
    exports2.GifReader = GifReader;
  } catch (e) {
  }
});

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS((exports2, module2) => {
  "use strict";
  var BitmapImage = class {
    constructor(...args) {
      if (args.length === 0) {
        throw new Error("constructor requires parameters");
      }
      const firstArg = args[0];
      if (firstArg !== null && typeof firstArg === "object") {
        if (firstArg instanceof BitmapImage) {
          const sourceBitmap = firstArg.bitmap;
          this.bitmap = {
            width: sourceBitmap.width,
            height: sourceBitmap.height,
            data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
          };
          sourceBitmap.data.copy(this.bitmap.data);
        } else if (firstArg.width && firstArg.height && firstArg.data) {
          this.bitmap = firstArg;
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      } else if (typeof firstArg === "number" && typeof args[1] === "number") {
        const width = firstArg;
        const height = args[1];
        const thirdArg = args[2];
        this.bitmap = {width, height};
        if (Buffer.isBuffer(thirdArg)) {
          this.bitmap.data = thirdArg;
        } else {
          this.bitmap.data = new Buffer(width * height * 4);
          if (typeof thirdArg === "number") {
            this.fillRGBA(thirdArg);
          }
        }
      } else {
        throw new Error("unrecognized constructor parameters");
      }
    }
    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
      if (fromX + fromWidth > this.bitmap.width) {
        throw new Error("copy exceeds width of source bitmap");
      }
      if (toX + fromWidth > toImage.bitmap.width) {
        throw new Error("copy exceeds width of target bitmap");
      }
      if (fromY + fromHeight > this.bitmap.height) {
        throw new Error("copy exceeds height of source bitmap");
      }
      if (toY + fromHeight > toImage.bitmap.height) {
        throw new Erro("copy exceeds height of target bitmap");
      }
      const sourceBuf = this.bitmap.data;
      const targetBuf = toImage.bitmap.data;
      const sourceByteWidth = this.bitmap.width * 4;
      const targetByteWidth = toImage.bitmap.width * 4;
      const copyByteWidth = fromWidth * 4;
      let si = fromY * sourceByteWidth + fromX * 4;
      let ti = toY * targetByteWidth + toX * 4;
      while (--fromHeight >= 0) {
        sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
        si += sourceByteWidth;
        ti += targetByteWidth;
      }
      return this;
    }
    fillRGBA(rgba) {
      const buf = this.bitmap.data;
      const bufByteWidth = this.bitmap.height * 4;
      let bi = 0;
      while (bi < bufByteWidth) {
        buf.writeUInt32BE(rgba, bi);
        bi += 4;
      }
      while (bi < buf.length) {
        buf.copy(buf, bi, 0, bufByteWidth);
        bi += bufByteWidth;
      }
      return this;
    }
    getRGBA(x, y) {
      const bi = (y * this.bitmap.width + x) * 4;
      return this.bitmap.data.readUInt32BE(bi);
    }
    getRGBASet() {
      const rgbaSet = new Set();
      const buf = this.bitmap.data;
      for (let bi = 0; bi < buf.length; bi += 4) {
        rgbaSet.add(buf.readUInt32BE(bi, true));
      }
      return rgbaSet;
    }
    greyscale() {
      const buf = this.bitmap.data;
      this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
        const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
        buf[idx] = grey;
        buf[idx + 1] = grey;
        buf[idx + 2] = grey;
      });
      return this;
    }
    reframe(xOffset, yOffset, width, height, fillRGBA) {
      const cropX = xOffset < 0 ? 0 : xOffset;
      const cropY = yOffset < 0 ? 0 : yOffset;
      const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
      const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
      const newX = xOffset < 0 ? -xOffset : 0;
      const newY = yOffset < 0 ? -yOffset : 0;
      let image;
      if (fillRGBA === void 0) {
        if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
          throw new GifError(`fillRGBA required for this reframing`);
        }
        image = new BitmapImage(width, height);
      } else {
        image = new BitmapImage(width, height, fillRGBA);
      }
      this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
      this.bitmap = image.bitmap;
      return this;
    }
    scale(factor) {
      if (factor === 1) {
        return;
      }
      if (!Number.isInteger(factor) || factor < 1) {
        throw new Error("the scale must be an integer >= 1");
      }
      const sourceWidth = this.bitmap.width;
      const sourceHeight = this.bitmap.height;
      const destByteWidth = sourceWidth * factor * 4;
      const sourceBuf = this.bitmap.data;
      const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
      let sourceIndex = 0;
      let priorDestRowIndex;
      let destIndex = 0;
      for (let y = 0; y < sourceHeight; ++y) {
        priorDestRowIndex = destIndex;
        for (let x = 0; x < sourceWidth; ++x) {
          const color = sourceBuf.readUInt32BE(sourceIndex, true);
          for (let cx = 0; cx < factor; ++cx) {
            destBuf.writeUInt32BE(color, destIndex);
            destIndex += 4;
          }
          sourceIndex += 4;
        }
        for (let cy = 1; cy < factor; ++cy) {
          destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
          destIndex += destByteWidth;
          priorDestRowIndex += destByteWidth;
        }
      }
      this.bitmap = {
        width: sourceWidth * factor,
        height: sourceHeight * factor,
        data: destBuf
      };
      return this;
    }
    scanAllCoords(scanHandler) {
      const width = this.bitmap.width;
      const bufferLength = this.bitmap.data.length;
      let x = 0;
      let y = 0;
      for (let bi = 0; bi < bufferLength; bi += 4) {
        scanHandler(x, y, bi);
        if (++x === width) {
          x = 0;
          ++y;
        }
      }
    }
    scanAllIndexes(scanHandler) {
      const bufferLength = this.bitmap.data.length;
      for (let bi = 0; bi < bufferLength; bi += 4) {
        scanHandler(bi);
      }
    }
  };
  module2.exports = BitmapImage;
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS((exports2) => {
  "use strict";
  var Gif = class {
    constructor(buffer, frames, spec) {
      this.width = spec.width;
      this.height = spec.height;
      this.loops = spec.loops;
      this.usesTransparency = spec.usesTransparency;
      this.colorScope = spec.colorScope;
      this.frames = frames;
      this.buffer = buffer;
    }
  };
  Gif.GlobalColorsPreferred = 0;
  Gif.GlobalColorsOnly = 1;
  Gif.LocalColorsOnly = 2;
  var GifError2 = class extends Error {
    constructor(messageOrError) {
      super(messageOrError);
      if (messageOrError instanceof Error) {
        this.stack = "Gif" + messageOrError.stack;
      }
    }
  };
  exports2.Gif = Gif;
  exports2.GifError = GifError2;
});

// node_modules/image-q/dist/iq.js
var require_iq = __commonJS((exports2, module2) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports2 === "object" && typeof module2 === "object")
      module2.exports = factory();
    else if (typeof define === "function" && define.amd)
      define("iq", [], factory);
    else if (typeof exports2 === "object")
      exports2["iq"] = factory();
    else
      root["iq"] = factory();
  })(exports2, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module3 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
        module3.loaded = true;
        return module3.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * iq.ts - Image Quantization Library
         */
        var constants = __webpack_require__(1);
        exports3.constants = constants;
        var conversion = __webpack_require__(3);
        exports3.conversion = conversion;
        var distance = __webpack_require__(12);
        exports3.distance = distance;
        var palette = __webpack_require__(20);
        exports3.palette = palette;
        var image = __webpack_require__(30);
        exports3.image = image;
        var quality = __webpack_require__(35);
        exports3.quality = quality;
        var utils = __webpack_require__(37);
        exports3.utils = utils;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * constants.ts - part of Image Quantization Library
         */
        var bt709 = __webpack_require__(2);
        exports3.bt709 = bt709;
      },
      function(module3, exports3) {
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * constants.ts - part of Image Quantization Library
         */
        "use strict";
        var Y;
        (function(Y2) {
          Y2[Y2["RED"] = 0.2126] = "RED";
          Y2[Y2["GREEN"] = 0.7152] = "GREEN";
          Y2[Y2["BLUE"] = 0.0722] = "BLUE";
          Y2[Y2["WHITE"] = 1] = "WHITE";
        })(Y || (Y = {}));
        exports3.Y = Y;
        var x;
        (function(x2) {
          x2[x2["RED"] = 0.64] = "RED";
          x2[x2["GREEN"] = 0.3] = "GREEN";
          x2[x2["BLUE"] = 0.15] = "BLUE";
          x2[x2["WHITE"] = 0.3127] = "WHITE";
        })(x || (x = {}));
        exports3.x = x;
        var y;
        (function(y2) {
          y2[y2["RED"] = 0.33] = "RED";
          y2[y2["GREEN"] = 0.6] = "GREEN";
          y2[y2["BLUE"] = 0.06] = "BLUE";
          y2[y2["WHITE"] = 0.329] = "WHITE";
        })(y || (y = {}));
        exports3.y = y;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * iq.ts - Image Quantization Library
         */
        var rgb2xyz_1 = __webpack_require__(4);
        exports3.rgb2xyz = rgb2xyz_1.rgb2xyz;
        var rgb2hsl_1 = __webpack_require__(5);
        exports3.rgb2hsl = rgb2hsl_1.rgb2hsl;
        var rgb2lab_1 = __webpack_require__(7);
        exports3.rgb2lab = rgb2lab_1.rgb2lab;
        var lab2xyz_1 = __webpack_require__(9);
        exports3.lab2xyz = lab2xyz_1.lab2xyz;
        var lab2rgb_1 = __webpack_require__(10);
        exports3.lab2rgb = lab2rgb_1.lab2rgb;
        var xyz2lab_1 = __webpack_require__(8);
        exports3.xyz2lab = xyz2lab_1.xyz2lab;
        var xyz2rgb_1 = __webpack_require__(11);
        exports3.xyz2rgb = xyz2rgb_1.xyz2rgb;
      },
      function(module3, exports3) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * rgb2xyz.ts - part of Image Quantization Library
         */
        function correctGamma(n) {
          return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
        }
        function rgb2xyz(r, g, b) {
          r = correctGamma(r / 255);
          g = correctGamma(g / 255);
          b = correctGamma(b / 255);
          return {
            x: r * 0.4124 + g * 0.3576 + b * 0.1805,
            y: r * 0.2126 + g * 0.7152 + b * 0.0722,
            z: r * 0.0193 + g * 0.1192 + b * 0.9505
          };
        }
        exports3.rgb2xyz = rgb2xyz;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * rgb2hsl.ts - part of Image Quantization Library
         */
        var arithmetic_1 = __webpack_require__(6);
        function rgb2hsl(r, g, b) {
          var min = arithmetic_1.min3(r, g, b), max = arithmetic_1.max3(r, g, b), delta = max - min, l = (min + max) / 510;
          var s = 0;
          if (l > 0 && l < 1)
            s = delta / (l < 0.5 ? max + min : 510 - max - min);
          var h = 0;
          if (delta > 0) {
            if (max === r) {
              h = (g - b) / delta;
            } else if (max === g) {
              h = 2 + (b - r) / delta;
            } else {
              h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0)
              h += 360;
          }
          return {h, s, l};
        }
        exports3.rgb2hsl = rgb2hsl;
      },
      function(module3, exports3) {
        "use strict";
        function degrees2radians(n) {
          return n * (Math.PI / 180);
        }
        exports3.degrees2radians = degrees2radians;
        function max3(a, b, c) {
          var m = a;
          m < b && (m = b);
          m < c && (m = c);
          return m;
        }
        exports3.max3 = max3;
        function min3(a, b, c) {
          var m = a;
          m > b && (m = b);
          m > c && (m = c);
          return m;
        }
        exports3.min3 = min3;
        function intInRange(value, low, high) {
          if (value > high)
            value = high;
          if (value < low)
            value = low;
          return value | 0;
        }
        exports3.intInRange = intInRange;
        function inRange0to255Rounded(n) {
          n = Math.round(n);
          if (n > 255)
            n = 255;
          else if (n < 0)
            n = 0;
          return n;
        }
        exports3.inRange0to255Rounded = inRange0to255Rounded;
        function inRange0to255(n) {
          if (n > 255)
            n = 255;
          else if (n < 0)
            n = 0;
          return n;
        }
        exports3.inRange0to255 = inRange0to255;
        function stableSort(arrayToSort, callback) {
          var type = typeof arrayToSort[0];
          var sorted;
          if (type === "number" || type === "string") {
            var ord_1 = Object.create(null);
            for (var i = 0, l = arrayToSort.length; i < l; i++) {
              var val = arrayToSort[i];
              if (ord_1[val] || ord_1[val] === 0)
                continue;
              ord_1[val] = i;
            }
            sorted = arrayToSort.sort(function(a, b) {
              return callback(a, b) || ord_1[a] - ord_1[b];
            });
          } else {
            var ord2_1 = arrayToSort.slice(0);
            sorted = arrayToSort.sort(function(a, b) {
              return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);
            });
          }
          return sorted;
        }
        exports3.stableSort = stableSort;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * rgb2lab.ts - part of Image Quantization Library
         */
        var rgb2xyz_1 = __webpack_require__(4);
        var xyz2lab_1 = __webpack_require__(8);
        function rgb2lab(r, g, b) {
          var xyz = rgb2xyz_1.rgb2xyz(r, g, b);
          return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);
        }
        exports3.rgb2lab = rgb2lab;
      },
      function(module3, exports3) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * xyz2lab.ts - part of Image Quantization Library
         */
        var refX = 0.95047, refY = 1, refZ = 1.08883;
        function pivot(n) {
          return n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
        }
        function xyz2lab(x, y, z) {
          x = pivot(x / refX);
          y = pivot(y / refY);
          z = pivot(z / refZ);
          if (116 * y - 16 < 0)
            throw new Error("xxx");
          return {
            L: Math.max(0, 116 * y - 16),
            a: 500 * (x - y),
            b: 200 * (y - z)
          };
        }
        exports3.xyz2lab = xyz2lab;
      },
      function(module3, exports3) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * lab2xyz.ts - part of Image Quantization Library
         */
        var refX = 0.95047, refY = 1, refZ = 1.08883;
        function pivot(n) {
          return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
        }
        function lab2xyz(L, a, b) {
          var y = (L + 16) / 116, x = a / 500 + y, z = y - b / 200;
          return {
            x: refX * pivot(x),
            y: refY * pivot(y),
            z: refZ * pivot(z)
          };
        }
        exports3.lab2xyz = lab2xyz;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * lab2rgb.ts - part of Image Quantization Library
         */
        var lab2xyz_1 = __webpack_require__(9);
        var xyz2rgb_1 = __webpack_require__(11);
        function lab2rgb(L, a, b) {
          var xyz = lab2xyz_1.lab2xyz(L, a, b);
          return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);
        }
        exports3.lab2rgb = lab2rgb;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * xyz2rgb.ts - part of Image Quantization Library
         */
        var arithmetic_1 = __webpack_require__(6);
        function correctGamma(n) {
          return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
        }
        function xyz2rgb(x, y, z) {
          var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986), g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415), b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);
          return {
            r: arithmetic_1.inRange0to255Rounded(r * 255),
            g: arithmetic_1.inRange0to255Rounded(g * 255),
            b: arithmetic_1.inRange0to255Rounded(b * 255)
          };
        }
        exports3.xyz2rgb = xyz2rgb;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * iq.ts - Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        exports3.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;
        var cie94_1 = __webpack_require__(14);
        exports3.CIE94Textiles = cie94_1.CIE94Textiles;
        exports3.CIE94GraphicArts = cie94_1.CIE94GraphicArts;
        var ciede2000_1 = __webpack_require__(15);
        exports3.CIEDE2000 = ciede2000_1.CIEDE2000;
        var cmetric_1 = __webpack_require__(16);
        exports3.CMETRIC = cmetric_1.CMETRIC;
        var euclidean_1 = __webpack_require__(17);
        exports3.AbstractEuclidean = euclidean_1.AbstractEuclidean;
        exports3.Euclidean = euclidean_1.Euclidean;
        exports3.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha;
        exports3.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;
        var manhattan_1 = __webpack_require__(18);
        exports3.AbstractManhattan = manhattan_1.AbstractManhattan;
        exports3.Manhattan = manhattan_1.Manhattan;
        exports3.ManhattanSRGB = manhattan_1.ManhattanSRGB;
        exports3.ManhattanNommyde = manhattan_1.ManhattanNommyde;
        var pngQuant_1 = __webpack_require__(19);
        exports3.PNGQUANT = pngQuant_1.PNGQUANT;
      },
      function(module3, exports3) {
        "use strict";
        var AbstractDistanceCalculator = function() {
          function AbstractDistanceCalculator2() {
            this._setDefaults();
            this.setWhitePoint(255, 255, 255, 255);
          }
          AbstractDistanceCalculator2.prototype.setWhitePoint = function(r, g, b, a) {
            this._whitePoint = {
              r: r > 0 ? 255 / r : 0,
              g: g > 0 ? 255 / g : 0,
              b: b > 0 ? 255 / b : 0,
              a: a > 0 ? 255 / a : 0
            };
            this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
          };
          AbstractDistanceCalculator2.prototype.calculateNormalized = function(colorA, colorB) {
            return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
          };
          AbstractDistanceCalculator2.prototype._setDefaults = function() {
          };
          return AbstractDistanceCalculator2;
        }();
        exports3.AbstractDistanceCalculator = AbstractDistanceCalculator;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * cie94.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var rgb2lab_1 = __webpack_require__(7);
        var arithmetic_1 = __webpack_require__(6);
        var AbstractCIE94 = function(_super) {
          __extends(AbstractCIE942, _super);
          function AbstractCIE942() {
            _super.apply(this, arguments);
          }
          AbstractCIE942.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b));
            var dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b), dC = c1 - c2;
            var deltaH = dA * dA + dB * dB - dC * dC;
            deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
            var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
            return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1 + this._K1 * c1), 2) + Math.pow(deltaH / (1 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));
          };
          return AbstractCIE942;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.AbstractCIE94 = AbstractCIE94;
        var CIE94Textiles = function(_super) {
          __extends(CIE94Textiles2, _super);
          function CIE94Textiles2() {
            _super.apply(this, arguments);
          }
          CIE94Textiles2.prototype._setDefaults = function() {
            this._Kl = 2;
            this._K1 = 0.048;
            this._K2 = 0.014;
            this._kA = 0.25 * 50 / 255;
          };
          return CIE94Textiles2;
        }(AbstractCIE94);
        exports3.CIE94Textiles = CIE94Textiles;
        var CIE94GraphicArts = function(_super) {
          __extends(CIE94GraphicArts2, _super);
          function CIE94GraphicArts2() {
            _super.apply(this, arguments);
          }
          CIE94GraphicArts2.prototype._setDefaults = function() {
            this._Kl = 1;
            this._K1 = 0.045;
            this._K2 = 0.015;
            this._kA = 0.25 * 100 / 255;
          };
          return CIE94GraphicArts2;
        }(AbstractCIE94);
        exports3.CIE94GraphicArts = CIE94GraphicArts;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * ciede2000.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var rgb2lab_1 = __webpack_require__(7);
        var arithmetic_1 = __webpack_require__(6);
        var CIEDE2000 = function(_super) {
          __extends(CIEDE20002, _super);
          function CIEDE20002() {
            _super.apply(this, arguments);
          }
          CIEDE20002.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * CIEDE20002._kA, dE2 = this.calculateRawInLab(lab1, lab2);
            return Math.sqrt(dE2 + dA * dA);
          };
          CIEDE20002.prototype.calculateRawInLab = function(Lab1, Lab2) {
            var L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b;
            var L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b;
            var C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2, 7), G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE20002._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = CIEDE20002._calculatehp(b1, a1p), h2p = CIEDE20002._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = CIEDE20002._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = CIEDE20002._calculate_ahp(C1pC2p, h_bar, h1p, h2p), T = CIEDE20002._calculateT(ahp), aCp = (C1p + C2p) / 2, aLp_minus_50_square = Math.pow((L1 + L2) / 2 - 50, 2), S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square), S_C = 1 + 0.045 * aCp, S_H = 1 + 0.015 * T * aCp, R_T = CIEDE20002._calculateRT(ahp, aCp), dLpSL = dLp / S_L, dCpSC = dCp / S_C, dHpSH = dHp / S_H;
            return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
          };
          CIEDE20002._calculatehp = function(b, ap) {
            var hp = Math.atan2(b, ap);
            if (hp >= 0)
              return hp;
            return hp + CIEDE20002._deg360InRad;
          };
          CIEDE20002._calculateRT = function(ahp, aCp) {
            var aCp_to_7 = Math.pow(aCp, 7), R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE20002._pow25to7)), delta_theta = CIEDE20002._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE20002._deg275InRad) / CIEDE20002._deg25InRad, 2));
            return -Math.sin(2 * delta_theta) * R_C;
          };
          CIEDE20002._calculateT = function(ahp) {
            return 1 - 0.17 * Math.cos(ahp - CIEDE20002._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + CIEDE20002._deg6InRad) - 0.2 * Math.cos(ahp * 4 - CIEDE20002._deg63InRad);
          };
          CIEDE20002._calculate_ahp = function(C1pC2p, h_bar, h1p, h2p) {
            var hpSum = h1p + h2p;
            if (C1pC2p == 0)
              return hpSum;
            if (h_bar <= CIEDE20002._deg180InRad)
              return hpSum / 2;
            if (hpSum < CIEDE20002._deg360InRad)
              return (hpSum + CIEDE20002._deg360InRad) / 2;
            return (hpSum - CIEDE20002._deg360InRad) / 2;
          };
          CIEDE20002._calculate_dHp = function(C1pC2p, h_bar, h2p, h1p) {
            var dhp;
            if (C1pC2p == 0) {
              dhp = 0;
            } else if (h_bar <= CIEDE20002._deg180InRad) {
              dhp = h2p - h1p;
            } else if (h2p <= h1p) {
              dhp = h2p - h1p + CIEDE20002._deg360InRad;
            } else {
              dhp = h2p - h1p - CIEDE20002._deg360InRad;
            }
            return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
          };
          CIEDE20002._kA = 0.25 * 100 / 255;
          CIEDE20002._pow25to7 = Math.pow(25, 7);
          CIEDE20002._deg360InRad = arithmetic_1.degrees2radians(360);
          CIEDE20002._deg180InRad = arithmetic_1.degrees2radians(180);
          CIEDE20002._deg30InRad = arithmetic_1.degrees2radians(30);
          CIEDE20002._deg6InRad = arithmetic_1.degrees2radians(6);
          CIEDE20002._deg63InRad = arithmetic_1.degrees2radians(63);
          CIEDE20002._deg275InRad = arithmetic_1.degrees2radians(275);
          CIEDE20002._deg25InRad = arithmetic_1.degrees2radians(25);
          return CIEDE20002;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.CIEDE2000 = CIEDE2000;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * cmetric.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var CMETRIC = function(_super) {
          __extends(CMETRIC2, _super);
          function CMETRIC2() {
            _super.apply(this, arguments);
          }
          CMETRIC2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
            return Math.sqrt(dE + dA * dA);
          };
          return CMETRIC2;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.CMETRIC = CMETRIC;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * euclidean.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var bt709_1 = __webpack_require__(2);
        var AbstractEuclidean = function(_super) {
          __extends(AbstractEuclidean2, _super);
          function AbstractEuclidean2() {
            _super.apply(this, arguments);
          }
          AbstractEuclidean2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
            return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
          };
          return AbstractEuclidean2;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.AbstractEuclidean = AbstractEuclidean;
        var Euclidean = function(_super) {
          __extends(Euclidean2, _super);
          function Euclidean2() {
            _super.apply(this, arguments);
          }
          Euclidean2.prototype._setDefaults = function() {
            this._kR = 1;
            this._kG = 1;
            this._kB = 1;
            this._kA = 1;
          };
          return Euclidean2;
        }(AbstractEuclidean);
        exports3.Euclidean = Euclidean;
        var EuclideanRgbQuantWithAlpha = function(_super) {
          __extends(EuclideanRgbQuantWithAlpha2, _super);
          function EuclideanRgbQuantWithAlpha2() {
            _super.apply(this, arguments);
          }
          EuclideanRgbQuantWithAlpha2.prototype._setDefaults = function() {
            this._kR = bt709_1.Y.RED;
            this._kG = bt709_1.Y.GREEN;
            this._kB = bt709_1.Y.BLUE;
            this._kA = 1;
          };
          return EuclideanRgbQuantWithAlpha2;
        }(AbstractEuclidean);
        exports3.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;
        var EuclideanRgbQuantWOAlpha = function(_super) {
          __extends(EuclideanRgbQuantWOAlpha2, _super);
          function EuclideanRgbQuantWOAlpha2() {
            _super.apply(this, arguments);
          }
          EuclideanRgbQuantWOAlpha2.prototype._setDefaults = function() {
            this._kR = bt709_1.Y.RED;
            this._kG = bt709_1.Y.GREEN;
            this._kB = bt709_1.Y.BLUE;
            this._kA = 0;
          };
          return EuclideanRgbQuantWOAlpha2;
        }(AbstractEuclidean);
        exports3.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * manhattanNeuQuant.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var bt709_1 = __webpack_require__(2);
        var AbstractManhattan = function(_super) {
          __extends(AbstractManhattan2, _super);
          function AbstractManhattan2() {
            _super.apply(this, arguments);
          }
          AbstractManhattan2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
            if (dR < 0)
              dR = 0 - dR;
            if (dG < 0)
              dG = 0 - dG;
            if (dB < 0)
              dB = 0 - dB;
            if (dA < 0)
              dA = 0 - dA;
            return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
          };
          return AbstractManhattan2;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.AbstractManhattan = AbstractManhattan;
        var Manhattan = function(_super) {
          __extends(Manhattan2, _super);
          function Manhattan2() {
            _super.apply(this, arguments);
          }
          Manhattan2.prototype._setDefaults = function() {
            this._kR = 1;
            this._kG = 1;
            this._kB = 1;
            this._kA = 1;
          };
          return Manhattan2;
        }(AbstractManhattan);
        exports3.Manhattan = Manhattan;
        var ManhattanNommyde = function(_super) {
          __extends(ManhattanNommyde2, _super);
          function ManhattanNommyde2() {
            _super.apply(this, arguments);
          }
          ManhattanNommyde2.prototype._setDefaults = function() {
            this._kR = 0.4984;
            this._kG = 0.8625;
            this._kB = 0.2979;
            this._kA = 1;
          };
          return ManhattanNommyde2;
        }(AbstractManhattan);
        exports3.ManhattanNommyde = ManhattanNommyde;
        var ManhattanSRGB = function(_super) {
          __extends(ManhattanSRGB2, _super);
          function ManhattanSRGB2() {
            _super.apply(this, arguments);
          }
          ManhattanSRGB2.prototype._setDefaults = function() {
            this._kR = bt709_1.Y.RED;
            this._kG = bt709_1.Y.GREEN;
            this._kB = bt709_1.Y.BLUE;
            this._kA = 1;
          };
          return ManhattanSRGB2;
        }(AbstractManhattan);
        exports3.ManhattanSRGB = ManhattanSRGB;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var __extends = this && this.__extends || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * pngQuant.ts - part of Image Quantization Library
         */
        var abstractDistanceCalculator_1 = __webpack_require__(13);
        var PNGQUANT = function(_super) {
          __extends(PNGQUANT2, _super);
          function PNGQUANT2() {
            _super.apply(this, arguments);
          }
          PNGQUANT2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
            var alphas = (a2 - a1) * this._whitePoint.a;
            return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
          };
          PNGQUANT2.prototype._colordifference_ch = function(x, y, alphas) {
            var black = x - y, white = black + alphas;
            return black * black + white * white;
          };
          return PNGQUANT2;
        }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
        exports3.PNGQUANT = PNGQUANT;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var neuquant_1 = __webpack_require__(21);
        exports3.NeuQuant = neuquant_1.NeuQuant;
        var neuquantFloat_1 = __webpack_require__(25);
        exports3.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;
        var rgbquant_1 = __webpack_require__(26);
        exports3.RGBQuant = rgbquant_1.RGBQuant;
        var colorHistogram_1 = __webpack_require__(27);
        exports3.ColorHistogram = colorHistogram_1.ColorHistogram;
        var wuQuant_1 = __webpack_require__(29);
        exports3.WuQuant = wuQuant_1.WuQuant;
        exports3.WuColorCube = wuQuant_1.WuColorCube;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve TypeScript port:
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * neuquant.ts - part of Image Quantization Library
         */
        var palette_1 = __webpack_require__(22);
        var point_1 = __webpack_require__(24);
        var networkBiasShift = 3;
        var Neuron = function() {
          function Neuron2(defaultValue) {
            this.r = this.g = this.b = this.a = defaultValue;
          }
          Neuron2.prototype.toPoint = function() {
            return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
          };
          Neuron2.prototype.subtract = function(r, g, b, a) {
            this.r -= r | 0;
            this.g -= g | 0;
            this.b -= b | 0;
            this.a -= a | 0;
          };
          return Neuron2;
        }();
        var NeuQuant = function() {
          function NeuQuant2(colorDistanceCalculator, colors) {
            if (colors === void 0) {
              colors = 256;
            }
            this._distance = colorDistanceCalculator;
            this._pointArray = [];
            this._sampleFactor = 1;
            this._networkSize = colors;
            this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
          }
          NeuQuant2.prototype.sample = function(pointBuffer) {
            this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
          };
          NeuQuant2.prototype.quantize = function() {
            this._init();
            this._learn();
            return this._buildPalette();
          };
          NeuQuant2.prototype._init = function() {
            this._freq = [];
            this._bias = [];
            this._radPower = [];
            this._network = [];
            for (var i = 0; i < this._networkSize; i++) {
              this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
              this._freq[i] = NeuQuant2._initialBias / this._networkSize | 0;
              this._bias[i] = 0;
            }
          };
          NeuQuant2.prototype._learn = function() {
            var sampleFactor = this._sampleFactor;
            var pointsNumber = this._pointArray.length;
            if (pointsNumber < NeuQuant2._minpicturebytes)
              sampleFactor = 1;
            var alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
            var delta = pointsToSample / NeuQuant2._nCycles | 0, alpha = NeuQuant2._initAlpha, radius = (this._networkSize >> 3) * NeuQuant2._radiusBias;
            var rad = radius >> NeuQuant2._radiusBiasShift;
            if (rad <= 1)
              rad = 0;
            for (var i = 0; i < rad; i++) {
              this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant2._radBias / (rad * rad)) >>> 0;
            }
            var step;
            if (pointsNumber < NeuQuant2._minpicturebytes) {
              step = 1;
            } else if (pointsNumber % NeuQuant2._prime1 != 0) {
              step = NeuQuant2._prime1;
            } else if (pointsNumber % NeuQuant2._prime2 != 0) {
              step = NeuQuant2._prime2;
            } else if (pointsNumber % NeuQuant2._prime3 != 0) {
              step = NeuQuant2._prime3;
            } else {
              step = NeuQuant2._prime4;
            }
            for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
              var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
              this._alterSingle(alpha, neuronIndex, b, g, r, a);
              if (rad !== 0)
                this._alterNeighbour(rad, neuronIndex, b, g, r, a);
              pointIndex += step;
              if (pointIndex >= pointsNumber)
                pointIndex -= pointsNumber;
              i++;
              if (delta === 0)
                delta = 1;
              if (i % delta === 0) {
                alpha -= alpha / alphadec | 0;
                radius -= radius / NeuQuant2._radiusDecrease | 0;
                rad = radius >> NeuQuant2._radiusBiasShift;
                if (rad <= 1)
                  rad = 0;
                for (var j = 0; j < rad; j++)
                  this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant2._radBias / (rad * rad)) >>> 0;
              }
            }
          };
          NeuQuant2.prototype._buildPalette = function() {
            var palette = new palette_1.Palette();
            this._network.forEach(function(neuron) {
              palette.add(neuron.toPoint());
            });
            palette.sort();
            return palette;
          };
          NeuQuant2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
            var lo = i - rad;
            if (lo < -1)
              lo = -1;
            var hi = i + rad;
            if (hi > this._networkSize)
              hi = this._networkSize;
            var j = i + 1, k = i - 1, m = 1;
            while (j < hi || k > lo) {
              var a = this._radPower[m++] / NeuQuant2._alphaRadBias;
              if (j < hi) {
                var p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
              }
              if (k > lo) {
                var p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
              }
            }
          };
          NeuQuant2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
            alpha /= NeuQuant2._initAlpha;
            var n = this._network[i];
            n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
          };
          NeuQuant2.prototype._contest = function(b, g, r, a) {
            var multiplier = 255 * 4 << networkBiasShift;
            var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
            for (var i = 0; i < this._networkSize; i++) {
              var n = this._network[i], dist = this._distance.calculateNormalized(n, {r, g, b, a}) * multiplier | 0;
              if (dist < bestd) {
                bestd = dist;
                bestpos = i;
              }
              var biasdist = dist - (this._bias[i] >> NeuQuant2._initialBiasShift - networkBiasShift);
              if (biasdist < bestbiasd) {
                bestbiasd = biasdist;
                bestbiaspos = i;
              }
              var betafreq = this._freq[i] >> NeuQuant2._betaShift;
              this._freq[i] -= betafreq;
              this._bias[i] += betafreq << NeuQuant2._gammaShift;
            }
            this._freq[bestpos] += NeuQuant2._beta;
            this._bias[bestpos] -= NeuQuant2._betaGamma;
            return bestbiaspos;
          };
          NeuQuant2._prime1 = 499;
          NeuQuant2._prime2 = 491;
          NeuQuant2._prime3 = 487;
          NeuQuant2._prime4 = 503;
          NeuQuant2._minpicturebytes = NeuQuant2._prime4;
          NeuQuant2._nCycles = 100;
          NeuQuant2._initialBiasShift = 16;
          NeuQuant2._initialBias = 1 << NeuQuant2._initialBiasShift;
          NeuQuant2._gammaShift = 10;
          NeuQuant2._betaShift = 10;
          NeuQuant2._beta = NeuQuant2._initialBias >> NeuQuant2._betaShift;
          NeuQuant2._betaGamma = NeuQuant2._initialBias << NeuQuant2._gammaShift - NeuQuant2._betaShift;
          NeuQuant2._radiusBiasShift = 6;
          NeuQuant2._radiusBias = 1 << NeuQuant2._radiusBiasShift;
          NeuQuant2._radiusDecrease = 30;
          NeuQuant2._alphaBiasShift = 10;
          NeuQuant2._initAlpha = 1 << NeuQuant2._alphaBiasShift;
          NeuQuant2._radBiasShift = 8;
          NeuQuant2._radBias = 1 << NeuQuant2._radBiasShift;
          NeuQuant2._alphaRadBiasShift = NeuQuant2._alphaBiasShift + NeuQuant2._radBiasShift;
          NeuQuant2._alphaRadBias = 1 << NeuQuant2._alphaRadBiasShift;
          return NeuQuant2;
        }();
        exports3.NeuQuant = NeuQuant;
      },
      function(module3, exports3, __webpack_require__) {
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * palette.ts - part of Image Quantization Library
         */
        "use strict";
        var pointContainer_1 = __webpack_require__(23);
        var rgb2hsl_1 = __webpack_require__(5);
        var hueGroups = 10;
        function hueGroup(hue, segmentsNumber) {
          var maxHue = 360, seg = maxHue / segmentsNumber, half = seg / 2;
          for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
            if (hue >= mid && hue < mid + seg)
              return i;
          }
          return 0;
        }
        exports3.hueGroup = hueGroup;
        var Palette = function() {
          function Palette2() {
            this._pointArray = [];
            this._i32idx = {};
            this._pointContainer = new pointContainer_1.PointContainer();
            this._pointContainer.setHeight(1);
            this._pointArray = this._pointContainer.getPointArray();
          }
          Palette2.prototype.add = function(color) {
            this._pointArray.push(color);
            this._pointContainer.setWidth(this._pointArray.length);
          };
          Palette2.prototype.has = function(color) {
            for (var i = this._pointArray.length - 1; i >= 0; i--) {
              if (color.uint32 === this._pointArray[i].uint32)
                return true;
            }
            return false;
          };
          Palette2.prototype.getNearestColor = function(colorDistanceCalculator, color) {
            return this._pointArray[this.getNearestIndex(colorDistanceCalculator, color) | 0];
          };
          Palette2.prototype.getPointContainer = function() {
            return this._pointContainer;
          };
          Palette2.prototype._nearestPointFromCache = function(key) {
            return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
          };
          Palette2.prototype.getNearestIndex = function(colorDistanceCalculator, point) {
            var idx = this._nearestPointFromCache("" + point.uint32);
            if (idx >= 0)
              return idx;
            var minimalDistance = Number.MAX_VALUE;
            idx = 0;
            for (var i = 0, l = this._pointArray.length; i < l; i++) {
              var p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
              if (distance < minimalDistance) {
                minimalDistance = distance;
                idx = i;
              }
            }
            this._i32idx[point.uint32] = idx;
            return idx;
          };
          Palette2.prototype.sort = function() {
            this._i32idx = {};
            this._pointArray.sort(function(a, b) {
              var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b), hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);
              var hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups), hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
              var hueDiff = hueB - hueA;
              if (hueDiff)
                return -hueDiff;
              var lA = a.getLuminosity(true), lB = b.getLuminosity(true);
              if (lB - lA !== 0)
                return lB - lA;
              var satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
              if (satDiff)
                return -satDiff;
              return 0;
            });
          };
          return Palette2;
        }();
        exports3.Palette = Palette;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * pointContainer.ts - part of Image Quantization Library
         */
        var point_1 = __webpack_require__(24);
        var PointContainer = function() {
          function PointContainer2() {
            this._width = 0;
            this._height = 0;
            this._pointArray = [];
          }
          PointContainer2.prototype.getWidth = function() {
            return this._width;
          };
          PointContainer2.prototype.getHeight = function() {
            return this._height;
          };
          PointContainer2.prototype.setWidth = function(width) {
            this._width = width;
          };
          PointContainer2.prototype.setHeight = function(height) {
            this._height = height;
          };
          PointContainer2.prototype.getPointArray = function() {
            return this._pointArray;
          };
          PointContainer2.prototype.clone = function() {
            var clone = new PointContainer2();
            clone._width = this._width;
            clone._height = this._height;
            for (var i = 0, l = this._pointArray.length; i < l; i++) {
              clone._pointArray[i] = point_1.Point.createByUint32(this._pointArray[i].uint32 | 0);
            }
            return clone;
          };
          PointContainer2.prototype.toUint32Array = function() {
            var l = this._pointArray.length, uint32Array = new Uint32Array(l);
            for (var i = 0; i < l; i++) {
              uint32Array[i] = this._pointArray[i].uint32;
            }
            return uint32Array;
          };
          PointContainer2.prototype.toUint8Array = function() {
            return new Uint8Array(this.toUint32Array().buffer);
          };
          PointContainer2.fromHTMLImageElement = function(img) {
            var width = img.naturalWidth, height = img.naturalHeight;
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
            return PointContainer2.fromHTMLCanvasElement(canvas);
          };
          PointContainer2.fromHTMLCanvasElement = function(canvas) {
            var width = canvas.width, height = canvas.height;
            var ctx = canvas.getContext("2d"), imgData = ctx.getImageData(0, 0, width, height);
            return PointContainer2.fromImageData(imgData);
          };
          PointContainer2.fromNodeCanvas = function(canvas) {
            return PointContainer2.fromHTMLCanvasElement(canvas);
          };
          PointContainer2.fromImageData = function(imageData) {
            var width = imageData.width, height = imageData.height;
            return PointContainer2.fromCanvasPixelArray(imageData.data, width, height);
          };
          PointContainer2.fromArray = function(byteArray, width, height) {
            var uint8array = new Uint8Array(byteArray);
            return PointContainer2.fromUint8Array(uint8array, width, height);
          };
          PointContainer2.fromCanvasPixelArray = function(data, width, height) {
            return PointContainer2.fromArray(data, width, height);
          };
          PointContainer2.fromUint8Array = function(uint8array, width, height) {
            return PointContainer2.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);
          };
          PointContainer2.fromUint32Array = function(uint32array, width, height) {
            var container = new PointContainer2();
            container._width = width;
            container._height = height;
            for (var i = 0, l = uint32array.length; i < l; i++) {
              container._pointArray[i] = point_1.Point.createByUint32(uint32array[i] | 0);
            }
            return container;
          };
          return PointContainer2;
        }();
        exports3.PointContainer = PointContainer;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * point.ts - part of Image Quantization Library
         */
        var bt709_1 = __webpack_require__(2);
        var Point = function() {
          function Point2() {
            this.uint32 = -1 >>> 0;
            this.r = this.g = this.b = this.a = 0;
            this.rgba = new Array(4);
            this.rgba[0] = 0;
            this.rgba[1] = 0;
            this.rgba[2] = 0;
            this.rgba[3] = 0;
          }
          Point2.createByQuadruplet = function(quadruplet) {
            var point = new Point2();
            point.r = quadruplet[0] | 0;
            point.g = quadruplet[1] | 0;
            point.b = quadruplet[2] | 0;
            point.a = quadruplet[3] | 0;
            point._loadUINT32();
            point._loadQuadruplet();
            return point;
          };
          Point2.createByRGBA = function(red, green, blue, alpha) {
            var point = new Point2();
            point.r = red | 0;
            point.g = green | 0;
            point.b = blue | 0;
            point.a = alpha | 0;
            point._loadUINT32();
            point._loadQuadruplet();
            return point;
          };
          Point2.createByUint32 = function(uint32) {
            var point = new Point2();
            point.uint32 = uint32 >>> 0;
            point._loadRGBA();
            point._loadQuadruplet();
            return point;
          };
          Point2.prototype.from = function(point) {
            this.r = point.r;
            this.g = point.g;
            this.b = point.b;
            this.a = point.a;
            this.uint32 = point.uint32;
            this.rgba[0] = point.r;
            this.rgba[1] = point.g;
            this.rgba[2] = point.b;
            this.rgba[3] = point.a;
          };
          Point2.prototype.getLuminosity = function(useAlphaChannel) {
            var r = this.r, g = this.g, b = this.b;
            if (useAlphaChannel) {
              r = Math.min(255, 255 - this.a + this.a * r / 255);
              g = Math.min(255, 255 - this.a + this.a * g / 255);
              b = Math.min(255, 255 - this.a + this.a * b / 255);
            }
            return r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;
          };
          Point2.prototype._loadUINT32 = function() {
            this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
          };
          Point2.prototype._loadRGBA = function() {
            this.r = this.uint32 & 255;
            this.g = this.uint32 >>> 8 & 255;
            this.b = this.uint32 >>> 16 & 255;
            this.a = this.uint32 >>> 24 & 255;
          };
          Point2.prototype._loadQuadruplet = function() {
            this.rgba[0] = this.r;
            this.rgba[1] = this.g;
            this.rgba[2] = this.b;
            this.rgba[3] = this.a;
          };
          return Point2;
        }();
        exports3.Point = Point;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve TypeScript port:
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * neuquant.ts - part of Image Quantization Library
         */
        var palette_1 = __webpack_require__(22);
        var point_1 = __webpack_require__(24);
        var networkBiasShift = 3;
        var NeuronFloat = function() {
          function NeuronFloat2(defaultValue) {
            this.r = this.g = this.b = this.a = defaultValue;
          }
          NeuronFloat2.prototype.toPoint = function() {
            return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
          };
          NeuronFloat2.prototype.subtract = function(r, g, b, a) {
            this.r -= r;
            this.g -= g;
            this.b -= b;
            this.a -= a;
          };
          return NeuronFloat2;
        }();
        var NeuQuantFloat = function() {
          function NeuQuantFloat2(colorDistanceCalculator, colors) {
            if (colors === void 0) {
              colors = 256;
            }
            this._distance = colorDistanceCalculator;
            this._pointArray = [];
            this._sampleFactor = 1;
            this._networkSize = colors;
            this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
          }
          NeuQuantFloat2.prototype.sample = function(pointBuffer) {
            this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
          };
          NeuQuantFloat2.prototype.quantize = function() {
            this._init();
            this._learn();
            return this._buildPalette();
          };
          NeuQuantFloat2.prototype._init = function() {
            this._freq = [];
            this._bias = [];
            this._radPower = [];
            this._network = [];
            for (var i = 0; i < this._networkSize; i++) {
              this._network[i] = new NeuronFloat((i << networkBiasShift + 8) / this._networkSize);
              this._freq[i] = NeuQuantFloat2._initialBias / this._networkSize;
              this._bias[i] = 0;
            }
          };
          NeuQuantFloat2.prototype._learn = function() {
            var sampleFactor = this._sampleFactor;
            var pointsNumber = this._pointArray.length;
            if (pointsNumber < NeuQuantFloat2._minpicturebytes)
              sampleFactor = 1;
            var alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
            var delta = pointsToSample / NeuQuantFloat2._nCycles | 0, alpha = NeuQuantFloat2._initAlpha, radius = (this._networkSize >> 3) * NeuQuantFloat2._radiusBias;
            var rad = radius >> NeuQuantFloat2._radiusBiasShift;
            if (rad <= 1)
              rad = 0;
            for (var i = 0; i < rad; i++) {
              this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat2._radBias / (rad * rad));
            }
            var step;
            if (pointsNumber < NeuQuantFloat2._minpicturebytes) {
              step = 1;
            } else if (pointsNumber % NeuQuantFloat2._prime1 != 0) {
              step = NeuQuantFloat2._prime1;
            } else if (pointsNumber % NeuQuantFloat2._prime2 != 0) {
              step = NeuQuantFloat2._prime2;
            } else if (pointsNumber % NeuQuantFloat2._prime3 != 0) {
              step = NeuQuantFloat2._prime3;
            } else {
              step = NeuQuantFloat2._prime4;
            }
            for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
              var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
              this._alterSingle(alpha, neuronIndex, b, g, r, a);
              if (rad != 0)
                this._alterNeighbour(rad, neuronIndex, b, g, r, a);
              pointIndex += step;
              if (pointIndex >= pointsNumber)
                pointIndex -= pointsNumber;
              i++;
              if (delta == 0)
                delta = 1;
              if (i % delta == 0) {
                alpha -= alpha / alphadec;
                radius -= radius / NeuQuantFloat2._radiusDecrease;
                rad = radius >> NeuQuantFloat2._radiusBiasShift;
                if (rad <= 1)
                  rad = 0;
                for (var j = 0; j < rad; j++)
                  this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat2._radBias / (rad * rad));
              }
            }
          };
          NeuQuantFloat2.prototype._buildPalette = function() {
            var palette = new palette_1.Palette();
            this._network.forEach(function(neuron) {
              palette.add(neuron.toPoint());
            });
            palette.sort();
            return palette;
          };
          NeuQuantFloat2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
            var lo = i - rad;
            if (lo < -1)
              lo = -1;
            var hi = i + rad;
            if (hi > this._networkSize)
              hi = this._networkSize;
            var j = i + 1, k = i - 1, m = 1;
            while (j < hi || k > lo) {
              var a = this._radPower[m++] / NeuQuantFloat2._alphaRadBias;
              if (j < hi) {
                var p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
              }
              if (k > lo) {
                var p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
              }
            }
          };
          NeuQuantFloat2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
            alpha /= NeuQuantFloat2._initAlpha;
            var n = this._network[i];
            n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
          };
          NeuQuantFloat2.prototype._contest = function(b, g, r, al) {
            var multiplier = 255 * 4 << networkBiasShift;
            var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
            for (var i = 0; i < this._networkSize; i++) {
              var n = this._network[i], dist = this._distance.calculateNormalized(n, {r, g, b, a: al}) * multiplier;
              if (dist < bestd) {
                bestd = dist;
                bestpos = i;
              }
              var biasdist = dist - (this._bias[i] >> NeuQuantFloat2._initialBiasShift - networkBiasShift);
              if (biasdist < bestbiasd) {
                bestbiasd = biasdist;
                bestbiaspos = i;
              }
              var betafreq = this._freq[i] >> NeuQuantFloat2._betaShift;
              this._freq[i] -= betafreq;
              this._bias[i] += betafreq << NeuQuantFloat2._gammaShift;
            }
            this._freq[bestpos] += NeuQuantFloat2._beta;
            this._bias[bestpos] -= NeuQuantFloat2._betaGamma;
            return bestbiaspos;
          };
          NeuQuantFloat2._prime1 = 499;
          NeuQuantFloat2._prime2 = 491;
          NeuQuantFloat2._prime3 = 487;
          NeuQuantFloat2._prime4 = 503;
          NeuQuantFloat2._minpicturebytes = NeuQuantFloat2._prime4;
          NeuQuantFloat2._nCycles = 100;
          NeuQuantFloat2._initialBiasShift = 16;
          NeuQuantFloat2._initialBias = 1 << NeuQuantFloat2._initialBiasShift;
          NeuQuantFloat2._gammaShift = 10;
          NeuQuantFloat2._betaShift = 10;
          NeuQuantFloat2._beta = NeuQuantFloat2._initialBias >> NeuQuantFloat2._betaShift;
          NeuQuantFloat2._betaGamma = NeuQuantFloat2._initialBias << NeuQuantFloat2._gammaShift - NeuQuantFloat2._betaShift;
          NeuQuantFloat2._radiusBiasShift = 6;
          NeuQuantFloat2._radiusBias = 1 << NeuQuantFloat2._radiusBiasShift;
          NeuQuantFloat2._radiusDecrease = 30;
          NeuQuantFloat2._alphaBiasShift = 10;
          NeuQuantFloat2._initAlpha = 1 << NeuQuantFloat2._alphaBiasShift;
          NeuQuantFloat2._radBiasShift = 8;
          NeuQuantFloat2._radBias = 1 << NeuQuantFloat2._radBiasShift;
          NeuQuantFloat2._alphaRadBiasShift = NeuQuantFloat2._alphaBiasShift + NeuQuantFloat2._radBiasShift;
          NeuQuantFloat2._alphaRadBias = 1 << NeuQuantFloat2._alphaRadBiasShift;
          return NeuQuantFloat2;
        }();
        exports3.NeuQuantFloat = NeuQuantFloat;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve TypeScript port:
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * rgbquant.ts - part of Image Quantization Library
         */
        var palette_1 = __webpack_require__(22);
        var point_1 = __webpack_require__(24);
        var colorHistogram_1 = __webpack_require__(27);
        var arithmetic_1 = __webpack_require__(6);
        var RemovedColor = function() {
          function RemovedColor2(index, color, distance) {
            this.index = index;
            this.color = color;
            this.distance = distance;
          }
          return RemovedColor2;
        }();
        var RGBQuant = function() {
          function RGBQuant2(colorDistanceCalculator, colors, method) {
            if (colors === void 0) {
              colors = 256;
            }
            if (method === void 0) {
              method = 2;
            }
            this._distance = colorDistanceCalculator;
            this._colors = colors;
            this._histogram = new colorHistogram_1.ColorHistogram(method, colors);
            this._initialDistance = 0.01;
            this._distanceIncrement = 5e-3;
          }
          RGBQuant2.prototype.sample = function(image) {
            this._histogram.sample(image);
          };
          RGBQuant2.prototype.quantize = function() {
            var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
            if (idxi32.length === 0) {
              throw new Error("No colors in image");
            }
            var palette = this._buildPalette(idxi32);
            palette.sort();
            return palette;
          };
          RGBQuant2.prototype._buildPalette = function(idxi32) {
            var palette = new palette_1.Palette(), colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
            for (var i = 0; i < idxi32.length; i++) {
              colorArray.push(point_1.Point.createByUint32(idxi32[i]));
              usageArray[i] = 1;
            }
            var len = colorArray.length, memDist = [];
            var palLen = len, thold = this._initialDistance;
            while (palLen > this._colors) {
              memDist.length = 0;
              for (var i = 0; i < len; i++) {
                if (usageArray[i] === 0)
                  continue;
                var pxi = colorArray[i];
                for (var j = i + 1; j < len; j++) {
                  if (usageArray[j] === 0)
                    continue;
                  var pxj = colorArray[j];
                  var dist = this._distance.calculateNormalized(pxi, pxj);
                  if (dist < thold) {
                    memDist.push(new RemovedColor(j, pxj, dist));
                    usageArray[j] = 0;
                    palLen--;
                  }
                }
              }
              thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
            }
            if (palLen < this._colors) {
              arithmetic_1.stableSort(memDist, function(a, b) {
                return b.distance - a.distance;
              });
              var k = 0;
              while (palLen < this._colors && k < memDist.length) {
                var removedColor = memDist[k];
                usageArray[removedColor.index] = 1;
                palLen++;
                k++;
              }
            }
            var colors = colorArray.length;
            for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
              if (usageArray[colorIndex] === 0) {
                if (colorIndex !== colors - 1) {
                  colorArray[colorIndex] = colorArray[colors - 1];
                }
                --colors;
              }
            }
            colorArray.length = colors;
            return palette;
          };
          return RGBQuant2;
        }();
        exports3.RGBQuant = RGBQuant;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve TypeScript port:
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * colorHistogram.ts - part of Image Quantization Library
         */
        var hueStatistics_1 = __webpack_require__(28);
        var arithmetic_1 = __webpack_require__(6);
        var ColorHistogram = function() {
          function ColorHistogram2(method, colors) {
            this._method = method;
            this._minHueCols = colors << 2;
            this._initColors = colors << 2;
            this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram2._hueGroups, this._minHueCols);
            this._histogram = Object.create(null);
          }
          ColorHistogram2.prototype.sample = function(pointBuffer) {
            switch (this._method) {
              case 1:
                this._colorStats1D(pointBuffer);
                break;
              case 2:
                this._colorStats2D(pointBuffer);
                break;
            }
          };
          ColorHistogram2.prototype.getImportanceSortedColorsIDXI32 = function() {
            var _this = this;
            var sorted = arithmetic_1.stableSort(Object.keys(this._histogram), function(a, b) {
              return _this._histogram[b] - _this._histogram[a];
            });
            if (sorted.length === 0) {
              return [];
            }
            var idxi32;
            switch (this._method) {
              case 1:
                var initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
                idxi32 = sorted.slice(0, initialColorsLimit);
                var pos = initialColorsLimit, len = sorted.length;
                while (pos < len && this._histogram[sorted[pos]] == freq)
                  idxi32.push(sorted[pos++]);
                this._hueStats.injectIntoArray(idxi32);
                break;
              case 2:
                idxi32 = sorted;
                break;
              default:
                throw new Error("Incorrect method");
            }
            return idxi32.map(function(v) {
              return +v;
            });
          };
          ColorHistogram2.prototype._colorStats1D = function(pointBuffer) {
            var histG = this._histogram, pointArray = pointBuffer.getPointArray(), len = pointArray.length;
            for (var i = 0; i < len; i++) {
              var col = pointArray[i].uint32;
              this._hueStats.check(col);
              if (col in histG)
                histG[col]++;
              else
                histG[col] = 1;
            }
          };
          ColorHistogram2.prototype._colorStats2D = function(pointBuffer) {
            var _this = this;
            var width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), pointArray = pointBuffer.getPointArray();
            var boxW = ColorHistogram2._boxSize[0], boxH = ColorHistogram2._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
            boxes.forEach(function(box) {
              var effc = Math.round(box.w * box.h / area) * ColorHistogram2._boxPixels;
              if (effc < 2)
                effc = 2;
              var histL = {};
              _this._iterateBox(box, width, function(i) {
                var col = pointArray[i].uint32;
                _this._hueStats.check(col);
                if (col in histG)
                  histG[col]++;
                else if (col in histL) {
                  if (++histL[col] >= effc)
                    histG[col] = histL[col];
                } else
                  histL[col] = 1;
              });
            });
            this._hueStats.injectIntoDictionary(histG);
          };
          ColorHistogram2.prototype._iterateBox = function(bbox, wid, fn) {
            var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
            var cnt = 0, i = i0;
            do {
              fn.call(this, i);
              i += ++cnt % b.w == 0 ? incr : 1;
            } while (i <= i1);
          };
          ColorHistogram2.prototype._makeBoxes = function(width, height, stepX, stepY) {
            var wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
            for (var y = 0; y < height; y += stepY)
              for (var x = 0; x < width; x += stepX)
                boxesArray.push({x, y, w: x == xend ? wrem : stepX, h: y == yend ? hrem : stepY});
            return boxesArray;
          };
          ColorHistogram2._boxSize = [64, 64];
          ColorHistogram2._boxPixels = 2;
          ColorHistogram2._hueGroups = 10;
          return ColorHistogram2;
        }();
        exports3.ColorHistogram = ColorHistogram;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * hueStatistics.ts - part of Image Quantization Library
         */
        var rgb2hsl_1 = __webpack_require__(5);
        var palette_1 = __webpack_require__(22);
        var HueGroup = function() {
          function HueGroup2() {
            this.num = 0;
            this.cols = [];
          }
          return HueGroup2;
        }();
        var HueStatistics = function() {
          function HueStatistics2(numGroups, minCols) {
            this._numGroups = numGroups;
            this._minCols = minCols;
            this._stats = [];
            for (var i = 0; i <= numGroups; i++) {
              this._stats[i] = new HueGroup();
            }
            this._groupsFull = 0;
          }
          HueStatistics2.prototype.check = function(i32) {
            if (this._groupsFull == this._numGroups + 1) {
              this.check = function() {
              };
            }
            var r = i32 & 255, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
            gr.num++;
            if (gr.num > min)
              return;
            if (gr.num == min)
              this._groupsFull++;
            if (gr.num <= min)
              this._stats[hg].cols.push(i32);
          };
          HueStatistics2.prototype.injectIntoDictionary = function(histG) {
            for (var i = 0; i <= this._numGroups; i++) {
              if (this._stats[i].num <= this._minCols) {
                this._stats[i].cols.forEach(function(col) {
                  if (!histG[col])
                    histG[col] = 1;
                  else
                    histG[col]++;
                });
              }
            }
          };
          HueStatistics2.prototype.injectIntoArray = function(histG) {
            for (var i = 0; i <= this._numGroups; i++) {
              if (this._stats[i].num <= this._minCols) {
                this._stats[i].cols.forEach(function(col) {
                  if (histG.indexOf(col) == -1)
                    histG.push(col);
                });
              }
            }
          };
          return HueStatistics2;
        }();
        exports3.HueStatistics = HueStatistics;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * wuQuant.ts - part of Image Quantization Library
         */
        var palette_1 = __webpack_require__(22);
        var point_1 = __webpack_require__(24);
        function createArray1D(dimension1) {
          var a = [];
          for (var k = 0; k < dimension1; k++) {
            a[k] = 0;
          }
          return a;
        }
        function createArray4D(dimension1, dimension2, dimension3, dimension4) {
          var a = new Array(dimension1);
          for (var i = 0; i < dimension1; i++) {
            a[i] = new Array(dimension2);
            for (var j = 0; j < dimension2; j++) {
              a[i][j] = new Array(dimension3);
              for (var k = 0; k < dimension3; k++) {
                a[i][j][k] = new Array(dimension4);
                for (var l = 0; l < dimension4; l++) {
                  a[i][j][k][l] = 0;
                }
              }
            }
          }
          return a;
        }
        function createArray3D(dimension1, dimension2, dimension3) {
          var a = new Array(dimension1);
          for (var i = 0; i < dimension1; i++) {
            a[i] = new Array(dimension2);
            for (var j = 0; j < dimension2; j++) {
              a[i][j] = new Array(dimension3);
              for (var k = 0; k < dimension3; k++) {
                a[i][j][k] = 0;
              }
            }
          }
          return a;
        }
        function fillArray3D(a, dimension1, dimension2, dimension3, value) {
          for (var i = 0; i < dimension1; i++) {
            a[i] = [];
            for (var j = 0; j < dimension2; j++) {
              a[i][j] = [];
              for (var k = 0; k < dimension3; k++) {
                a[i][j][k] = value;
              }
            }
          }
        }
        function fillArray1D(a, dimension1, value) {
          for (var i = 0; i < dimension1; i++) {
            a[i] = value;
          }
        }
        var WuColorCube = function() {
          function WuColorCube2() {
          }
          return WuColorCube2;
        }();
        exports3.WuColorCube = WuColorCube;
        var WuQuant = function() {
          function WuQuant2(colorDistanceCalculator, colors, significantBitsPerChannel) {
            if (colors === void 0) {
              colors = 256;
            }
            if (significantBitsPerChannel === void 0) {
              significantBitsPerChannel = 5;
            }
            this._distance = colorDistanceCalculator;
            this._setQuality(significantBitsPerChannel);
            this._initialize(colors);
          }
          WuQuant2.prototype.sample = function(image) {
            var pointArray = image.getPointArray();
            for (var i = 0, l = pointArray.length; i < l; i++) {
              this._addColor(pointArray[i]);
            }
            this._pixels = this._pixels.concat(pointArray);
          };
          WuQuant2.prototype.quantize = function() {
            this._preparePalette();
            var palette = new palette_1.Palette();
            for (var paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
              if (this._sums[paletteIndex] > 0) {
                var sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum;
                var color = point_1.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
                palette.add(color);
              }
            }
            palette.sort();
            return palette;
          };
          WuQuant2.prototype._preparePalette = function() {
            this._calculateMoments();
            var next = 0, volumeVariance = createArray1D(this._colors);
            for (var cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
              if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
                volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
                volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
              } else {
                volumeVariance[next] = 0;
                cubeIndex--;
              }
              next = 0;
              var temp = volumeVariance[0];
              for (var index = 1; index <= cubeIndex; ++index) {
                if (volumeVariance[index] > temp) {
                  temp = volumeVariance[index];
                  next = index;
                }
              }
              if (temp <= 0) {
                this._colors = cubeIndex + 1;
                break;
              }
            }
            var lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
            for (var k = 0; k < this._colors; ++k) {
              var weight = WuQuant2._volume(this._cubes[k], this._weights);
              if (weight > 0) {
                lookupRed[k] = WuQuant2._volume(this._cubes[k], this._momentsRed) / weight | 0;
                lookupGreen[k] = WuQuant2._volume(this._cubes[k], this._momentsGreen) / weight | 0;
                lookupBlue[k] = WuQuant2._volume(this._cubes[k], this._momentsBlue) / weight | 0;
                lookupAlpha[k] = WuQuant2._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
              } else {
                lookupRed[k] = 0;
                lookupGreen[k] = 0;
                lookupBlue[k] = 0;
                lookupAlpha[k] = 0;
              }
            }
            this._reds = createArray1D(this._colors + 1);
            this._greens = createArray1D(this._colors + 1);
            this._blues = createArray1D(this._colors + 1);
            this._alphas = createArray1D(this._colors + 1);
            this._sums = createArray1D(this._colors + 1);
            for (var index = 0, l = this._pixels.length; index < l; index++) {
              var color = this._pixels[index];
              var match = -1;
              var bestMatch = match, bestDistance = Number.MAX_VALUE;
              for (var lookup = 0; lookup < this._colors; lookup++) {
                var foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup];
                var distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                if (distance < bestDistance) {
                  bestDistance = distance;
                  bestMatch = lookup;
                }
              }
              this._reds[bestMatch] += color.r;
              this._greens[bestMatch] += color.g;
              this._blues[bestMatch] += color.b;
              this._alphas[bestMatch] += color.a;
              this._sums[bestMatch]++;
            }
          };
          WuQuant2.prototype._addColor = function(color) {
            var bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = (color.r >> bitsToRemove) + 1, indexGreen = (color.g >> bitsToRemove) + 1, indexBlue = (color.b >> bitsToRemove) + 1, indexAlpha = (color.a >> bitsToRemove) + 1;
            this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
            this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
            this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
            this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
            this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
            this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
          };
          WuQuant2.prototype._calculateMoments = function() {
            var area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [];
            var xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
            for (var alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
              fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
              fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
              fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
              fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
              fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
              fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
              for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {
                fillArray1D(area, this._sideSize, 0);
                fillArray1D(areaRed, this._sideSize, 0);
                fillArray1D(areaGreen, this._sideSize, 0);
                fillArray1D(areaBlue, this._sideSize, 0);
                fillArray1D(areaAlpha, this._sideSize, 0);
                fillArray1D(area2, this._sideSize, 0);
                for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                  var line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                  for (var blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                    line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                    lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                    lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                    lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                    lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                    line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                    area[blueIndex] += line;
                    areaRed[blueIndex] += lineRed;
                    areaGreen[blueIndex] += lineGreen;
                    areaBlue[blueIndex] += lineBlue;
                    areaAlpha[blueIndex] += lineAlpha;
                    area2[blueIndex] += line2;
                    xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                    xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                    xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                    xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                    xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                    xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                    this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                    this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                    this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                    this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                    this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                    this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                  }
                }
              }
            }
          };
          WuQuant2._volumeFloat = function(cube, moment) {
            return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          };
          WuQuant2._volume = function(cube, moment) {
            return WuQuant2._volumeFloat(cube, moment) | 0;
          };
          WuQuant2._top = function(cube, direction, position, moment) {
            var result;
            switch (direction) {
              case WuQuant2.alpha:
                result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                break;
              case WuQuant2.red:
                result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                break;
              case WuQuant2.green:
                result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                break;
              case WuQuant2.blue:
                result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                break;
              default:
                throw new Error("impossible");
            }
            return result | 0;
          };
          WuQuant2._bottom = function(cube, direction, moment) {
            switch (direction) {
              case WuQuant2.alpha:
                return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
              case WuQuant2.red:
                return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
              case WuQuant2.green:
                return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
              case WuQuant2.blue:
                return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
              default:
                return 0;
            }
          };
          WuQuant2.prototype._calculateVariance = function(cube) {
            var volumeRed = WuQuant2._volume(cube, this._momentsRed), volumeGreen = WuQuant2._volume(cube, this._momentsGreen), volumeBlue = WuQuant2._volume(cube, this._momentsBlue), volumeAlpha = WuQuant2._volume(cube, this._momentsAlpha), volumeMoment = WuQuant2._volumeFloat(cube, this._moments), volumeWeight = WuQuant2._volume(cube, this._weights), distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
            return volumeMoment - distance / volumeWeight;
          };
          WuQuant2.prototype._maximize = function(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
            var bottomRed = WuQuant2._bottom(cube, direction, this._momentsRed) | 0, bottomGreen = WuQuant2._bottom(cube, direction, this._momentsGreen) | 0, bottomBlue = WuQuant2._bottom(cube, direction, this._momentsBlue) | 0, bottomAlpha = WuQuant2._bottom(cube, direction, this._momentsAlpha) | 0, bottomWeight = WuQuant2._bottom(cube, direction, this._weights) | 0;
            var result = 0, cutPosition = -1;
            for (var position = first; position < last; ++position) {
              var halfRed = bottomRed + WuQuant2._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + WuQuant2._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + WuQuant2._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + WuQuant2._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + WuQuant2._top(cube, direction, position, this._weights);
              if (halfWeight != 0) {
                var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                halfRed = wholeRed - halfRed;
                halfGreen = wholeGreen - halfGreen;
                halfBlue = wholeBlue - halfBlue;
                halfAlpha = wholeAlpha - halfAlpha;
                halfWeight = wholeWeight - halfWeight;
                if (halfWeight != 0) {
                  halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                  temp += halfDistance / halfWeight;
                  if (temp > result) {
                    result = temp;
                    cutPosition = position;
                  }
                }
              }
            }
            return {max: result, position: cutPosition};
          };
          WuQuant2.prototype._cut = function(first, second) {
            var direction;
            var wholeRed = WuQuant2._volume(first, this._momentsRed), wholeGreen = WuQuant2._volume(first, this._momentsGreen), wholeBlue = WuQuant2._volume(first, this._momentsBlue), wholeAlpha = WuQuant2._volume(first, this._momentsAlpha), wholeWeight = WuQuant2._volume(first, this._weights), red = this._maximize(first, WuQuant2.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, WuQuant2.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, WuQuant2.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, WuQuant2.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
            if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
              direction = WuQuant2.alpha;
              if (alpha.position < 0)
                return false;
            } else {
              if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
                direction = WuQuant2.red;
              } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
                direction = WuQuant2.green;
              } else {
                direction = WuQuant2.blue;
              }
            }
            second.redMaximum = first.redMaximum;
            second.greenMaximum = first.greenMaximum;
            second.blueMaximum = first.blueMaximum;
            second.alphaMaximum = first.alphaMaximum;
            switch (direction) {
              case WuQuant2.red:
                second.redMinimum = first.redMaximum = red.position;
                second.greenMinimum = first.greenMinimum;
                second.blueMinimum = first.blueMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
              case WuQuant2.green:
                second.greenMinimum = first.greenMaximum = green.position;
                second.redMinimum = first.redMinimum;
                second.blueMinimum = first.blueMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
              case WuQuant2.blue:
                second.blueMinimum = first.blueMaximum = blue.position;
                second.redMinimum = first.redMinimum;
                second.greenMinimum = first.greenMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
              case WuQuant2.alpha:
                second.alphaMinimum = first.alphaMaximum = alpha.position;
                second.blueMinimum = first.blueMinimum;
                second.redMinimum = first.redMinimum;
                second.greenMinimum = first.greenMinimum;
                break;
            }
            first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
            second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
            return true;
          };
          WuQuant2.prototype._initialize = function(colors) {
            this._colors = colors;
            this._cubes = [];
            for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
              this._cubes[cubeIndex] = new WuColorCube();
            }
            this._cubes[0].redMinimum = 0;
            this._cubes[0].greenMinimum = 0;
            this._cubes[0].blueMinimum = 0;
            this._cubes[0].alphaMinimum = 0;
            this._cubes[0].redMaximum = this._maxSideIndex;
            this._cubes[0].greenMaximum = this._maxSideIndex;
            this._cubes[0].blueMaximum = this._maxSideIndex;
            this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
            this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
            this._table = [];
            for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {
              this._table[tableIndex] = tableIndex * tableIndex;
            }
            this._pixels = [];
          };
          WuQuant2.prototype._setQuality = function(significantBitsPerChannel) {
            if (significantBitsPerChannel === void 0) {
              significantBitsPerChannel = 5;
            }
            this._significantBitsPerChannel = significantBitsPerChannel;
            this._maxSideIndex = 1 << this._significantBitsPerChannel;
            this._alphaMaxSideIndex = this._maxSideIndex;
            this._sideSize = this._maxSideIndex + 1;
            this._alphaSideSize = this._alphaMaxSideIndex + 1;
          };
          WuQuant2.alpha = 3;
          WuQuant2.red = 2;
          WuQuant2.green = 1;
          WuQuant2.blue = 0;
          return WuQuant2;
        }();
        exports3.WuQuant = WuQuant;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var nearestColor_1 = __webpack_require__(31);
        exports3.NearestColor = nearestColor_1.NearestColor;
        var array_1 = __webpack_require__(32);
        exports3.ErrorDiffusionArray = array_1.ErrorDiffusionArray;
        exports3.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;
        var riemersma_1 = __webpack_require__(33);
        exports3.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;
      },
      function(module3, exports3) {
        "use strict";
        var NearestColor = function() {
          function NearestColor2(colorDistanceCalculator) {
            this._distance = colorDistanceCalculator;
          }
          NearestColor2.prototype.quantize = function(pointBuffer, palette) {
            var pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight();
            for (var y = 0; y < height; y++) {
              for (var x = 0, idx = y * width; x < width; x++, idx++) {
                var point = pointArray[idx];
                point.from(palette.getNearestColor(this._distance, point));
              }
            }
            return pointBuffer;
          };
          return NearestColor2;
        }();
        exports3.NearestColor = NearestColor;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var point_1 = __webpack_require__(24);
        var arithmetic_1 = __webpack_require__(6);
        (function(ErrorDiffusionArrayKernel2) {
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
          ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
        })(exports3.ErrorDiffusionArrayKernel || (exports3.ErrorDiffusionArrayKernel = {}));
        var ErrorDiffusionArrayKernel = exports3.ErrorDiffusionArrayKernel;
        var ErrorDiffusionArray = function() {
          function ErrorDiffusionArray2(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {
            if (serpentine === void 0) {
              serpentine = true;
            }
            if (minimumColorDistanceToDither === void 0) {
              minimumColorDistanceToDither = 0;
            }
            if (calculateErrorLikeGIMP === void 0) {
              calculateErrorLikeGIMP = false;
            }
            this._setKernel(kernel);
            this._distance = colorDistanceCalculator;
            this._minColorDistance = minimumColorDistanceToDither;
            this._serpentine = serpentine;
            this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
          }
          ErrorDiffusionArray2.prototype.quantize = function(pointBuffer, palette) {
            var pointArray = pointBuffer.getPointArray(), originalPoint = new point_1.Point(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorLines = [];
            var dir = 1, maxErrorLines = 1;
            for (var i = 0; i < this._kernel.length; i++) {
              var kernelErrorLines = this._kernel[i][2] + 1;
              if (maxErrorLines < kernelErrorLines)
                maxErrorLines = kernelErrorLines;
            }
            for (var i = 0; i < maxErrorLines; i++) {
              this._fillErrorLine(errorLines[i] = [], width);
            }
            for (var y = 0; y < height; y++) {
              if (this._serpentine)
                dir = dir * -1;
              var lni = y * width, xStart = dir == 1 ? 0 : width - 1, xEnd = dir == 1 ? width : -1;
              this._fillErrorLine(errorLines[0], width);
              errorLines.push(errorLines.shift());
              var errorLine = errorLines[0];
              for (var x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {
                var point = pointArray[idx], error = errorLine[x];
                originalPoint.from(point);
                var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error[0]), arithmetic_1.inRange0to255Rounded(point.g + error[1]), arithmetic_1.inRange0to255Rounded(point.b + error[2]), arithmetic_1.inRange0to255Rounded(point.a + error[3]));
                var palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                point.from(palettePoint);
                if (this._minColorDistance) {
                  var dist = this._distance.calculateNormalized(point, palettePoint);
                  if (dist < this._minColorDistance)
                    continue;
                }
                var er = void 0, eg = void 0, eb = void 0, ea = void 0;
                if (this._calculateErrorLikeGIMP) {
                  er = correctedPoint.r - palettePoint.r;
                  eg = correctedPoint.g - palettePoint.g;
                  eb = correctedPoint.b - palettePoint.b;
                  ea = correctedPoint.a - palettePoint.a;
                } else {
                  er = originalPoint.r - palettePoint.r;
                  eg = originalPoint.g - palettePoint.g;
                  eb = originalPoint.b - palettePoint.b;
                  ea = originalPoint.a - palettePoint.a;
                }
                var dStart = dir == 1 ? 0 : this._kernel.length - 1, dEnd = dir == 1 ? this._kernel.length : -1;
                for (var i = dStart; i !== dEnd; i += dir) {
                  var x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                  if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                    var d = this._kernel[i][0], e = errorLines[y1][x1 + x];
                    e[0] = e[0] + er * d;
                    e[1] = e[1] + eg * d;
                    e[2] = e[2] + eb * d;
                    e[3] = e[3] + ea * d;
                  }
                }
              }
            }
            return pointBuffer;
          };
          ErrorDiffusionArray2.prototype._fillErrorLine = function(errorLine, width) {
            if (errorLine.length > width) {
              errorLine.length = width;
            }
            var l = errorLine.length;
            for (var i = 0; i < l; i++) {
              var error = errorLine[i];
              error[0] = error[1] = error[2] = error[3] = 0;
            }
            for (var i = l; i < width; i++) {
              errorLine[i] = [0, 0, 0, 0];
            }
          };
          ErrorDiffusionArray2.prototype._setKernel = function(kernel) {
            switch (kernel) {
              case ErrorDiffusionArrayKernel.FloydSteinberg:
                this._kernel = [
                  [7 / 16, 1, 0],
                  [3 / 16, -1, 1],
                  [5 / 16, 0, 1],
                  [1 / 16, 1, 1]
                ];
                break;
              case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                this._kernel = [
                  [3 / 8, 1, 0],
                  [3 / 8, 0, 1],
                  [2 / 8, 1, 1]
                ];
                break;
              case ErrorDiffusionArrayKernel.Stucki:
                this._kernel = [
                  [8 / 42, 1, 0],
                  [4 / 42, 2, 0],
                  [2 / 42, -2, 1],
                  [4 / 42, -1, 1],
                  [8 / 42, 0, 1],
                  [4 / 42, 1, 1],
                  [2 / 42, 2, 1],
                  [1 / 42, -2, 2],
                  [2 / 42, -1, 2],
                  [4 / 42, 0, 2],
                  [2 / 42, 1, 2],
                  [1 / 42, 2, 2]
                ];
                break;
              case ErrorDiffusionArrayKernel.Atkinson:
                this._kernel = [
                  [1 / 8, 1, 0],
                  [1 / 8, 2, 0],
                  [1 / 8, -1, 1],
                  [1 / 8, 0, 1],
                  [1 / 8, 1, 1],
                  [1 / 8, 0, 2]
                ];
                break;
              case ErrorDiffusionArrayKernel.Jarvis:
                this._kernel = [
                  [7 / 48, 1, 0],
                  [5 / 48, 2, 0],
                  [3 / 48, -2, 1],
                  [5 / 48, -1, 1],
                  [7 / 48, 0, 1],
                  [5 / 48, 1, 1],
                  [3 / 48, 2, 1],
                  [1 / 48, -2, 2],
                  [3 / 48, -1, 2],
                  [5 / 48, 0, 2],
                  [3 / 48, 1, 2],
                  [1 / 48, 2, 2]
                ];
                break;
              case ErrorDiffusionArrayKernel.Burkes:
                this._kernel = [
                  [8 / 32, 1, 0],
                  [4 / 32, 2, 0],
                  [2 / 32, -2, 1],
                  [4 / 32, -1, 1],
                  [8 / 32, 0, 1],
                  [4 / 32, 1, 1],
                  [2 / 32, 2, 1]
                ];
                break;
              case ErrorDiffusionArrayKernel.Sierra:
                this._kernel = [
                  [5 / 32, 1, 0],
                  [3 / 32, 2, 0],
                  [2 / 32, -2, 1],
                  [4 / 32, -1, 1],
                  [5 / 32, 0, 1],
                  [4 / 32, 1, 1],
                  [2 / 32, 2, 1],
                  [2 / 32, -1, 2],
                  [3 / 32, 0, 2],
                  [2 / 32, 1, 2]
                ];
                break;
              case ErrorDiffusionArrayKernel.TwoSierra:
                this._kernel = [
                  [4 / 16, 1, 0],
                  [3 / 16, 2, 0],
                  [1 / 16, -2, 1],
                  [2 / 16, -1, 1],
                  [3 / 16, 0, 1],
                  [2 / 16, 1, 1],
                  [1 / 16, 2, 1]
                ];
                break;
              case ErrorDiffusionArrayKernel.SierraLite:
                this._kernel = [
                  [2 / 4, 1, 0],
                  [1 / 4, -1, 1],
                  [1 / 4, 0, 1]
                ];
                break;
              default:
                throw new Error("ErrorDiffusionArray: unknown kernel = " + kernel);
            }
          };
          return ErrorDiffusionArray2;
        }();
        exports3.ErrorDiffusionArray = ErrorDiffusionArray;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var hilbertCurve_1 = __webpack_require__(34);
        var point_1 = __webpack_require__(24);
        var arithmetic_1 = __webpack_require__(6);
        var ErrorDiffusionRiemersma = function() {
          function ErrorDiffusionRiemersma2(colorDistanceCalculator, errorQueueSize, errorPropagation) {
            if (errorQueueSize === void 0) {
              errorQueueSize = 16;
            }
            if (errorPropagation === void 0) {
              errorPropagation = 1;
            }
            this._distance = colorDistanceCalculator;
            this._errorPropagation = errorPropagation;
            this._errorQueueSize = errorQueueSize;
            this._max = this._errorQueueSize;
            this._createWeights();
          }
          ErrorDiffusionRiemersma2.prototype.quantize = function(pointBuffer, palette) {
            var _this = this;
            var curve = new hilbertCurve_1.HilbertCurveBase(), pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorQueue = [];
            var head = 0;
            for (var i = 0; i < this._errorQueueSize; i++) {
              errorQueue[i] = {r: 0, g: 0, b: 0, a: 0};
            }
            curve.walk(width, height, function(x, y) {
              var p = pointArray[x + y * width];
              var r = p.r, g = p.g, b = p.b, a = p.a;
              for (var i2 = 0; i2 < _this._errorQueueSize; i2++) {
                var weight = _this._weights[i2], e = errorQueue[(i2 + head) % _this._errorQueueSize];
                r += e.r * weight;
                g += e.g * weight;
                b += e.b * weight;
                a += e.a * weight;
              }
              var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a));
              var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);
              head = (head + 1) % _this._errorQueueSize;
              var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;
              errorQueue[tail].r = p.r - quantizedPoint.r;
              errorQueue[tail].g = p.g - quantizedPoint.g;
              errorQueue[tail].b = p.b - quantizedPoint.b;
              errorQueue[tail].a = p.a - quantizedPoint.a;
              p.from(quantizedPoint);
            });
            return pointBuffer;
          };
          ErrorDiffusionRiemersma2.prototype._createWeights = function() {
            this._weights = [];
            var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));
            for (var i = 0, next = 1; i < this._errorQueueSize; i++) {
              this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation;
              next *= multiplier;
            }
          };
          return ErrorDiffusionRiemersma2;
        }();
        exports3.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;
      },
      function(module3, exports3) {
        "use strict";
        var Direction;
        (function(Direction2) {
          Direction2[Direction2["NONE"] = 0] = "NONE";
          Direction2[Direction2["UP"] = 1] = "UP";
          Direction2[Direction2["LEFT"] = 2] = "LEFT";
          Direction2[Direction2["RIGHT"] = 3] = "RIGHT";
          Direction2[Direction2["DOWN"] = 4] = "DOWN";
        })(Direction || (Direction = {}));
        var HilbertCurveBase = function() {
          function HilbertCurveBase2() {
          }
          HilbertCurveBase2.prototype.walk = function(width, height, visitorCallback) {
            this._x = 0;
            this._y = 0;
            this._d = 0;
            this._width = width;
            this._height = height;
            this._callback = visitorCallback;
            var maxBound = Math.max(width, height);
            this._level = Math.log(maxBound) / Math.log(2) + 1 | 0;
            this._walkHilbert(Direction.UP);
            this._visit(Direction.NONE);
          };
          HilbertCurveBase2.prototype._walkHilbert = function(direction) {
            if (this._level < 1)
              return;
            this._level--;
            switch (direction) {
              case Direction.LEFT:
                this._walkHilbert(Direction.UP);
                this._visit(Direction.RIGHT);
                this._walkHilbert(Direction.LEFT);
                this._visit(Direction.DOWN);
                this._walkHilbert(Direction.LEFT);
                this._visit(Direction.LEFT);
                this._walkHilbert(Direction.DOWN);
                break;
              case Direction.RIGHT:
                this._walkHilbert(Direction.DOWN);
                this._visit(Direction.LEFT);
                this._walkHilbert(Direction.RIGHT);
                this._visit(Direction.UP);
                this._walkHilbert(Direction.RIGHT);
                this._visit(Direction.RIGHT);
                this._walkHilbert(Direction.UP);
                break;
              case Direction.UP:
                this._walkHilbert(Direction.LEFT);
                this._visit(Direction.DOWN);
                this._walkHilbert(Direction.UP);
                this._visit(Direction.RIGHT);
                this._walkHilbert(Direction.UP);
                this._visit(Direction.UP);
                this._walkHilbert(Direction.RIGHT);
                break;
              case Direction.DOWN:
                this._walkHilbert(Direction.RIGHT);
                this._visit(Direction.UP);
                this._walkHilbert(Direction.DOWN);
                this._visit(Direction.LEFT);
                this._walkHilbert(Direction.DOWN);
                this._visit(Direction.DOWN);
                this._walkHilbert(Direction.LEFT);
                break;
              default:
                break;
            }
            this._level++;
          };
          HilbertCurveBase2.prototype._visit = function(direction) {
            if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {
              this._callback(this._x, this._y, this._d);
              this._d++;
            }
            switch (direction) {
              case Direction.LEFT:
                this._x--;
                break;
              case Direction.RIGHT:
                this._x++;
                break;
              case Direction.UP:
                this._y--;
                break;
              case Direction.DOWN:
                this._y++;
                break;
            }
          };
          return HilbertCurveBase2;
        }();
        exports3.HilbertCurveBase = HilbertCurveBase;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * iq.ts - Image Quantization Library
         */
        var ssim_1 = __webpack_require__(36);
        exports3.SSIM = ssim_1.SSIM;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        var bt709_1 = __webpack_require__(2);
        var K1 = 0.01, K2 = 0.03;
        var SSIM = function() {
          function SSIM2() {
          }
          SSIM2.prototype.compare = function(image1, image2) {
            if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
              throw new Error("Images have different sizes!");
            }
            var bitsPerComponent = 8, L = (1 << bitsPerComponent) - 1, c1 = Math.pow(K1 * L, 2), c2 = Math.pow(K2 * L, 2);
            var numWindows = 0, mssim = 0;
            this._iterate(image1, image2, function(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
              var sigxy = 0, sigsqx = 0, sigsqy = 0;
              for (var i = 0; i < lumaValues1.length; i++) {
                sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2);
                sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2);
                sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
              }
              var numPixelsInWin = lumaValues1.length - 1;
              sigsqx /= numPixelsInWin;
              sigsqy /= numPixelsInWin;
              sigxy /= numPixelsInWin;
              var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2), denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2), ssim = numerator / denominator;
              mssim += ssim;
              numWindows++;
            });
            return mssim / numWindows;
          };
          SSIM2.prototype._iterate = function(image1, image2, callback) {
            var windowSize = 8, width = image1.getWidth(), height = image1.getHeight();
            for (var y = 0; y < height; y += windowSize) {
              for (var x = 0; x < width; x += windowSize) {
                var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                var lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight), lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight), averageLuma1 = this._calculateAverageLuma(lumaValues1), averageLuma2 = this._calculateAverageLuma(lumaValues2);
                callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
              }
            }
          };
          SSIM2.prototype._calculateLumaValuesForWindow = function(image, x, y, width, height) {
            var pointArray = image.getPointArray(), lumaValues = [];
            var counter = 0;
            for (var j = y; j < y + height; j++) {
              var offset = j * image.getWidth();
              for (var i = x; i < x + width; i++) {
                var point = pointArray[offset + i];
                lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE;
                counter++;
              }
            }
            return lumaValues;
          };
          SSIM2.prototype._calculateAverageLuma = function(lumaValues) {
            var sumLuma = 0;
            for (var i = 0; i < lumaValues.length; i++) {
              sumLuma += lumaValues[i];
            }
            return sumLuma / lumaValues.length;
          };
          return SSIM2;
        }();
        exports3.SSIM = SSIM;
      },
      function(module3, exports3, __webpack_require__) {
        "use strict";
        /**
         * @preserve
         * Copyright 2015-2016 Igor Bezkrovnyi
         * All rights reserved. (MIT Licensed)
         *
         * iq.ts - Image Quantization Library
         */
        var arithmetic = __webpack_require__(6);
        exports3.arithmetic = arithmetic;
        var hueStatistics_1 = __webpack_require__(28);
        exports3.HueStatistics = hueStatistics_1.HueStatistics;
        var palette_1 = __webpack_require__(22);
        exports3.Palette = palette_1.Palette;
        var point_1 = __webpack_require__(24);
        exports3.Point = point_1.Point;
        var pointContainer_1 = __webpack_require__(23);
        exports3.PointContainer = pointContainer_1.PointContainer;
      }
    ]);
  });
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS((exports2) => {
  "use strict";
  var BitmapImage = require_bitmapimage();
  var {GifError: GifError2} = require_gif();
  var GifFrame = class extends BitmapImage {
    constructor(...args) {
      super(...args);
      if (args[0] instanceof GifFrame) {
        const source = args[0];
        this.xOffset = source.xOffset;
        this.yOffset = source.yOffset;
        this.disposalMethod = source.disposalMethod;
        this.delayCentisecs = source.delayCentisecs;
        this.interlaced = source.interlaced;
      } else {
        const lastArg = args[args.length - 1];
        let options = {};
        if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
          options = lastArg;
        }
        this.xOffset = options.xOffset || 0;
        this.yOffset = options.yOffset || 0;
        this.disposalMethod = options.disposalMethod !== void 0 ? options.disposalMethod : GifFrame.DisposeToBackgroundColor;
        this.delayCentisecs = options.delayCentisecs || 8;
        this.interlaced = options.interlaced || false;
      }
    }
    getPalette() {
      const colorSet = new Set();
      const buf = this.bitmap.data;
      let i = 0;
      let usesTransparency = false;
      while (i < buf.length) {
        if (buf[i + 3] === 0) {
          usesTransparency = true;
        } else {
          const color = buf.readUInt32BE(i, true) >> 8 & 16777215;
          colorSet.add(color);
        }
        i += 4;
      }
      const colors = new Array(colorSet.size);
      const iter = colorSet.values();
      for (i = 0; i < colors.length; ++i) {
        colors[i] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      let indexCount = colors.length;
      if (usesTransparency) {
        ++indexCount;
      }
      return {colors, usesTransparency, indexCount};
    }
  };
  GifFrame.DisposeToAnything = 0;
  GifFrame.DisposeNothing = 1;
  GifFrame.DisposeToBackgroundColor = 2;
  GifFrame.DisposeToPrevious = 3;
  exports2.GifFrame = GifFrame;
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS((exports2) => {
  "use strict";
  var fs = require("fs");
  var ImageQ = require_iq();
  var BitmapImage = require_bitmapimage();
  var {GifFrame} = require_gifframe();
  var {GifError: GifError2} = require_gif();
  var {GifCodec} = require_gifcodec();
  var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
  var defaultCodec = new GifCodec();
  exports2.cloneFrames = function(frames) {
    let clones = [];
    frames.forEach((frame) => {
      clones.push(new GifFrame(frame));
    });
    return clones;
  };
  exports2.getColorInfo = function(frames, maxGlobalIndex) {
    let usesTransparency = false;
    const palettes = [];
    for (let i = 0; i < frames.length; ++i) {
      let palette = frames[i].getPalette();
      if (palette.usesTransparency) {
        usesTransparency = true;
      }
      if (palette.indexCount > 256) {
        throw new GifError2(`Frame ${i} uses more than 256 color indexes`);
      }
      palettes.push(palette);
    }
    if (maxGlobalIndex === 0) {
      return {usesTransparency, palettes};
    }
    const globalColorSet = new Set();
    palettes.forEach((palette) => {
      palette.colors.forEach((color) => {
        globalColorSet.add(color);
      });
    });
    let indexCount = globalColorSet.size;
    if (usesTransparency) {
      ++indexCount;
    }
    if (maxGlobalIndex && indexCount > maxGlobalIndex) {
      return {usesTransparency, palettes};
    }
    const colors = new Array(globalColorSet.size);
    const iter = globalColorSet.values();
    for (let i = 0; i < colors.length; ++i) {
      colors[i] = iter.next().value;
    }
    colors.sort((a, b) => a - b);
    return {colors, indexCount, usesTransparency, palettes};
  };
  exports2.copyAsJimp = function(jimp, bitmapImageToCopy) {
    return exports2.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
  };
  exports2.getMaxDimensions = function(frames) {
    let maxWidth = 0, maxHeight = 0;
    frames.forEach((frame) => {
      const width = frame.xOffset + frame.bitmap.width;
      if (width > maxWidth) {
        maxWidth = width;
      }
      const height = frame.yOffset + frame.bitmap.height;
      if (height > maxHeight) {
        maxHeight = height;
      }
    });
    return {maxWidth, maxHeight};
  };
  exports2.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
  };
  exports2.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    histogram = histogram || "min-pop";
    let histogramID;
    switch (histogram) {
      case "min-pop":
        histogramID = 2;
        break;
      case "top-pop":
        histogramID = 1;
        break;
      default:
        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
    }
    _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
  };
  exports2.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    significantBits = significantBits || 5;
    if (significantBits < 1 || significantBits > 8) {
      throw new Error("Invalid quantization quality");
    }
    _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
  };
  exports2.read = function(source, decoder) {
    decoder = decoder || defaultCodec;
    if (Buffer.isBuffer(source)) {
      return decoder.decodeGif(source);
    }
    return _readBinary(source).then((buffer) => {
      return decoder.decodeGif(buffer);
    });
  };
  exports2.shareAsJimp = function(jimp, bitmapImageToShare) {
    const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
    return jimpImage;
  };
  exports2.write = function(path, frames, spec, encoder) {
    encoder = encoder || defaultCodec;
    const matches = path.match(/\.[a-zA-Z]+$/);
    if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
      throw new Error(`GIF '${path}' has an unexpected suffix`);
    }
    return encoder.encodeGif(frames, spec).then((gif) => {
      return _writeBinary(path, gif.buffer).then(() => {
        return gif;
      });
    });
  };
  function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
    const ditherAlgs = [
      "FloydSteinberg",
      "FalseFloydSteinberg",
      "Stucki",
      "Atkinson",
      "Jarvis",
      "Burkes",
      "Sierra",
      "TwoSierra",
      "SierraLite"
    ];
    if (dither) {
      if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
        throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
      }
      if (dither.serpentine === void 0) {
        dither.serpentine = true;
      }
      if (dither.minimumColorDistanceToDither === void 0) {
        dither.minimumColorDistanceToDither = 0;
      }
      if (dither.calculateErrorLikeGIMP === void 0) {
        dither.calculateErrorLikeGIMP = false;
      }
    }
    const distCalculator = new ImageQ.distance.Euclidean();
    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
    let imageMaker;
    if (dither) {
      imageMaker = new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP);
    } else {
      imageMaker = new ImageQ.image.NearestColor(distCalculator);
    }
    const inputContainers = [];
    images.forEach((image) => {
      const imageBuf = image.bitmap.data;
      const inputBuf = new ArrayBuffer(imageBuf.length);
      const inputArray = new Uint32Array(inputBuf);
      for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
        inputArray[ai] = imageBuf.readUInt32LE(bi, true);
      }
      const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image.bitmap.width, image.bitmap.height);
      quantizer.sample(inputContainer);
      inputContainers.push(inputContainer);
    });
    const limitedPalette = quantizer.quantize();
    for (let i = 0; i < images.length; ++i) {
      const imageBuf = images[i].bitmap.data;
      const outputContainer = imageMaker.quantize(inputContainers[i], limitedPalette);
      const outputArray = outputContainer.toUint32Array();
      for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
        imageBuf.writeUInt32LE(outputArray[ai], bi);
      }
    }
  }
  function _readBinary(path) {
    return new Promise((resolve, reject) => {
      fs.readFile(path, (err, buffer) => {
        if (err) {
          return reject(err);
        }
        return resolve(buffer);
      });
    });
  }
  function _writeBinary(path, buffer) {
    return new Promise((resolve, reject) => {
      fs.writeFile(path, buffer, (err) => {
        if (err) {
          return reject(err);
        }
        return resolve();
      });
    });
  }
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS((exports2) => {
  "use strict";
  var Omggif = require_omggif();
  var {Gif, GifError: GifError2} = require_gif();
  var GifUtil;
  process.nextTick(() => {
    GifUtil = require_gifutil();
  });
  var {GifFrame} = require_gifframe();
  var PER_GIF_OVERHEAD = 200;
  var PER_FRAME_OVERHEAD = 100;
  var GifCodec = class {
    constructor(options = {}) {
      this._transparentRGB = null;
      if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
        this._transparentRGBA = options.transparentRGB * 256;
      }
      this._testInitialBufferSize = 0;
    }
    decodeGif(buffer) {
      try {
        let reader;
        try {
          reader = new Omggif.GifReader(buffer);
        } catch (err) {
          throw new GifError2(err);
        }
        const frameCount = reader.numFrames();
        const frames = [];
        const spec = {
          width: reader.width,
          height: reader.height,
          loops: reader.loopCount()
        };
        spec.usesTransparency = false;
        for (let i = 0; i < frameCount; ++i) {
          const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
          frames.push(frameInfo.frame);
          if (frameInfo.usesTransparency) {
            spec.usesTransparency = true;
          }
        }
        return Promise.resolve(new Gif(buffer, frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    encodeGif(frames, spec = {}) {
      try {
        if (frames === null || frames.length === 0) {
          throw new GifError2("there are no frames");
        }
        const dims = GifUtil.getMaxDimensions(frames);
        spec = Object.assign({}, spec);
        spec.width = dims.maxWidth;
        spec.height = dims.maxHeight;
        spec.loops = spec.loops || 0;
        spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
        return Promise.resolve(this._encodeGif(frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
      let info, buffer;
      try {
        info = reader.frameInfo(frameIndex);
        buffer = new Buffer(reader.width * reader.height * 4);
        reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
        if (info.width !== reader.width || info.height !== reader.height) {
          if (info.y) {
            buffer = buffer.slice(info.y * reader.width * 4);
          }
          if (reader.width > info.width) {
            for (let ii = 0; ii < info.height; ++ii) {
              buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);
            }
          }
          buffer = buffer.slice(0, info.width * info.height * 4);
        }
      } catch (err) {
        throw new GifError2(err);
      }
      let usesTransparency = false;
      if (this._transparentRGBA === null) {
        if (!alreadyUsedTransparency) {
          for (let i = 3; i < buffer.length; i += 4) {
            if (buffer[i] === 0) {
              usesTransparency = true;
              i = buffer.length;
            }
          }
        }
      } else {
        for (let i = 3; i < buffer.length; i += 4) {
          if (buffer[i] === 0) {
            buffer.writeUInt32BE(this._transparentRGBA, i - 3);
            usesTransparency = true;
          }
        }
      }
      const frame = new GifFrame(info.width, info.height, buffer, {
        xOffset: info.x,
        yOffset: info.y,
        disposalMethod: info.disposal,
        interlaced: info.interlaced,
        delayCentisecs: info.delay
      });
      return {frame, usesTransparency};
    }
    _encodeGif(frames, spec) {
      let colorInfo;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        colorInfo = GifUtil.getColorInfo(frames, 0);
      } else {
        colorInfo = GifUtil.getColorInfo(frames, 256);
        if (!colorInfo.colors) {
          if (spec.colorScope === Gif.GlobalColorsOnly) {
            throw new GifError2("Too many color indexes for global color table");
          }
          spec.colorScope = Gif.LocalColorsOnly;
        }
      }
      spec.usesTransparency = colorInfo.usesTransparency;
      const localPalettes = colorInfo.palettes;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        const localSizeEst = 2e3;
        return _encodeLocal(frames, spec, localSizeEst, localPalettes);
      }
      const globalSizeEst = 2e3;
      return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
      const pixelBitWidth = _getPixelBitWidth(globalPalette);
      frames.forEach((frame) => {
        sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
      });
      return sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD;
      for (let i = 0; i < frames.length; ++i) {
        const palette = palettes[i];
        const pixelBitWidth = _getPixelBitWidth(palette);
        sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
      }
      return sizeEst;
    }
  };
  exports2.GifCodec = GifCodec;
  function _colorLookupLinear(colors, color) {
    const index = colors.indexOf(color);
    return index === -1 ? null : index;
  }
  function _colorLookupBinary(colors, color) {
    var lo = 0, hi = colors.length - 1, mid;
    while (lo <= hi) {
      mid = Math.floor((lo + hi) / 2);
      if (colors[mid] > color)
        hi = mid - 1;
      else if (colors[mid] < color)
        lo = mid + 1;
      else
        return mid;
    }
    return null;
  }
  function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
    const extendedGlobalPalette = {
      colors: globalPalette.colors.slice(),
      usesTransparency: globalPalette.usesTransparency
    };
    _extendPaletteToPowerOf2(extendedGlobalPalette);
    const options = {
      palette: extendedGlobalPalette.colors,
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i = 0; i < frames.length; ++i) {
      buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
    const options = {
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i = 0; i < frames.length; ++i) {
      buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _extendPaletteToPowerOf2(palette) {
    const colors = palette.colors;
    if (palette.usesTransparency) {
      colors.push(0);
    }
    const colorCount = colors.length;
    let powerOf2 = 2;
    while (colorCount > powerOf2) {
      powerOf2 <<= 1;
    }
    colors.length = powerOf2;
    colors.fill(0, colorCount);
  }
  function _getFrameSizeEst(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
    byteLength += Math.ceil(byteLength / 255);
    return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
  }
  function _getIndexedImage(frameIndex, frame, palette) {
    const colors = palette.colors;
    const colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary;
    const colorBuffer = frame.bitmap.data;
    const indexBuffer = new Buffer(colorBuffer.length / 4);
    let transparentIndex = colors.length;
    let i = 0, j = 0;
    while (i < colorBuffer.length) {
      if (colorBuffer[i + 3] !== 0) {
        const color = colorBuffer.readUInt32BE(i, true) >> 8 & 16777215;
        indexBuffer[j] = colorToIndexFunc(colors, color);
      } else {
        indexBuffer[j] = transparentIndex;
      }
      i += 4;
      ++j;
    }
    if (palette.usesTransparency) {
      if (transparentIndex === 256) {
        throw new GifError2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
      }
    } else {
      transparentIndex = null;
    }
    return {buffer: indexBuffer, transparentIndex};
  }
  function _getPixelBitWidth(palette) {
    let indexCount = palette.indexCount;
    let pixelBitWidth = 0;
    --indexCount;
    while (indexCount) {
      ++pixelBitWidth;
      indexCount >>= 1;
    }
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
  }
  function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
    if (frame.interlaced) {
      throw new GifError2("writing interlaced GIFs is not supported");
    }
    const frameInfo = _getIndexedImage(frameIndex, frame, palette);
    const options = {
      delay: frame.delayCentisecs,
      disposal: frame.disposalMethod,
      transparent: frameInfo.transparentIndex
    };
    if (isLocalPalette) {
      _extendPaletteToPowerOf2(palette);
      options.palette = palette.colors;
    }
    try {
      let buffer = gifWriter.getOutputBuffer();
      let startOfFrame = gifWriter.getOutputBufferPosition();
      let endOfFrame;
      let tryAgain = true;
      while (tryAgain) {
        endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
        tryAgain = false;
        if (endOfFrame >= buffer.length - 1) {
          const biggerBuffer = new Buffer(buffer.length * 1.5);
          buffer.copy(biggerBuffer);
          gifWriter.setOutputBuffer(biggerBuffer);
          gifWriter.setOutputBufferPosition(startOfFrame);
          buffer = biggerBuffer;
          tryAgain = true;
        }
      }
      return buffer;
    } catch (err) {
      throw new GifError2(err);
    }
  }
});

// node_modules/gifwrap/src/index.js
var require_src = __commonJS((exports2, module2) => {
  "use strict";
  var BitmapImage = require_bitmapimage();
  var {Gif, GifError: GifError2} = require_gif();
  var {GifCodec} = require_gifcodec();
  var {GifFrame} = require_gifframe();
  var GifUtil = require_gifutil();
  module2.exports = {
    BitmapImage,
    Gif,
    GifCodec,
    GifFrame,
    GifUtil,
    GifError: GifError2
  };
});

// node_modules/@jimp/gif/dist/index.js
var require_dist8 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _omggif = _interopRequireDefault(require_omggif());
  var _gifwrap = require_src();
  var MIME_TYPE = "image/gif";
  var _default = function _default2() {
    return {
      mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["gif"]),
      constants: {
        MIME_GIF: MIME_TYPE
      },
      decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
        var gifObj = new _omggif["default"].GifReader(data);
        var gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
        gifObj.decodeAndBlitFrameRGBA(0, gifData);
        return {
          data: gifData,
          width: gifObj.width,
          height: gifObj.height
        };
      }),
      encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
        var bitmap = new _gifwrap.BitmapImage(data.bitmap);
        _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
        var newFrame = new _gifwrap.GifFrame(bitmap);
        var gifCodec = new _gifwrap.GifCodec();
        return gifCodec.encodeGif([newFrame], {}).then(function(newGif) {
          return newGif.buffer;
        });
      })
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/types/dist/index.js
var require_dist9 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _timm = require_timm();
  var _jpeg = _interopRequireDefault(require_dist4());
  var _png = _interopRequireDefault(require_dist5());
  var _bmp = _interopRequireDefault(require_dist6());
  var _tiff = _interopRequireDefault(require_dist7());
  var _gif = _interopRequireDefault(require_dist8());
  var _default = function _default2() {
    return (0, _timm.mergeDeep)((0, _jpeg["default"])(), (0, _png["default"])(), (0, _bmp["default"])(), (0, _tiff["default"])(), (0, _gif["default"])());
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-blit/dist/index.js
var require_dist10 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      blit: function blit(src, x, y, srcx, srcy, srcw, srch, cb) {
        if (!(src instanceof this.constructor)) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        if (typeof srcx === "function") {
          cb = srcx;
          srcx = 0;
          srcy = 0;
          srcw = src.bitmap.width;
          srch = src.bitmap.height;
        } else if ((0, _typeof2["default"])(srcx) === (0, _typeof2["default"])(srcy) && (0, _typeof2["default"])(srcy) === (0, _typeof2["default"])(srcw) && (0, _typeof2["default"])(srcw) === (0, _typeof2["default"])(srch)) {
          srcx = srcx || 0;
          srcy = srcy || 0;
          srcw = srcw || src.bitmap.width;
          srch = srch || src.bitmap.height;
        } else {
          return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        srcx = Math.round(srcx);
        srcy = Math.round(srcy);
        srcw = Math.round(srcw);
        srch = Math.round(srch);
        var maxWidth = this.bitmap.width;
        var maxHeight = this.bitmap.height;
        var baseImage = this;
        src.scanQuiet(srcx, srcy, srcw, srch, function(sx, sy, idx) {
          var xOffset = x + sx - srcx;
          var yOffset = y + sy - srcy;
          if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
            var dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
            var _src = {
              r: this.bitmap.data[idx],
              g: this.bitmap.data[idx + 1],
              b: this.bitmap.data[idx + 2],
              a: this.bitmap.data[idx + 3]
            };
            var dst = {
              r: baseImage.bitmap.data[dstIdx],
              g: baseImage.bitmap.data[dstIdx + 1],
              b: baseImage.bitmap.data[dstIdx + 2],
              a: baseImage.bitmap.data[dstIdx + 3]
            };
            baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r;
            baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g;
            baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b;
            baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-blur/dist/blur-tables.js
var require_blur_tables = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.shgTable = exports2.mulTable = void 0;
  var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
  exports2.mulTable = mulTable;
  var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
  exports2.shgTable = shgTable;
});

// node_modules/@jimp/plugin-blur/dist/index.js
var require_dist11 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _blurTables = require_blur_tables();
  var _default = function _default2() {
    return {
      blur: function blur(r, cb) {
        if (typeof r !== "number")
          return _utils.throwError.call(this, "r must be a number", cb);
        if (r < 1)
          return _utils.throwError.call(this, "r must be greater than 0", cb);
        var rsum;
        var gsum;
        var bsum;
        var asum;
        var x;
        var y;
        var i;
        var p;
        var p1;
        var p2;
        var yp;
        var yi;
        var yw;
        var pa;
        var wm = this.bitmap.width - 1;
        var hm = this.bitmap.height - 1;
        var rad1 = r + 1;
        var mulSum = _blurTables.mulTable[r];
        var shgSum = _blurTables.shgTable[r];
        var red = [];
        var green = [];
        var blue = [];
        var alpha = [];
        var vmin = [];
        var vmax = [];
        var iterations = 2;
        while (iterations-- > 0) {
          yi = 0;
          yw = 0;
          for (y = 0; y < this.bitmap.height; y++) {
            rsum = this.bitmap.data[yw] * rad1;
            gsum = this.bitmap.data[yw + 1] * rad1;
            bsum = this.bitmap.data[yw + 2] * rad1;
            asum = this.bitmap.data[yw + 3] * rad1;
            for (i = 1; i <= r; i++) {
              p = yw + ((i > wm ? wm : i) << 2);
              rsum += this.bitmap.data[p++];
              gsum += this.bitmap.data[p++];
              bsum += this.bitmap.data[p++];
              asum += this.bitmap.data[p];
            }
            for (x = 0; x < this.bitmap.width; x++) {
              red[yi] = rsum;
              green[yi] = gsum;
              blue[yi] = bsum;
              alpha[yi] = asum;
              if (y === 0) {
                vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
              }
              p1 = yw + vmin[x];
              p2 = yw + vmax[x];
              rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              asum += this.bitmap.data[p1] - this.bitmap.data[p2];
              yi++;
            }
            yw += this.bitmap.width << 2;
          }
          for (x = 0; x < this.bitmap.width; x++) {
            yp = x;
            rsum = red[yp] * rad1;
            gsum = green[yp] * rad1;
            bsum = blue[yp] * rad1;
            asum = alpha[yp] * rad1;
            for (i = 1; i <= r; i++) {
              yp += i > hm ? 0 : this.bitmap.width;
              rsum += red[yp];
              gsum += green[yp];
              bsum += blue[yp];
              asum += alpha[yp];
            }
            yi = x << 2;
            for (y = 0; y < this.bitmap.height; y++) {
              pa = asum * mulSum >>> shgSum;
              this.bitmap.data[yi + 3] = pa;
              if (pa > 255) {
                this.bitmap.data[yi + 3] = 255;
              }
              if (pa > 0) {
                pa = 255 / pa;
                this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
                this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
                this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
              } else {
                this.bitmap.data[yi + 2] = 0;
                this.bitmap.data[yi + 1] = 0;
                this.bitmap.data[yi] = 0;
              }
              if (x === 0) {
                vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
                vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
              }
              p1 = x + vmin[y];
              p2 = x + vmax[y];
              rsum += red[p1] - red[p2];
              gsum += green[p1] - green[p2];
              bsum += blue[p1] - blue[p2];
              asum += alpha[p1] - alpha[p2];
              yi += this.bitmap.width << 2;
            }
          }
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-circle/dist/index.js
var require_dist12 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      circle: function circle() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        var radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;
        var center = {
          x: typeof options.x === "number" ? options.x : this.bitmap.width / 2,
          y: typeof options.y === "number" ? options.y : this.bitmap.height / 2
        };
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
          if (radius - curR <= 0) {
            this.bitmap.data[idx + 3] = 0;
          } else if (radius - curR < 1) {
            this.bitmap.data[idx + 3] = 255 * (radius - curR);
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-color/dist/index.js
var require_dist13 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
  var _tinycolor = _interopRequireDefault(require_tinycolor());
  var _utils = require_dist();
  function applyKernel(im, kernel, x, y) {
    var value = [0, 0, 0];
    var size = (kernel.length - 1) / 2;
    for (var kx = 0; kx < kernel.length; kx += 1) {
      for (var ky = 0; ky < kernel[kx].length; ky += 1) {
        var idx = im.getPixelIndex(x + kx - size, y + ky - size);
        value[0] += im.bitmap.data[idx] * kernel[kx][ky];
        value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
        value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
      }
    }
    return value;
  }
  var isDef = function isDef2(v) {
    return typeof v !== "undefined" && v !== null;
  };
  function greyscale(cb) {
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
      this.bitmap.data[idx] = grey;
      this.bitmap.data[idx + 1] = grey;
      this.bitmap.data[idx + 2] = grey;
    });
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  function mix(clr, clr2) {
    var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
    return {
      r: (clr2.r - clr.r) * (p / 100) + clr.r,
      g: (clr2.g - clr.g) * (p / 100) + clr.g,
      b: (clr2.b - clr.b) * (p / 100) + clr.b
    };
  }
  function colorFn(actions, cb) {
    var _this = this;
    if (!actions || !Array.isArray(actions)) {
      return _utils.throwError.call(this, "actions must be an array", cb);
    }
    actions = actions.map(function(action) {
      if (action.apply === "xor" || action.apply === "mix") {
        action.params[0] = (0, _tinycolor["default"])(action.params[0]).toRgb();
      }
      return action;
    });
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      var clr = {
        r: _this.bitmap.data[idx],
        g: _this.bitmap.data[idx + 1],
        b: _this.bitmap.data[idx + 2]
      };
      var colorModifier = function colorModifier2(i, amount) {
        return _this.constructor.limit255(clr[i] + amount);
      };
      actions.forEach(function(action) {
        if (action.apply === "mix") {
          clr = mix(clr, action.params[0], action.params[1]);
        } else if (action.apply === "tint") {
          clr = mix(clr, {
            r: 255,
            g: 255,
            b: 255
          }, action.params[0]);
        } else if (action.apply === "shade") {
          clr = mix(clr, {
            r: 0,
            g: 0,
            b: 0
          }, action.params[0]);
        } else if (action.apply === "xor") {
          clr = {
            r: clr.r ^ action.params[0].r,
            g: clr.g ^ action.params[0].g,
            b: clr.b ^ action.params[0].b
          };
        } else if (action.apply === "red") {
          clr.r = colorModifier("r", action.params[0]);
        } else if (action.apply === "green") {
          clr.g = colorModifier("g", action.params[0]);
        } else if (action.apply === "blue") {
          clr.b = colorModifier("b", action.params[0]);
        } else {
          var _clr;
          if (action.apply === "hue") {
            action.apply = "spin";
          }
          clr = (0, _tinycolor["default"])(clr);
          if (!clr[action.apply]) {
            return _utils.throwError.call(_this, "action " + action.apply + " not supported", cb);
          }
          clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2["default"])(action.params)).toRgb();
        }
      });
      _this.bitmap.data[idx] = clr.r;
      _this.bitmap.data[idx + 1] = clr.g;
      _this.bitmap.data[idx + 2] = clr.b;
    });
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  var _default = function _default2() {
    return {
      brightness: function brightness(val, cb) {
        if (typeof val !== "number") {
          return _utils.throwError.call(this, "val must be numbers", cb);
        }
        if (val < -1 || val > 1) {
          return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          if (val < 0) {
            this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);
            this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);
            this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);
          } else {
            this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;
            this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;
            this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      contrast: function contrast(val, cb) {
        if (typeof val !== "number") {
          return _utils.throwError.call(this, "val must be numbers", cb);
        }
        if (val < -1 || val > 1) {
          return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
        }
        var factor = (val + 1) / (1 - val);
        function adjust(value) {
          value = Math.floor(factor * (value - 127) + 127);
          return value < 0 ? 0 : value > 255 ? 255 : value;
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
          this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
          this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      posterize: function posterize(n, cb) {
        if (typeof n !== "number") {
          return _utils.throwError.call(this, "n must be numbers", cb);
        }
        if (n < 2) {
          n = 2;
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
          this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
          this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      greyscale,
      grayscale: greyscale,
      opacity: function opacity(f, cb) {
        if (typeof f !== "number")
          return _utils.throwError.call(this, "f must be a number", cb);
        if (f < 0 || f > 1)
          return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var v = this.bitmap.data[idx + 3] * f;
          this.bitmap.data[idx + 3] = v;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      sepia: function sepia(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var red = this.bitmap.data[idx];
          var green = this.bitmap.data[idx + 1];
          var blue = this.bitmap.data[idx + 2];
          red = red * 0.393 + green * 0.769 + blue * 0.189;
          green = red * 0.349 + green * 0.686 + blue * 0.168;
          blue = red * 0.272 + green * 0.534 + blue * 0.131;
          this.bitmap.data[idx] = red < 255 ? red : 255;
          this.bitmap.data[idx + 1] = green < 255 ? green : 255;
          this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      fade: function fade(f, cb) {
        if (typeof f !== "number") {
          return _utils.throwError.call(this, "f must be a number", cb);
        }
        if (f < 0 || f > 1) {
          return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
        }
        this.opacity(1 - f);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      convolution: function convolution(kernel, edgeHandling, cb) {
        if (typeof edgeHandling === "function" && typeof cb === "undefined") {
          cb = edgeHandling;
          edgeHandling = null;
        }
        if (!edgeHandling) {
          edgeHandling = this.constructor.EDGE_EXTEND;
        }
        var newData = Buffer.from(this.bitmap.data);
        var kRows = kernel.length;
        var kCols = kernel[0].length;
        var rowEnd = Math.floor(kRows / 2);
        var colEnd = Math.floor(kCols / 2);
        var rowIni = -rowEnd;
        var colIni = -colEnd;
        var weight;
        var rSum;
        var gSum;
        var bSum;
        var ri;
        var gi;
        var bi;
        var xi;
        var yi;
        var idxi;
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          bSum = 0;
          gSum = 0;
          rSum = 0;
          for (var row = rowIni; row <= rowEnd; row++) {
            for (var col = colIni; col <= colEnd; col++) {
              xi = x + col;
              yi = y + row;
              weight = kernel[row + rowEnd][col + colEnd];
              idxi = this.getPixelIndex(xi, yi, edgeHandling);
              if (idxi === -1) {
                bi = 0;
                gi = 0;
                ri = 0;
              } else {
                ri = this.bitmap.data[idxi + 0];
                gi = this.bitmap.data[idxi + 1];
                bi = this.bitmap.data[idxi + 2];
              }
              rSum += weight * ri;
              gSum += weight * gi;
              bSum += weight * bi;
            }
          }
          if (rSum < 0) {
            rSum = 0;
          }
          if (gSum < 0) {
            gSum = 0;
          }
          if (bSum < 0) {
            bSum = 0;
          }
          if (rSum > 255) {
            rSum = 255;
          }
          if (gSum > 255) {
            gSum = 255;
          }
          if (bSum > 255) {
            bSum = 255;
          }
          newData[idx + 0] = rSum;
          newData[idx + 1] = gSum;
          newData[idx + 2] = bSum;
        });
        this.bitmap.data = newData;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      opaque: function opaque(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx + 3] = 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      pixelate: function pixelate(size, x, y, w, h, cb) {
        if (typeof x === "function") {
          cb = x;
          h = null;
          w = null;
          y = null;
          x = null;
        } else {
          if (typeof size !== "number") {
            return _utils.throwError.call(this, "size must be a number", cb);
          }
          if (isDef(x) && typeof x !== "number") {
            return _utils.throwError.call(this, "x must be a number", cb);
          }
          if (isDef(y) && typeof y !== "number") {
            return _utils.throwError.call(this, "y must be a number", cb);
          }
          if (isDef(w) && typeof w !== "number") {
            return _utils.throwError.call(this, "w must be a number", cb);
          }
          if (isDef(h) && typeof h !== "number") {
            return _utils.throwError.call(this, "h must be a number", cb);
          }
        }
        var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
        x = x || 0;
        y = y || 0;
        w = isDef(w) ? w : this.bitmap.width - x;
        h = isDef(h) ? h : this.bitmap.height - y;
        var source = this.cloneQuiet();
        this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
          xx = size * Math.floor(xx / size);
          yx = size * Math.floor(yx / size);
          var value = applyKernel(source, kernel, xx, yx);
          this.bitmap.data[idx] = value[0];
          this.bitmap.data[idx + 1] = value[1];
          this.bitmap.data[idx + 2] = value[2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      convolute: function convolute(kernel, x, y, w, h, cb) {
        if (!Array.isArray(kernel))
          return _utils.throwError.call(this, "the kernel must be an array", cb);
        if (typeof x === "function") {
          cb = x;
          x = null;
          y = null;
          w = null;
          h = null;
        } else {
          if (isDef(x) && typeof x !== "number") {
            return _utils.throwError.call(this, "x must be a number", cb);
          }
          if (isDef(y) && typeof y !== "number") {
            return _utils.throwError.call(this, "y must be a number", cb);
          }
          if (isDef(w) && typeof w !== "number") {
            return _utils.throwError.call(this, "w must be a number", cb);
          }
          if (isDef(h) && typeof h !== "number") {
            return _utils.throwError.call(this, "h must be a number", cb);
          }
        }
        var ksize = (kernel.length - 1) / 2;
        x = isDef(x) ? x : ksize;
        y = isDef(y) ? y : ksize;
        w = isDef(w) ? w : this.bitmap.width - x;
        h = isDef(h) ? h : this.bitmap.height - y;
        var source = this.cloneQuiet();
        this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
          var value = applyKernel(source, kernel, xx, yx);
          this.bitmap.data[idx] = this.constructor.limit255(value[0]);
          this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);
          this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      color: colorFn,
      colour: colorFn
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-contain/dist/index.js
var require_dist14 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      contain: function contain(w, h, alignBits, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (typeof alignBits === "string") {
          if (typeof mode === "function" && typeof cb === "undefined")
            cb = mode;
          mode = alignBits;
          alignBits = null;
        }
        if (typeof alignBits === "function") {
          if (typeof cb === "undefined")
            cb = alignBits;
          mode = null;
          alignBits = null;
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
        var hbits = alignBits & (1 << 3) - 1;
        var vbits = alignBits >> 3;
        if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
          return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
        }
        var alignH = hbits >> 1;
        var alignV = vbits >> 1;
        var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
        var c = this.cloneQuiet().scale(f, mode);
        this.resize(w, h, mode);
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data.writeUInt32BE(this._background, idx);
        });
        this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-cover/dist/index.js
var require_dist15 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      cover: function cover(w, h, alignBits, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (alignBits && typeof alignBits === "function" && typeof cb === "undefined") {
          cb = alignBits;
          alignBits = null;
          mode = null;
        } else if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
        var hbits = alignBits & (1 << 3) - 1;
        var vbits = alignBits >> 3;
        if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1)))
          return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
        var alignH = hbits >> 1;
        var alignV = vbits >> 1;
        var f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
        this.scale(f, mode);
        this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-crop/dist/index.js
var require_dist16 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = pluginCrop;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _utils = require_dist();
  function pluginCrop(event) {
    event("crop", function(x, y, w, h, cb) {
      if (typeof x !== "number" || typeof y !== "number")
        return _utils.throwError.call(this, "x and y must be numbers", cb);
      if (typeof w !== "number" || typeof h !== "number")
        return _utils.throwError.call(this, "w and h must be numbers", cb);
      x = Math.round(x);
      y = Math.round(y);
      w = Math.round(w);
      h = Math.round(h);
      if (x === 0 && w === this.bitmap.width) {
        var start = w * y + x << 2;
        var end = start + h * w << 2;
        this.bitmap.data = this.bitmap.data.slice(start, end);
      } else {
        var bitmap = Buffer.allocUnsafe(w * h * 4);
        var offset = 0;
        this.scanQuiet(x, y, w, h, function(x2, y2, idx) {
          var data = this.bitmap.data.readUInt32BE(idx, true);
          bitmap.writeUInt32BE(data, offset, true);
          offset += 4;
        });
        this.bitmap.data = bitmap;
      }
      this.bitmap.width = w;
      this.bitmap.height = h;
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    });
    return {
      class: {
        autocrop: function autocrop() {
          var w = this.bitmap.width;
          var h = this.bitmap.height;
          var minPixelsPerSide = 1;
          var cb;
          var leaveBorder = 0;
          var tolerance = 2e-4;
          var cropOnlyFrames = true;
          var cropSymmetric = false;
          var ignoreSides = {
            north: false,
            south: false,
            east: false,
            west: false
          };
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          for (var a = 0, len = args.length; a < len; a++) {
            if (typeof args[a] === "number") {
              tolerance = args[a];
            }
            if (typeof args[a] === "boolean") {
              cropOnlyFrames = args[a];
            }
            if (typeof args[a] === "function") {
              cb = args[a];
            }
            if ((0, _typeof2["default"])(args[a]) === "object") {
              var config = args[a];
              if (typeof config.tolerance !== "undefined") {
                tolerance = config.tolerance;
              }
              if (typeof config.cropOnlyFrames !== "undefined") {
                cropOnlyFrames = config.cropOnlyFrames;
              }
              if (typeof config.cropSymmetric !== "undefined") {
                cropSymmetric = config.cropSymmetric;
              }
              if (typeof config.leaveBorder !== "undefined") {
                leaveBorder = config.leaveBorder;
              }
              if (typeof config.ignoreSides !== "undefined") {
                ignoreSides = config.ignoreSides;
              }
            }
          }
          var colorTarget = this.getPixelColor(0, 0);
          var rgba1 = this.constructor.intToRGBA(colorTarget);
          var northPixelsToCrop = 0;
          var eastPixelsToCrop = 0;
          var southPixelsToCrop = 0;
          var westPixelsToCrop = 0;
          colorTarget = this.getPixelColor(0, 0);
          if (!ignoreSides.north) {
            north:
              for (var y = 0; y < h - minPixelsPerSide; y++) {
                for (var x = 0; x < w; x++) {
                  var colorXY = this.getPixelColor(x, y);
                  var rgba2 = this.constructor.intToRGBA(colorXY);
                  if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                    break north;
                  }
                }
                northPixelsToCrop++;
              }
          }
          colorTarget = this.getPixelColor(w, 0);
          if (!ignoreSides.east) {
            east:
              for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
                for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
                  var _colorXY = this.getPixelColor(_x, _y);
                  var _rgba = this.constructor.intToRGBA(_colorXY);
                  if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {
                    break east;
                  }
                }
                eastPixelsToCrop++;
              }
          }
          colorTarget = this.getPixelColor(0, h);
          if (!ignoreSides.south) {
            south:
              for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
                for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
                  var _colorXY2 = this.getPixelColor(_x2, _y2);
                  var _rgba2 = this.constructor.intToRGBA(_colorXY2);
                  if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {
                    break south;
                  }
                }
                southPixelsToCrop++;
              }
          }
          colorTarget = this.getPixelColor(w, h);
          if (!ignoreSides.west) {
            west:
              for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
                for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
                  var _colorXY3 = this.getPixelColor(_x3, _y3);
                  var _rgba3 = this.constructor.intToRGBA(_colorXY3);
                  if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {
                    break west;
                  }
                }
                westPixelsToCrop++;
              }
          }
          var doCrop = false;
          westPixelsToCrop -= leaveBorder;
          eastPixelsToCrop -= leaveBorder;
          northPixelsToCrop -= leaveBorder;
          southPixelsToCrop -= leaveBorder;
          if (cropSymmetric) {
            var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
            var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
            westPixelsToCrop = horizontal;
            eastPixelsToCrop = horizontal;
            northPixelsToCrop = vertical;
            southPixelsToCrop = vertical;
          }
          westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
          eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
          northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
          southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
          var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
          var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
          if (cropOnlyFrames) {
            doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
          } else {
            doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
          }
          if (doCrop) {
            this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    };
  }
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-displace/dist/index.js
var require_dist17 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      displace: function displace(map, offset, cb) {
        if ((0, _typeof2["default"])(map) !== "object" || map.constructor !== this.constructor) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof offset !== "number") {
          return _utils.throwError.call(this, "factor must be a number", cb);
        }
        var source = this.cloneQuiet();
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var displacement = map.bitmap.data[idx] / 256 * offset;
          displacement = Math.round(displacement);
          var ids = this.getPixelIndex(x + displacement, y);
          this.bitmap.data[ids] = source.bitmap.data[idx];
          this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
          this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-dither/dist/index.js
var require_dist18 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  function dither(cb) {
    var rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      var thresholdId = ((y & 3) << 2) + x % 4;
      var dither2 = rgb565Matrix[thresholdId];
      this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither2, 255);
      this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither2, 255);
      this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither2, 255);
    });
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  var _default = function _default2() {
    return {
      dither565: dither,
      dither16: dither
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-fisheye/dist/index.js
var require_dist19 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      fisheye: function fisheye() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          r: 2.5
        };
        var cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {
            r: 2.5
          };
        }
        var source = this.cloneQuiet();
        var _source$bitmap = source.bitmap, width = _source$bitmap.width, height = _source$bitmap.height;
        source.scanQuiet(0, 0, width, height, function(x, y) {
          var hx = x / width;
          var hy = y / height;
          var r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
          var rn = 2 * Math.pow(r, options.r);
          var cosA = (hx - 0.5) / r;
          var sinA = (hy - 0.5) / r;
          var newX = Math.round((rn * cosA + 0.5) * width);
          var newY = Math.round((rn * sinA + 0.5) * height);
          var color = source.getPixelColor(newX, newY);
          _this.setPixelColor(color, x, y);
        });
        this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-flip/dist/index.js
var require_dist20 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  function flipFn(horizontal, vertical, cb) {
    if (typeof horizontal !== "boolean" || typeof vertical !== "boolean")
      return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
    var bitmap = Buffer.alloc(this.bitmap.data.length);
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      var _x = horizontal ? this.bitmap.width - 1 - x : x;
      var _y = vertical ? this.bitmap.height - 1 - y : y;
      var _idx = this.bitmap.width * _y + _x << 2;
      var data = this.bitmap.data.readUInt32BE(idx);
      bitmap.writeUInt32BE(data, _idx);
    });
    this.bitmap.data = Buffer.from(bitmap);
    if ((0, _utils.isNodePattern)(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  var _default = function _default2() {
    return {
      flip: flipFn,
      mirror: flipFn
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-gaussian/dist/index.js
var require_dist21 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      gaussian: function gaussian(r, cb) {
        if (typeof r !== "number") {
          return _utils.throwError.call(this, "r must be a number", cb);
        }
        if (r < 1) {
          return _utils.throwError.call(this, "r must be greater than 0", cb);
        }
        var rs = Math.ceil(r * 2.57);
        var range = rs * 2 + 1;
        var rr2 = r * r * 2;
        var rr2pi = rr2 * Math.PI;
        var weights = [];
        for (var y = 0; y < range; y++) {
          weights[y] = [];
          for (var x = 0; x < range; x++) {
            var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
            weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
          }
        }
        for (var _y = 0; _y < this.bitmap.height; _y++) {
          for (var _x = 0; _x < this.bitmap.width; _x++) {
            var red = 0;
            var green = 0;
            var blue = 0;
            var alpha = 0;
            var wsum = 0;
            for (var iy = 0; iy < range; iy++) {
              for (var ix = 0; ix < range; ix++) {
                var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs));
                var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs));
                var weight = weights[iy][ix];
                var _idx = y1 * this.bitmap.width + x1 << 2;
                red += this.bitmap.data[_idx] * weight;
                green += this.bitmap.data[_idx + 1] * weight;
                blue += this.bitmap.data[_idx + 2] * weight;
                alpha += this.bitmap.data[_idx + 3] * weight;
                wsum += weight;
              }
              var idx = _y * this.bitmap.width + _x << 2;
              this.bitmap.data[idx] = Math.round(red / wsum);
              this.bitmap.data[idx + 1] = Math.round(green / wsum);
              this.bitmap.data[idx + 2] = Math.round(blue / wsum);
              this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
            }
          }
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-invert/dist/index.js
var require_dist22 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      invert: function invert(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
          this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
          this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-mask/dist/index.js
var require_dist23 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      mask: function mask(src) {
        var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var cb = arguments.length > 3 ? arguments[3] : void 0;
        if (!(src instanceof this.constructor)) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        var w = this.bitmap.width;
        var h = this.bitmap.height;
        var baseImage = this;
        src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
          var destX = x + sx;
          var destY = y + sy;
          if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
            var dstIdx = baseImage.getPixelIndex(destX, destY);
            var data = this.bitmap.data;
            var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
            baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-normalize/dist/index.js
var require_dist24 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  function histogram() {
    var histogram2 = {
      r: new Array(256).fill(0),
      g: new Array(256).fill(0),
      b: new Array(256).fill(0)
    };
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index) {
      histogram2.r[this.bitmap.data[index + 0]]++;
      histogram2.g[this.bitmap.data[index + 1]]++;
      histogram2.b[this.bitmap.data[index + 2]]++;
    });
    return histogram2;
  }
  var _normalize = function normalize(value, min, max) {
    return (value - min) * 255 / (max - min);
  };
  var getBounds = function getBounds2(histogramChannel) {
    return [histogramChannel.findIndex(function(value) {
      return value > 0;
    }), 255 - histogramChannel.slice().reverse().findIndex(function(value) {
      return value > 0;
    })];
  };
  var _default = function _default2() {
    return {
      normalize: function normalize(cb) {
        var h = histogram.call(this);
        var bounds = {
          r: getBounds(h.r),
          g: getBounds(h.g),
          b: getBounds(h.b)
        };
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var r = this.bitmap.data[idx + 0];
          var g = this.bitmap.data[idx + 1];
          var b = this.bitmap.data[idx + 2];
          this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);
          this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);
          this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/parse-bmfont-ascii/index.js
var require_parse_bmfont_ascii = __commonJS((exports2, module2) => {
  module2.exports = function parseBMFontAscii(data) {
    if (!data)
      throw new Error("no data provided");
    data = data.toString().trim();
    var output = {
      pages: [],
      chars: [],
      kernings: []
    };
    var lines = data.split(/\r\n?|\n/g);
    if (lines.length === 0)
      throw new Error("no data in BMFont file");
    for (var i = 0; i < lines.length; i++) {
      var lineData = splitLine(lines[i], i);
      if (!lineData)
        continue;
      if (lineData.key === "page") {
        if (typeof lineData.data.id !== "number")
          throw new Error("malformed file at line " + i + " -- needs page id=N");
        if (typeof lineData.data.file !== "string")
          throw new Error("malformed file at line " + i + ' -- needs page file="path"');
        output.pages[lineData.data.id] = lineData.data.file;
      } else if (lineData.key === "chars" || lineData.key === "kernings") {
      } else if (lineData.key === "char") {
        output.chars.push(lineData.data);
      } else if (lineData.key === "kerning") {
        output.kernings.push(lineData.data);
      } else {
        output[lineData.key] = lineData.data;
      }
    }
    return output;
  };
  function splitLine(line, idx) {
    line = line.replace(/\t+/g, " ").trim();
    if (!line)
      return null;
    var space = line.indexOf(" ");
    if (space === -1)
      throw new Error("no named row at line " + idx);
    var key = line.substring(0, space);
    line = line.substring(space + 1);
    line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, "");
    line = line.split("=");
    line = line.map(function(str) {
      return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
    });
    var data = [];
    for (var i = 0; i < line.length; i++) {
      var dt = line[i];
      if (i === 0) {
        data.push({
          key: dt[0],
          data: ""
        });
      } else if (i === line.length - 1) {
        data[data.length - 1].data = parseData(dt[0]);
      } else {
        data[data.length - 1].data = parseData(dt[0]);
        data.push({
          key: dt[1],
          data: ""
        });
      }
    }
    var out = {
      key,
      data: {}
    };
    data.forEach(function(v) {
      out.data[v.key] = v.data;
    });
    return out;
  }
  function parseData(data) {
    if (!data || data.length === 0)
      return "";
    if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
      return data.substring(1, data.length - 1);
    if (data.indexOf(",") !== -1)
      return parseIntList(data);
    return parseInt(data, 10);
  }
  function parseIntList(data) {
    return data.split(",").map(function(val) {
      return parseInt(val, 10);
    });
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS((exports2) => {
  (function() {
    exports2.defaults = {
      "0.1": {
        explicitCharkey: false,
        trim: true,
        normalize: true,
        normalizeTags: false,
        attrkey: "@",
        charkey: "#",
        explicitArray: false,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: false,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        childkey: "@@",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: false,
        trim: false,
        normalize: false,
        normalizeTags: false,
        attrkey: "$",
        charkey: "_",
        explicitArray: true,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: true,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        preserveChildrenOrder: false,
        childkey: "$$",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: true
        },
        doctype: null,
        renderOpts: {
          pretty: true,
          indent: "  ",
          newline: "\n"
        },
        headless: false,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: false
      }
    };
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS((exports2, module2) => {
  (function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
      var i, key, len, source, sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key))
                continue;
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
    isFunction = function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject = function(val) {
      var ref;
      return !!val && ((ref = typeof val) === "function" || ref === "object");
    };
    isArray = function(val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === "[object Array]";
      }
    };
    isEmpty = function(val) {
      var key;
      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key))
            continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject = function(val) {
      var ctor, proto;
      return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    module2.exports.assign = assign;
    module2.exports.isFunction = isFunction;
    module2.exports.isObject = isObject;
    module2.exports.isArray = isArray;
    module2.exports.isEmpty = isEmpty;
    module2.exports.isPlainObject = isPlainObject;
    module2.exports.getValue = getValue;
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMImplementation;
    module2.exports = XMLDOMImplementation = function() {
      function XMLDOMImplementation2() {
      }
      XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
        return true;
      };
      XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLDOMImplementation2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMErrorHandler;
    module2.exports = XMLDOMErrorHandler = function() {
      function XMLDOMErrorHandler2() {
      }
      XMLDOMErrorHandler2.prototype.handleError = function(error) {
        throw new Error(error);
      };
      return XMLDOMErrorHandler2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMStringList;
    module2.exports = XMLDOMStringList = function() {
      function XMLDOMStringList2(arr) {
        this.arr = arr || [];
      }
      Object.defineProperty(XMLDOMStringList2.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      });
      XMLDOMStringList2.prototype.item = function(index) {
        return this.arr[index] || null;
      };
      XMLDOMStringList2.prototype.contains = function(str) {
        return this.arr.indexOf(str) !== -1;
      };
      return XMLDOMStringList2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require_XMLDOMErrorHandler();
    XMLDOMStringList = require_XMLDOMStringList();
    module2.exports = XMLDOMConfiguration = function() {
      function XMLDOMConfiguration2() {
        var clonedSelf;
        this.defaultParams = {
          "canonical-form": false,
          "cdata-sections": false,
          comments: false,
          "datatype-normalization": false,
          "element-content-whitespace": true,
          entities: true,
          "error-handler": new XMLDOMErrorHandler(),
          infoset: true,
          "validate-if-schema": false,
          namespaces: true,
          "namespace-declarations": true,
          "normalize-characters": false,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": true,
          validate: false,
          "well-formed": true
        };
        this.params = clonedSelf = Object.create(this.defaultParams);
      }
      Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
        get: function() {
          return new XMLDOMStringList(Object.keys(this.defaultParams));
        }
      });
      XMLDOMConfiguration2.prototype.getParameter = function(name) {
        if (this.params.hasOwnProperty(name)) {
          return this.params[name];
        } else {
          return null;
        }
      };
      XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
        return true;
      };
      XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
        if (value != null) {
          return this.params[name] = value;
        } else {
          return delete this.params[name];
        }
      };
      return XMLDOMConfiguration2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module2.exports = XMLAttribute = function() {
      function XMLAttribute2(parent, name, value) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.value = this.stringify.attValue(value);
        this.type = NodeType.Attribute;
        this.isId = false;
        this.schemaTypeInfo = null;
      }
      Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "specified", {
        get: function() {
          return true;
        }
      });
      XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function(options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      };
      XMLAttribute2.prototype.debugInfo = function(name) {
        name = name || this.name;
        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      };
      XMLAttribute2.prototype.isEqualNode = function(node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.value !== this.value) {
          return false;
        }
        return true;
      };
      return XMLAttribute2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS((exports2, module2) => {
  (function() {
    var XMLNamedNodeMap;
    module2.exports = XMLNamedNodeMap = function() {
      function XMLNamedNodeMap2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      });
      XMLNamedNodeMap2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
        return this.nodes[name];
      };
      XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
        var oldNode;
        oldNode = this.nodes[name];
        delete this.nodes[name];
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.item = function(index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      };
      XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLNamedNodeMap2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLAttribute = require_XMLAttribute();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module2.exports = XMLElement = function(superClass) {
      extend(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        var child, j, len, ref1;
        XMLElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.type === NodeType.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
          if (parent.children) {
            ref1 = parent.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (child.type === NodeType.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }
      Object.defineProperty(XMLElement2.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "attributes", {
        get: function() {
          if (!this.attributeMap || !this.attributeMap.nodes) {
            this.attributeMap = new XMLNamedNodeMap(this.attribs);
          }
          return this.attributeMap;
        }
      });
      XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attribs = {};
        ref1 = this.attribs;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName))
            continue;
          att = ref1[attName];
          clonedSelf.attribs[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName))
              continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (this.options.keepNullAttributes && value == null) {
            this.attribs[name] = new XMLAttribute(this, name, "");
          } else if (value != null) {
            this.attribs[name] = new XMLAttribute(this, name, value);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function(name) {
        var attName, j, len;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            attName = name[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name];
        }
        return this;
      };
      XMLElement2.prototype.toString = function(options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      };
      XMLElement2.prototype.att = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.a = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.getAttribute = function(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].value;
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttribute = function(name, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNode = function(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name];
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttributeNode = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.hasAttribute = function(name) {
        return this.attribs.hasOwnProperty(name);
      };
      XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttribute = function(name, isId) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].isId;
        } else {
          return isId;
        }
      };
      XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.isEqualNode = function(node) {
        var i, j, ref1;
        if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.attribs.length !== this.attribs.length) {
          return false;
        }
        for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
          if (!this.attribs[i].isEqualNode(node.attribs[i])) {
            return false;
          }
        }
        return true;
      };
      return XMLElement2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS((exports2, module2) => {
  (function() {
    var XMLCharacterData, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    module2.exports = XMLCharacterData = function(superClass) {
      extend(XMLCharacterData2, superClass);
      function XMLCharacterData2(parent) {
        XMLCharacterData2.__super__.constructor.call(this, parent);
        this.value = "";
      }
      Object.defineProperty(XMLCharacterData2.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      });
      XMLCharacterData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCharacterData2.prototype.substringData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.appendData = function(arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.insertData = function(offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.deleteData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.isEqualNode = function(node) {
        if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.data !== this.data) {
          return false;
        }
        return true;
      };
      return XMLCharacterData2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLCData = function(superClass) {
      extend(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }
        this.name = "#cdata-section";
        this.type = NodeType.CData;
        this.value = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function(options) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
      };
      return XMLCData2;
    }(XMLCharacterData);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLComment = function(superClass) {
      extend(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }
        this.name = "#comment";
        this.type = NodeType.Comment;
        this.value = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function(options) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
      };
      return XMLComment2;
    }(XMLCharacterData);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDeclaration = function(superClass) {
      extend(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding, standalone) {
        var ref;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
        }
        if (!version) {
          version = "1.0";
        }
        this.type = NodeType.Declaration;
        this.version = this.stringify.xmlVersion(version);
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function(options) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
      };
      return XMLDeclaration2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDAttList = function(superClass) {
      extend(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }
        if (defaultValueType.indexOf("#") !== 0) {
          defaultValueType = "#" + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        this.elementName = this.stringify.name(elementName);
        this.type = NodeType.AttributeDeclaration;
        this.attributeName = this.stringify.name(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        if (defaultValue) {
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        }
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function(options) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDAttList2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDEntity = function(superClass) {
      extend(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.name(name);
        this.type = NodeType.EntityDeclaration;
        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
          this.internal = true;
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }
          this.internal = false;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }
      Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      });
      XMLDTDEntity2.prototype.toString = function(options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDEntity2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDElement = function(superClass) {
      extend(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (!value) {
          value = "(#PCDATA)";
        }
        if (Array.isArray(value)) {
          value = "(" + value.join(",") + ")";
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.ElementDeclaration;
        this.value = this.stringify.dtdElementValue(value);
      }
      XMLDTDElement2.prototype.toString = function(options) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDElement2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDNotation = function(superClass) {
      extend(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }
        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.NotationDeclaration;
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }
      Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      XMLDTDNotation2.prototype.toString = function(options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDNotation2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module2.exports = XMLDocType = function(superClass) {
      extend(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var child, i, len, ref, ref1, ref2;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.type = NodeType.DocType;
        if (parent.children) {
          ref = parent.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
          }
        }
        this.documentObject = parent;
        if (isObject(pubID)) {
          ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
        }
        if (sysID == null) {
          ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      Object.defineProperty(XMLDocType2.prototype, "entities", {
        get: function() {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.EntityDeclaration && !child.pe) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "notations", {
        get: function() {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.NotationDeclaration) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLDocType2.prototype.element = function(name, value) {
        var child;
        child = new XMLDTDElement(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function(name, value) {
        var child;
        child = new XMLDTDEntity(this, false, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function(name, value) {
        var child;
        child = new XMLDTDEntity(this, true, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function(name, value) {
        var child;
        child = new XMLDTDNotation(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function(options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      };
      XMLDocType2.prototype.ele = function(name, value) {
        return this.element(name, value);
      };
      XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocType2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocType2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      };
      XMLDocType2.prototype.isEqualNode = function(node) {
        if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (node.publicId !== this.publicId) {
          return false;
        }
        if (node.systemId !== this.systemId) {
          return false;
        }
        return true;
      };
      return XMLDocType2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module2.exports = XMLRaw = function(superClass) {
      extend(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }
        this.type = NodeType.Raw;
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function(options) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
      };
      return XMLRaw2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLText = function(superClass) {
      extend(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.name = "#text";
        this.type = NodeType.Text;
        this.value = this.stringify.text(text);
      }
      Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLText2.prototype, "wholeText", {
        get: function() {
          var next, prev, str;
          str = "";
          prev = this.previousSibling;
          while (prev) {
            str = prev.data + str;
            prev = prev.previousSibling;
          }
          str += this.data;
          next = this.nextSibling;
          while (next) {
            str = str + next.data;
            next = next.nextSibling;
          }
          return str;
        }
      });
      XMLText2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function(options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      };
      XMLText2.prototype.splitText = function(offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLText2.prototype.replaceWholeText = function(content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLText2;
    }(XMLCharacterData);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLProcessingInstruction = function(superClass) {
      extend(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }
        this.type = NodeType.ProcessingInstruction;
        this.target = this.stringify.insTarget(target);
        this.name = this.target;
        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function(options) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
      };
      XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
        if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.target !== this.target) {
          return false;
        }
        return true;
      };
      return XMLProcessingInstruction2;
    }(XMLCharacterData);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDummy = function(superClass) {
      extend(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.type = NodeType.Dummy;
      }
      XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function(options) {
        return "";
      };
      return XMLDummy2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS((exports2, module2) => {
  (function() {
    var XMLNodeList;
    module2.exports = XMLNodeList = function() {
      function XMLNodeList2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNodeList2.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      });
      XMLNodeList2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNodeList2.prototype.item = function(index) {
        return this.nodes[index] || null;
      };
      return XMLNodeList2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS((exports2, module2) => {
  (function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module2.exports = XMLNode = function() {
      function XMLNode2(parent1) {
        this.parent = parent1;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.value = null;
        this.children = [];
        this.baseURI = null;
        if (!XMLElement) {
          XMLElement = require_XMLElement();
          XMLCData = require_XMLCData();
          XMLComment = require_XMLComment();
          XMLDeclaration = require_XMLDeclaration();
          XMLDocType = require_XMLDocType();
          XMLRaw = require_XMLRaw();
          XMLText = require_XMLText();
          XMLProcessingInstruction = require_XMLProcessingInstruction();
          XMLDummy = require_XMLDummy();
          NodeType = require_NodeType();
          XMLNodeList = require_XMLNodeList();
          XMLNamedNodeMap = require_XMLNamedNodeMap();
          DocumentPosition = require_DocumentPosition();
        }
      }
      Object.defineProperty(XMLNode2.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "childNodes", {
        get: function() {
          if (!this.childNodeList || !this.childNodeList.nodes) {
            this.childNodeList = new XMLNodeList(this.children);
          }
          return this.childNodeList;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "previousSibling", {
        get: function() {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nextSibling", {
        get: function() {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i + 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "textContent", {
        get: function() {
          var child, j, len, ref2, str;
          if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
            str = "";
            ref2 = this.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (child.textContent) {
                str += child.textContent;
              }
            }
            return str;
          } else {
            return null;
          }
        },
        set: function(value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLNode2.prototype.setParent = function(parent) {
        var child, j, len, ref2, results;
        this.parent = parent;
        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }
        ref2 = this.children;
        results = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          results.push(child.setParent(this));
        }
        return results;
      };
      XMLNode2.prototype.element = function(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
        lastChild = null;
        if (attributes === null && text == null) {
          ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
        }
        if (name != null) {
          name = getValue(name);
        }
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key))
              continue;
            val = name[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
              lastChild = this.dummy();
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            } else if (!this.options.keepNullNodes && val == null) {
              lastChild = this.dummy();
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function(name, attributes, text) {
        var child, i, newChild, refChild, removed;
        if (name != null ? name.type : void 0) {
          newChild = name;
          refChild = attributes;
          newChild.setParent(this);
          if (refChild) {
            i = children.indexOf(refChild);
            removed = children.splice(i);
            children.push(newChild);
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }
          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      };
      XMLNode2.prototype.insertAfter = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function() {
        var i, ref2;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
        return this.parent;
      };
      XMLNode2.prototype.node = function(name, attributes, text) {
        var child, ref2;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
        }
        child = new XMLElement(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function(value) {
        var child;
        if (isObject(value)) {
          this.element(value);
        }
        child = new XMLText(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function(value) {
        var child;
        child = new XMLCData(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function(value) {
        var child;
        child = new XMLComment(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function(value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function(value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function(value) {
        var child;
        child = new XMLRaw(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function() {
        var child;
        child = new XMLDummy(this);
        return child;
      };
      XMLNode2.prototype.instruction = function(target, value) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (j = 0, len = target.length; j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function(target, value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function(target, value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function(version, encoding, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      };
      XMLNode2.prototype.dtd = function(pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        ref2 = doc.children;
        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          child = ref2[i];
          if (child.type === NodeType.DocType) {
            doc.children[i] = doctype;
            return doctype;
          }
        }
        ref3 = doc.children;
        for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
          child = ref3[i];
          if (child.isRoot) {
            doc.children.splice(i, 0, doctype);
            return doctype;
          }
        }
        doc.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.document = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.end = function(options) {
        return this.document().end(options);
      };
      XMLNode2.prototype.prev = function() {
        var i;
        i = this.parent.children.indexOf(this);
        if (i < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i - 1];
      };
      XMLNode2.prototype.next = function() {
        var i;
        i = this.parent.children.indexOf(this);
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i + 1];
      };
      XMLNode2.prototype.importDocument = function(doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function(name) {
        var ref2, ref3;
        name = name || this.name;
        if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      };
      XMLNode2.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.doc = function() {
        return this.document();
      };
      XMLNode2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLNode2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.u = function() {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function(doc) {
        return this.importDocument(doc);
      };
      XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.removeChild = function(oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.appendChild = function(newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      };
      XMLNode2.prototype.cloneNode = function(deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isSupported = function(feature, version) {
        return true;
      };
      XMLNode2.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      };
      XMLNode2.prototype.compareDocumentPosition = function(other) {
        var ref, res;
        ref = this;
        if (ref === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
          if (Math.random() < 0.5) {
            res |= DocumentPosition.Preceding;
          } else {
            res |= DocumentPosition.Following;
          }
          return res;
        } else if (ref.isAncestor(other)) {
          return DocumentPosition.Contains | DocumentPosition.Preceding;
        } else if (ref.isDescendant(other)) {
          return DocumentPosition.Contains | DocumentPosition.Following;
        } else if (ref.isPreceding(other)) {
          return DocumentPosition.Preceding;
        } else {
          return DocumentPosition.Following;
        }
      };
      XMLNode2.prototype.isSameNode = function(other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isEqualNode = function(node) {
        var i, j, ref2;
        if (node.nodeType !== this.nodeType) {
          return false;
        }
        if (node.children.length !== this.children.length) {
          return false;
        }
        for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
          if (!this.children[i].isEqualNode(node.children[i])) {
            return false;
          }
        }
        return true;
      };
      XMLNode2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.setUserData = function(key, data, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.getUserData = function(key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.contains = function(other) {
        if (!other) {
          return false;
        }
        return other === this || this.isDescendant(other);
      };
      XMLNode2.prototype.isDescendant = function(node) {
        var child, isDescendantChild, j, len, ref2;
        ref2 = this.children;
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          if (node === child) {
            return true;
          }
          isDescendantChild = child.isDescendant(node);
          if (isDescendantChild) {
            return true;
          }
        }
        return false;
      };
      XMLNode2.prototype.isAncestor = function(node) {
        return node.isDescendant(this);
      };
      XMLNode2.prototype.isPreceding = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      };
      XMLNode2.prototype.isFollowing = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      };
      XMLNode2.prototype.treePosition = function(node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function(childNode) {
          pos++;
          if (!found && childNode === node) {
            return found = true;
          }
        });
        if (found) {
          return pos;
        } else {
          return -1;
        }
      };
      XMLNode2.prototype.foreachTreeNode = function(node, func) {
        var child, j, len, ref2, res;
        node || (node = this.document());
        ref2 = node.children;
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          if (res = func(child)) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);
            if (res) {
              return res;
            }
          }
        }
      };
      return XMLNode2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS((exports2, module2) => {
  (function() {
    var XMLStringifier, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, hasProp = {}.hasOwnProperty;
    module2.exports = XMLStringifier = function() {
      function XMLStringifier2(options) {
        this.assertLegalName = bind(this.assertLegalName, this);
        this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref, value;
        options || (options = {});
        this.options = options;
        if (!this.options.version) {
          this.options.version = "1.0";
        }
        ref = options.stringify || {};
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value = ref[key];
          this[key] = value;
        }
      }
      XMLStringifier2.prototype.name = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalName("" + val || "");
      };
      XMLStringifier2.prototype.text = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.textEscape("" + val || ""));
      };
      XMLStringifier2.prototype.cdata = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        val = val.replace("]]>", "]]]]><![CDATA[>");
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return "" + val || "";
      };
      XMLStringifier2.prototype.attValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.attEscape(val = "" + val || ""));
      };
      XMLStringifier2.prototype.insTarget = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.insValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlVersion = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlStandalone = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };
      XMLStringifier2.prototype.dtdPubID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdSysID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdElementValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttType = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttDefault = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdEntityValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdNData = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.convertAttKey = "@";
      XMLStringifier2.prototype.convertPIKey = "?";
      XMLStringifier2.prototype.convertTextKey = "#text";
      XMLStringifier2.prototype.convertCDataKey = "#cdata";
      XMLStringifier2.prototype.convertCommentKey = "#comment";
      XMLStringifier2.prototype.convertRawKey = "#raw";
      XMLStringifier2.prototype.assertLegalChar = function(str) {
        var regex, res;
        if (this.options.noValidation) {
          return str;
        }
        regex = "";
        if (this.options.version === "1.0") {
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        } else if (this.options.version === "1.1") {
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        }
        return str;
      };
      XMLStringifier2.prototype.assertLegalName = function(str) {
        var regex;
        if (this.options.noValidation) {
          return str;
        }
        this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
        if (!str.match(regex)) {
          throw new Error("Invalid character in name");
        }
        return str;
      };
      XMLStringifier2.prototype.textEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      };
      XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      };
      return XMLStringifier2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
    assign = require_Utility().assign;
    NodeType = require_NodeType();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLElement = require_XMLElement();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDummy = require_XMLDummy();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDNotation = require_XMLDTDNotation();
    WriterState = require_WriterState();
    module2.exports = XMLWriterBase = function() {
      function XMLWriterBase2(options) {
        var key, ref, value;
        options || (options = {});
        this.options = options;
        ref = options.writer || {};
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value = ref[key];
          this["_" + key] = this[key];
          this[key] = value;
        }
      }
      XMLWriterBase2.prototype.filterOptions = function(options) {
        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
        options || (options = {});
        options = assign({}, this.options, options);
        filteredOptions = {
          writer: this
        };
        filteredOptions.pretty = options.pretty || false;
        filteredOptions.allowEmpty = options.allowEmpty || false;
        filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
        filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
        filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
        if (filteredOptions.spaceBeforeSlash === true) {
          filteredOptions.spaceBeforeSlash = " ";
        }
        filteredOptions.suppressPrettyCount = 0;
        filteredOptions.user = {};
        filteredOptions.state = WriterState.None;
        return filteredOptions;
      };
      XMLWriterBase2.prototype.indent = function(node, options, level) {
        var indentLevel;
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else if (options.pretty) {
          indentLevel = (level || 0) + options.offset + 1;
          if (indentLevel > 0) {
            return new Array(indentLevel).join(options.indent);
          }
        }
        return "";
      };
      XMLWriterBase2.prototype.endline = function(node, options, level) {
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else {
          return options.newline;
        }
      };
      XMLWriterBase2.prototype.attribute = function(att, options, level) {
        var r;
        this.openAttribute(att, options, level);
        r = " " + att.name + '="' + att.value + '"';
        this.closeAttribute(att, options, level);
        return r;
      };
      XMLWriterBase2.prototype.cdata = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<![CDATA[";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += "]]>" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.comment = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!-- ";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += " -->" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.declaration = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?xml";
        options.state = WriterState.InsideTag;
        r += ' version="' + node.version + '"';
        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }
        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.docType = function(node, options, level) {
        var child, i, len, r, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        r += "<!DOCTYPE " + node.root().name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.children.length > 0) {
          r += " [";
          r += this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += "]";
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
        level || (level = 0);
        prettySuppressed = false;
        r = "";
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r += this.indent(node, options, level) + "<" + node.name;
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name))
            continue;
          att = ref[name];
          r += this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            r += ">";
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          r += ">";
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          r += this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          r += "</" + node.name + ">" + this.endline(node, options, level);
        } else {
          if (options.dontPrettyTextNodes) {
            ref1 = node.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                options.suppressPrettyCount++;
                prettySuppressed = true;
                break;
              }
            }
          }
          r += ">" + this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref2 = node.children;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            child = ref2[j];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += this.indent(node, options, level) + "</" + node.name + ">";
          if (prettySuppressed) {
            options.suppressPrettyCount--;
          }
          r += this.endline(node, options, level);
          options.state = WriterState.None;
        }
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
        switch (node.type) {
          case NodeType.CData:
            return this.cdata(node, options, level);
          case NodeType.Comment:
            return this.comment(node, options, level);
          case NodeType.Element:
            return this.element(node, options, level);
          case NodeType.Raw:
            return this.raw(node, options, level);
          case NodeType.Text:
            return this.text(node, options, level);
          case NodeType.ProcessingInstruction:
            return this.processingInstruction(node, options, level);
          case NodeType.Dummy:
            return "";
          case NodeType.Declaration:
            return this.declaration(node, options, level);
          case NodeType.DocType:
            return this.docType(node, options, level);
          case NodeType.AttributeDeclaration:
            return this.dtdAttList(node, options, level);
          case NodeType.ElementDeclaration:
            return this.dtdElement(node, options, level);
          case NodeType.EntityDeclaration:
            return this.dtdEntity(node, options, level);
          case NodeType.NotationDeclaration:
            return this.dtdNotation(node, options, level);
          default:
            throw new Error("Unknown XML node type: " + node.constructor.name);
        }
      };
      XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?";
        options.state = WriterState.InsideTag;
        r += node.target;
        if (node.value) {
          r += " " + node.value;
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.raw = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.text = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ATTLIST";
        options.state = WriterState.InsideTag;
        r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
        if (node.defaultValueType !== "#DEFAULT") {
          r += " " + node.defaultValueType;
        }
        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ELEMENT";
        options.state = WriterState.InsideTag;
        r += " " + node.name + " " + node.value;
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ENTITY";
        options.state = WriterState.InsideTag;
        if (node.pe) {
          r += " %";
        }
        r += " " + node.name;
        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.nData) {
            r += " NDATA " + node.nData;
          }
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!NOTATION";
        options.state = WriterState.InsideTag;
        r += " " + node.name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.openNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.closeNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
      };
      XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
      };
      return XMLWriterBase2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS((exports2, module2) => {
  (function() {
    var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLWriterBase = require_XMLWriterBase();
    module2.exports = XMLStringWriter = function(superClass) {
      extend(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      XMLStringWriter2.prototype.document = function(doc, options) {
        var child, i, len, r, ref;
        options = this.filterOptions(options);
        r = "";
        ref = doc.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, 0);
        }
        if (options.pretty && r.slice(-options.newline.length) === options.newline) {
          r = r.slice(0, -options.newline.length);
        }
        return r;
      };
      return XMLStringWriter2;
    }(XMLWriterBase);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject = require_Utility().isPlainObject;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDOMConfiguration = require_XMLDOMConfiguration();
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    module2.exports = XMLDocument = function(superClass) {
      extend(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = "#document";
        this.type = NodeType.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration();
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter();
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
      }
      Object.defineProperty(XMLDocument2.prototype, "implementation", {
        value: new XMLDOMImplementation()
      });
      Object.defineProperty(XMLDocument2.prototype, "doctype", {
        get: function() {
          var child, i, len, ref;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.DocType) {
              return child;
            }
          }
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
        get: function() {
          return false;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].encoding;
          } else {
            return null;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].standalone === "yes";
          } else {
            return false;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].version;
          } else {
            return "1.0";
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "origin", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "compatMode", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "characterSet", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "contentType", {
        get: function() {
          return null;
        }
      });
      XMLDocument2.prototype.end = function(writer) {
        var writerOptions;
        writerOptions = {};
        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }
        return writer.document(this, writer.filterOptions(writerOptions));
      };
      XMLDocument2.prototype.toString = function(options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      };
      XMLDocument2.prototype.createElement = function(tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTextNode = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createComment = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createCDATASection = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttribute = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEntityReference = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.importNode = function(importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementById = function(elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.adoptNode = function(source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEvent = function(eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLDocument2;
    }(XMLNode);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType = require_NodeType();
    XMLDocument = require_XMLDocument();
    XMLElement = require_XMLElement();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLAttribute = require_XMLAttribute();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    WriterState = require_WriterState();
    module2.exports = XMLDocumentCB = function() {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        this.type = NodeType.Document;
        options || (options = {});
        writerOptions = {};
        if (!options.writer) {
          options.writer = new XMLStringWriter();
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter();
        }
        this.options = options;
        this.writer = options.writer;
        this.writerOptions = this.writer.filterOptions(writerOptions);
        this.stringify = new XMLStringifier(options);
        this.onDataCallback = onData || function() {
        };
        this.onEndCallback = onEnd || function() {
        };
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.createChildNode = function(node) {
        var att, attName, attributes, child, i, len, ref1, ref2;
        switch (node.type) {
          case NodeType.CData:
            this.cdata(node.value);
            break;
          case NodeType.Comment:
            this.comment(node.value);
            break;
          case NodeType.Element:
            attributes = {};
            ref1 = node.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName))
                continue;
              att = ref1[attName];
              attributes[attName] = att.value;
            }
            this.node(node.name, attributes);
            break;
          case NodeType.Dummy:
            this.dummy();
            break;
          case NodeType.Raw:
            this.raw(node.value);
            break;
          case NodeType.Text:
            this.text(node.value);
            break;
          case NodeType.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
        }
        ref2 = node.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          this.createChildNode(child);
          if (child.type === NodeType.Element) {
            this.up();
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.dummy = function() {
        return this;
      };
      XMLDocumentCB2.prototype.node = function(name, attributes, text) {
        var ref1;
        if (name == null) {
          throw new Error("Missing node name.");
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        }
        this.openCurrent();
        name = getValue(name);
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }
        this.currentNode = new XMLElement(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function(name, attributes, text) {
        var child, i, len, oldValidationFlag, ref1, root;
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          this.dtdElement.apply(this, arguments);
        } else {
          if (Array.isArray(name) || isObject(name) || isFunction(name)) {
            oldValidationFlag = this.options.noValidation;
            this.options.noValidation = true;
            root = new XMLDocument(this.options).element("TEMP_ROOT");
            root.element(name);
            this.options.noValidation = oldValidationFlag;
            ref1 = root.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
          } else {
            this.node(name, attributes, text);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        }
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName))
              continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (this.options.keepNullAttributes && value == null) {
            this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
          } else if (value != null) {
            this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function(value) {
        var node;
        this.openCurrent();
        node = new XMLText(this, value);
        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function(value) {
        var node;
        this.openCurrent();
        node = new XMLCData(this, value);
        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.comment = function(value) {
        var node;
        this.openCurrent();
        node = new XMLComment(this, value);
        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.raw = function(value) {
        var node;
        this.openCurrent();
        node = new XMLRaw(this, value);
        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function(target, value) {
        var i, insTarget, insValue, len, node;
        this.openCurrent();
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (i = 0, len = target.length; i < len; i++) {
            insTarget = target[i];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          node = new XMLProcessingInstruction(this, target, value);
          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
        var node;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }
        node = new XMLDeclaration(this, version, encoding, standalone);
        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
        this.openCurrent();
        if (root == null) {
          throw new Error("Missing root node name.");
        }
        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }
        this.currentNode = new XMLDocType(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement(this, name, value);
        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.entity = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, false, name, value);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, true, name, value);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.notation = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation(this, name, value);
        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function() {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function(node) {
        var att, chunk, name, ref1;
        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
            this.root = node;
          }
          chunk = "";
          if (node.type === NodeType.Element) {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name))
                continue;
              att = ref1[name];
              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
            }
            chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              chunk += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children) {
              chunk += " [";
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.CloseTag;
              chunk += ">";
            }
            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.onData(chunk, this.currentLevel);
          return node.isOpen = true;
        }
      };
      XMLDocumentCB2.prototype.closeNode = function(node) {
        var chunk;
        if (!node.isClosed) {
          chunk = "";
          this.writerOptions.state = WriterState.CloseTag;
          if (node.type === NodeType.Element) {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          } else {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.writerOptions.state = WriterState.None;
          this.onData(chunk, this.currentLevel);
          return node.isClosed = true;
        }
      };
      XMLDocumentCB2.prototype.onData = function(chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function() {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function(name) {
        if (name == null) {
          return "";
        } else {
          return "node: <" + name + ">";
        }
      };
      XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLDocumentCB2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.att = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocumentCB2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocumentCB2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      return XMLDocumentCB2;
    }();
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLWriterBase = require_XMLWriterBase();
    WriterState = require_WriterState();
    module2.exports = XMLStreamWriter = function(superClass) {
      extend(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream, options) {
        this.stream = stream;
        XMLStreamWriter2.__super__.constructor.call(this, options);
      }
      XMLStreamWriter2.prototype.endline = function(node, options, level) {
        if (node.isLastRootNode && options.state === WriterState.CloseTag) {
          return "";
        } else {
          return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
        }
      };
      XMLStreamWriter2.prototype.document = function(doc, options) {
        var child, i, j, k, len, len1, ref, ref1, results;
        ref = doc.children;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          child = ref[i];
          child.isLastRootNode = i === doc.children.length - 1;
        }
        options = this.filterOptions(options);
        ref1 = doc.children;
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          child = ref1[k];
          results.push(this.writeChildNode(child, options, 0));
        }
        return results;
      };
      XMLStreamWriter2.prototype.attribute = function(att, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
      };
      XMLStreamWriter2.prototype.cdata = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.comment = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.declaration = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.docType = function(node, options, level) {
        var child, j, len, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level));
        this.stream.write("<!DOCTYPE " + node.root().name);
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.children.length > 0) {
          this.stream.write(" [");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write("]");
        }
        options.state = WriterState.CloseTag;
        this.stream.write(options.spaceBeforeSlash + ">");
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level) + "<" + node.name);
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name))
            continue;
          att = ref[name];
          this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            this.stream.write(">");
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + "/>");
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          this.stream.write(">");
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          this.stream.write("</" + node.name + ">");
        } else {
          this.stream.write(">" + this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref1 = node.children;
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
        }
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.raw = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.text = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
      };
      return XMLStreamWriter2;
    }(XMLWriterBase);
  }).call(exports2);
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDocument = require_XMLDocument();
    XMLDocumentCB = require_XMLDocumentCB();
    XMLStringWriter = require_XMLStringWriter();
    XMLStreamWriter = require_XMLStreamWriter();
    NodeType = require_NodeType();
    WriterState = require_WriterState();
    module2.exports.create = function(name, xmldec, doctype, options) {
      var doc, root;
      if (name == null) {
        throw new Error("Root element needs a name.");
      }
      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument(options);
      root = doc.element(name);
      if (!options.headless) {
        doc.declaration(options);
        if (options.pubID != null || options.sysID != null) {
          doc.dtd(options);
        }
      }
      return root;
    };
    module2.exports.begin = function(options, onData, onEnd) {
      var ref1;
      if (isFunction(options)) {
        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
        options = {};
      }
      if (onData) {
        return new XMLDocumentCB(options, onData, onEnd);
      } else {
        return new XMLDocument(options);
      }
    };
    module2.exports.stringWriter = function(options) {
      return new XMLStringWriter(options);
    };
    module2.exports.streamWriter = function(stream, options) {
      return new XMLStreamWriter(stream, options);
    };
    module2.exports.implementation = new XMLDOMImplementation();
    module2.exports.nodeType = NodeType;
    module2.exports.writerState = WriterState;
  }).call(exports2);
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS((exports2) => {
  (function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = require_lib();
    defaults = require_defaults().defaults;
    requiresCDATA = function(entry) {
      return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    };
    wrapCDATA = function(entry) {
      return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
      return entry.replace("]]>", "]]]]><![CDATA[>");
    };
    exports2.Builder = function() {
      function Builder(opts) {
        var key, ref, value;
        this.options = {};
        ref = defaults["0.2"];
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value = ref[key];
          this.options[key] = value;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value = opts[key];
          this.options[key] = value;
        }
      }
      Builder.prototype.buildObject = function(rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
          rootName = Object.keys(rootObj)[0];
          rootObj = rootObj[rootName];
        } else {
          rootName = this.options.rootName;
        }
        render = function(_this) {
          return function(element, obj) {
            var attr, child, entry, index, key, value;
            if (typeof obj !== "object") {
              if (_this.options.cdata && requiresCDATA(obj)) {
                element.raw(wrapCDATA(obj));
              } else {
                element.txt(obj);
              }
            } else if (Array.isArray(obj)) {
              for (index in obj) {
                if (!hasProp.call(obj, index))
                  continue;
                child = obj[index];
                for (key in child) {
                  entry = child[key];
                  element = render(element.ele(key), entry).up();
                }
              }
            } else {
              for (key in obj) {
                if (!hasProp.call(obj, key))
                  continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === "object") {
                    for (attr in child) {
                      value = child[attr];
                      element = element.att(attr, value);
                    }
                  }
                } else if (key === charkey) {
                  if (_this.options.cdata && requiresCDATA(child)) {
                    element = element.raw(wrapCDATA(child));
                  } else {
                    element = element.txt(child);
                  }
                } else if (Array.isArray(child)) {
                  for (index in child) {
                    if (!hasProp.call(child, index))
                      continue;
                    entry = child[index];
                    if (typeof entry === "string") {
                      if (_this.options.cdata && requiresCDATA(entry)) {
                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                      } else {
                        element = element.ele(key, entry).up();
                      }
                    } else {
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === "object") {
                  element = render(element.ele(key), child).up();
                } else {
                  if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                    element = element.ele(key).raw(wrapCDATA(child)).up();
                  } else {
                    if (child == null) {
                      child = "";
                    }
                    element = element.ele(key, child.toString()).up();
                  }
                }
              }
            }
            return element;
          };
        }(this);
        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        });
        return render(rootElement, rootObj).end(this.options.renderOpts);
      };
      return Builder;
    }();
  }).call(exports2);
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports2) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o)
          if (o.hasOwnProperty(i))
            a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = {xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE};
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = {name: parser.tagName, attributes: {}};
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return {prefix, local};
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", {prefix: p, uri: n});
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c)) {
            } else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS((exports2) => {
  (function() {
    "use strict";
    exports2.stripBOM = function(str) {
      if (str[0] === "\uFEFF") {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }).call(exports2);
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS((exports2) => {
  (function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports2.normalize = function(str) {
      return str.toLowerCase();
    };
    exports2.firstCharLowerCase = function(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports2.stripPrefix = function(str) {
      return str.replace(prefixMatch, "");
    };
    exports2.parseNumbers = function(str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }
      return str;
    };
    exports2.parseBooleans = function(str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === "true";
      }
      return str;
    };
  }).call(exports2);
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS((exports2) => {
  (function() {
    "use strict";
    var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    sax = require_sax();
    events = require("events");
    bom = require_bom();
    processors = require_processors();
    setImmediate = require("timers").setImmediate;
    defaults = require_defaults().defaults;
    isEmpty = function(thing) {
      return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors2, item, key) {
      var i, len, process2;
      for (i = 0, len = processors2.length; i < len; i++) {
        process2 = processors2[i];
        item = process2(item, key);
      }
      return item;
    };
    exports2.Parser = function(superClass) {
      extend(Parser, superClass);
      function Parser(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this);
        this.parseString = bind(this.parseString, this);
        this.reset = bind(this.reset, this);
        this.assignOrPush = bind(this.assignOrPush, this);
        this.processAsync = bind(this.processAsync, this);
        var key, ref, value;
        if (!(this instanceof exports2.Parser)) {
          return new exports2.Parser(opts);
        }
        this.options = {};
        ref = defaults["0.2"];
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value = ref[key];
          this.options[key] = value;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value = opts[key];
          this.options[key] = value;
        }
        if (this.options.xmlns) {
          this.options.xmlnskey = this.options.attrkey + "ns";
        }
        if (this.options.normalizeTags) {
          if (!this.options.tagNameProcessors) {
            this.options.tagNameProcessors = [];
          }
          this.options.tagNameProcessors.unshift(processors.normalize);
        }
        this.reset();
      }
      Parser.prototype.processAsync = function() {
        var chunk, err;
        try {
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = "";
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate(this.processAsync);
          }
        } catch (error1) {
          err = error1;
          if (!this.saxParser.errThrown) {
            this.saxParser.errThrown = true;
            return this.emit(err);
          }
        }
      };
      Parser.prototype.assignOrPush = function(obj, key, newValue) {
        if (!(key in obj)) {
          if (!this.options.explicitArray) {
            return obj[key] = newValue;
          } else {
            return obj[key] = [newValue];
          }
        } else {
          if (!(obj[key] instanceof Array)) {
            obj[key] = [obj[key]];
          }
          return obj[key].push(newValue);
        }
      };
      Parser.prototype.reset = function() {
        var attrkey, charkey, ontext, stack;
        this.removeAllListeners();
        this.saxParser = sax.parser(this.options.strict, {
          trim: false,
          normalize: false,
          xmlns: this.options.xmlns
        });
        this.saxParser.errThrown = false;
        this.saxParser.onerror = function(_this) {
          return function(error) {
            _this.saxParser.resume();
            if (!_this.saxParser.errThrown) {
              _this.saxParser.errThrown = true;
              return _this.emit("error", error);
            }
          };
        }(this);
        this.saxParser.onend = function(_this) {
          return function() {
            if (!_this.saxParser.ended) {
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        this.saxParser.ended = false;
        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
        this.resultObject = null;
        stack = [];
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        this.saxParser.onopentag = function(_this) {
          return function(node) {
            var key, newValue, obj, processedKey, ref;
            obj = {};
            obj[charkey] = "";
            if (!_this.options.ignoreAttrs) {
              ref = node.attributes;
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                  obj[attrkey] = {};
                }
                newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                if (_this.options.mergeAttrs) {
                  _this.assignOrPush(obj, processedKey, newValue);
                } else {
                  obj[attrkey][processedKey] = newValue;
                }
              }
            }
            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
            if (_this.options.xmlns) {
              obj[_this.options.xmlnskey] = {
                uri: node.uri,
                local: node.local
              };
            }
            return stack.push(obj);
          };
        }(this);
        this.saxParser.onclosetag = function(_this) {
          return function() {
            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
            obj = stack.pop();
            nodeName = obj["#name"];
            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
              delete obj["#name"];
            }
            if (obj.cdata === true) {
              cdata = obj.cdata;
              delete obj.cdata;
            }
            s = stack[stack.length - 1];
            if (obj[charkey].match(/^\s*$/) && !cdata) {
              emptyStr = obj[charkey];
              delete obj[charkey];
            } else {
              if (_this.options.trim) {
                obj[charkey] = obj[charkey].trim();
              }
              if (_this.options.normalize) {
                obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
              }
              obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
            if (isEmpty(obj)) {
              obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
            }
            if (_this.options.validator != null) {
              xpath = "/" + function() {
                var i, len, results;
                results = [];
                for (i = 0, len = stack.length; i < len; i++) {
                  node = stack[i];
                  results.push(node["#name"]);
                }
                return results;
              }().concat(nodeName).join("/");
              (function() {
                var err;
                try {
                  return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (error1) {
                  err = error1;
                  return _this.emit("error", err);
                }
              })();
            }
            if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
              if (!_this.options.preserveChildrenOrder) {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              } else if (s) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                objClone = {};
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  objClone[key] = obj[key];
                }
                s[_this.options.childkey].push(objClone);
                delete obj["#name"];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
            }
            if (stack.length > 0) {
              return _this.assignOrPush(s, nodeName, obj);
            } else {
              if (_this.options.explicitRoot) {
                old = obj;
                obj = {};
                obj[nodeName] = old;
              }
              _this.resultObject = obj;
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        ontext = function(_this) {
          return function(text) {
            var charChild, s;
            s = stack[stack.length - 1];
            if (s) {
              s[charkey] += text;
              if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                charChild = {
                  "#name": "__text__"
                };
                charChild[charkey] = text;
                if (_this.options.normalize) {
                  charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                }
                s[_this.options.childkey].push(charChild);
              }
              return s;
            }
          };
        }(this);
        this.saxParser.ontext = ontext;
        return this.saxParser.oncdata = function(_this) {
          return function(text) {
            var s;
            s = ontext(text);
            if (s) {
              return s.cdata = true;
            }
          };
        }(this);
      };
      Parser.prototype.parseString = function(str, cb) {
        var err;
        if (cb != null && typeof cb === "function") {
          this.on("end", function(result) {
            this.reset();
            return cb(null, result);
          });
          this.on("error", function(err2) {
            this.reset();
            return cb(err2);
          });
        }
        try {
          str = str.toString();
          if (str.trim() === "") {
            this.emit("end", null);
            return true;
          }
          str = bom.stripBOM(str);
          if (this.options.async) {
            this.remaining = str;
            setImmediate(this.processAsync);
            return this.saxParser;
          }
          return this.saxParser.write(str).close();
        } catch (error1) {
          err = error1;
          if (!(this.saxParser.errThrown || this.saxParser.ended)) {
            this.emit("error", err);
            return this.saxParser.errThrown = true;
          } else if (this.saxParser.ended) {
            throw err;
          }
        }
      };
      Parser.prototype.parseStringPromise = function(str) {
        return new Promise(function(_this) {
          return function(resolve, reject) {
            return _this.parseString(str, function(err, value) {
              if (err) {
                return reject(err);
              } else {
                return resolve(value);
              }
            });
          };
        }(this));
      };
      return Parser;
    }(events);
    exports2.parseString = function(str, a, b) {
      var cb, options, parser;
      if (b != null) {
        if (typeof b === "function") {
          cb = b;
        }
        if (typeof a === "object") {
          options = a;
        }
      } else {
        if (typeof a === "function") {
          cb = a;
        }
        options = {};
      }
      parser = new exports2.Parser(options);
      return parser.parseString(str, cb);
    };
    exports2.parseStringPromise = function(str, a) {
      var options, parser;
      if (typeof a === "object") {
        options = a;
      }
      parser = new exports2.Parser(options);
      return parser.parseStringPromise(str);
    };
  }).call(exports2);
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS((exports2) => {
  (function() {
    "use strict";
    var builder, defaults, parser, processors, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = require_defaults();
    builder = require_builder();
    parser = require_parser3();
    processors = require_processors();
    exports2.defaults = defaults.defaults;
    exports2.processors = processors;
    exports2.ValidationError = function(superClass) {
      extend(ValidationError, superClass);
      function ValidationError(message) {
        this.message = message;
      }
      return ValidationError;
    }(Error);
    exports2.Builder = builder.Builder;
    exports2.Parser = parser.Parser;
    exports2.parseString = parser.parseString;
    exports2.parseStringPromise = parser.parseStringPromise;
  }).call(exports2);
});

// node_modules/parse-bmfont-xml/lib/parse-attribs.js
var require_parse_attribs = __commonJS((exports2, module2) => {
  var GLYPH_DESIGNER_ERROR = "chasrset";
  module2.exports = function parseAttributes(obj) {
    if (GLYPH_DESIGNER_ERROR in obj) {
      obj["charset"] = obj[GLYPH_DESIGNER_ERROR];
      delete obj[GLYPH_DESIGNER_ERROR];
    }
    for (var k in obj) {
      if (k === "face" || k === "charset")
        continue;
      else if (k === "padding" || k === "spacing")
        obj[k] = parseIntList(obj[k]);
      else
        obj[k] = parseInt(obj[k], 10);
    }
    return obj;
  };
  function parseIntList(data) {
    return data.split(",").map(function(val) {
      return parseInt(val, 10);
    });
  }
});

// node_modules/parse-bmfont-xml/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  var xml2js = require_xml2js();
  var parseAttributes = require_parse_attribs();
  module2.exports = function parseBMFontXML(data) {
    data = data.toString().trim();
    var output = {
      pages: [],
      chars: [],
      kernings: []
    };
    xml2js.parseString(data, function(err, result) {
      if (err)
        throw err;
      if (!result.font)
        throw "XML bitmap font doesn't have <font> root";
      result = result.font;
      output.common = parseAttributes(result.common[0].$);
      output.info = parseAttributes(result.info[0].$);
      for (var i = 0; i < result.pages.length; i++) {
        var p = result.pages[i].page[0].$;
        if (typeof p.id === "undefined")
          throw new Error("malformed file -- needs page id=N");
        if (typeof p.file !== "string")
          throw new Error('malformed file -- needs page file="path"');
        output.pages[parseInt(p.id, 10)] = p.file;
      }
      if (result.chars) {
        var chrArray = result.chars[0]["char"] || [];
        for (var i = 0; i < chrArray.length; i++) {
          output.chars.push(parseAttributes(chrArray[i].$));
        }
      }
      if (result.kernings) {
        var kernArray = result.kernings[0]["kerning"] || [];
        for (var i = 0; i < kernArray.length; i++) {
          output.kernings.push(parseAttributes(kernArray[i].$));
        }
      }
    });
    return output;
  };
});

// node_modules/parse-bmfont-binary/index.js
var require_parse_bmfont_binary = __commonJS((exports2, module2) => {
  var HEADER = [66, 77, 70];
  module2.exports = function readBMFontBinary(buf) {
    if (buf.length < 6)
      throw new Error("invalid buffer length for BMFont");
    var header = HEADER.every(function(byte, i2) {
      return buf.readUInt8(i2) === byte;
    });
    if (!header)
      throw new Error("BMFont missing BMF byte header");
    var i = 3;
    var vers = buf.readUInt8(i++);
    if (vers > 3)
      throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
    var target = {kernings: [], chars: []};
    for (var b = 0; b < 5; b++)
      i += readBlock(target, buf, i);
    return target;
  };
  function readBlock(target, buf, i) {
    if (i > buf.length - 1)
      return 0;
    var blockID = buf.readUInt8(i++);
    var blockSize = buf.readInt32LE(i);
    i += 4;
    switch (blockID) {
      case 1:
        target.info = readInfo(buf, i);
        break;
      case 2:
        target.common = readCommon(buf, i);
        break;
      case 3:
        target.pages = readPages(buf, i, blockSize);
        break;
      case 4:
        target.chars = readChars(buf, i, blockSize);
        break;
      case 5:
        target.kernings = readKernings(buf, i, blockSize);
        break;
    }
    return 5 + blockSize;
  }
  function readInfo(buf, i) {
    var info = {};
    info.size = buf.readInt16LE(i);
    var bitField = buf.readUInt8(i + 2);
    info.smooth = bitField >> 7 & 1;
    info.unicode = bitField >> 6 & 1;
    info.italic = bitField >> 5 & 1;
    info.bold = bitField >> 4 & 1;
    if (bitField >> 3 & 1)
      info.fixedHeight = 1;
    info.charset = buf.readUInt8(i + 3) || "";
    info.stretchH = buf.readUInt16LE(i + 4);
    info.aa = buf.readUInt8(i + 6);
    info.padding = [
      buf.readInt8(i + 7),
      buf.readInt8(i + 8),
      buf.readInt8(i + 9),
      buf.readInt8(i + 10)
    ];
    info.spacing = [
      buf.readInt8(i + 11),
      buf.readInt8(i + 12)
    ];
    info.outline = buf.readUInt8(i + 13);
    info.face = readStringNT(buf, i + 14);
    return info;
  }
  function readCommon(buf, i) {
    var common = {};
    common.lineHeight = buf.readUInt16LE(i);
    common.base = buf.readUInt16LE(i + 2);
    common.scaleW = buf.readUInt16LE(i + 4);
    common.scaleH = buf.readUInt16LE(i + 6);
    common.pages = buf.readUInt16LE(i + 8);
    var bitField = buf.readUInt8(i + 10);
    common.packed = 0;
    common.alphaChnl = buf.readUInt8(i + 11);
    common.redChnl = buf.readUInt8(i + 12);
    common.greenChnl = buf.readUInt8(i + 13);
    common.blueChnl = buf.readUInt8(i + 14);
    return common;
  }
  function readPages(buf, i, size) {
    var pages = [];
    var text = readNameNT(buf, i);
    var len = text.length + 1;
    var count = size / len;
    for (var c = 0; c < count; c++) {
      pages[c] = buf.slice(i, i + text.length).toString("utf8");
      i += len;
    }
    return pages;
  }
  function readChars(buf, i, blockSize) {
    var chars = [];
    var count = blockSize / 20;
    for (var c = 0; c < count; c++) {
      var char = {};
      var off = c * 20;
      char.id = buf.readUInt32LE(i + 0 + off);
      char.x = buf.readUInt16LE(i + 4 + off);
      char.y = buf.readUInt16LE(i + 6 + off);
      char.width = buf.readUInt16LE(i + 8 + off);
      char.height = buf.readUInt16LE(i + 10 + off);
      char.xoffset = buf.readInt16LE(i + 12 + off);
      char.yoffset = buf.readInt16LE(i + 14 + off);
      char.xadvance = buf.readInt16LE(i + 16 + off);
      char.page = buf.readUInt8(i + 18 + off);
      char.chnl = buf.readUInt8(i + 19 + off);
      chars[c] = char;
    }
    return chars;
  }
  function readKernings(buf, i, blockSize) {
    var kernings = [];
    var count = blockSize / 10;
    for (var c = 0; c < count; c++) {
      var kern = {};
      var off = c * 10;
      kern.first = buf.readUInt32LE(i + 0 + off);
      kern.second = buf.readUInt32LE(i + 4 + off);
      kern.amount = buf.readInt16LE(i + 8 + off);
      kernings[c] = kern;
    }
    return kernings;
  }
  function readNameNT(buf, offset) {
    var pos = offset;
    for (; pos < buf.length; pos++) {
      if (buf[pos] === 0)
        break;
    }
    return buf.slice(offset, pos);
  }
  function readStringNT(buf, offset) {
    return readNameNT(buf, offset).toString("utf8");
  }
});

// node_modules/mime/types.json
var require_types = __commonJS((exports2, module2) => {
  module2.exports = {"application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"]};
});

// node_modules/mime/mime.js
var require_mime2 = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  function Mime() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  }
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0; i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
        }
        this.types[exts[i]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path2, fallback) {
    var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime();
  mime.define(require_types());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module2.exports = mime;
});

// node_modules/buffer-equal/index.js
var require_buffer_equal = __commonJS((exports2, module2) => {
  var Buffer2 = require("buffer").Buffer;
  module2.exports = function(a, b) {
    if (!Buffer2.isBuffer(a))
      return void 0;
    if (!Buffer2.isBuffer(b))
      return void 0;
    if (typeof a.equals === "function")
      return a.equals(b);
    if (a.length !== b.length)
      return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  };
});

// node_modules/load-bmfont/lib/is-binary.js
var require_is_binary = __commonJS((exports2, module2) => {
  var equal = require_buffer_equal();
  var HEADER = Buffer.from([66, 77, 70, 3]);
  module2.exports = function(buf) {
    if (typeof buf === "string")
      return buf.substring(0, 3) === "BMF";
    return buf.length > 4 && equal(buf.slice(0, 4), HEADER);
  };
});

// node_modules/load-bmfont/index.js
var require_load_bmfont = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var url = require("url");
  var path = require("path");
  var request = require_phin_compiled();
  var parseASCII = require_parse_bmfont_ascii();
  var parseXML = require_lib2();
  var readBinary = require_parse_bmfont_binary();
  var mime = require_mime2();
  var noop = function() {
  };
  var isBinary = require_is_binary();
  function parseFont(file, data, cb) {
    var result, binary;
    if (isBinary(data)) {
      if (typeof data === "string")
        data = Buffer.from(data, "binary");
      binary = true;
    } else
      data = data.toString().trim();
    try {
      if (binary)
        result = readBinary(data);
      else if (/json/.test(mime.lookup(file)) || data.charAt(0) === "{")
        result = JSON.parse(data);
      else if (/xml/.test(mime.lookup(file)) || data.charAt(0) === "<")
        result = parseXML(data);
      else
        result = parseASCII(data);
    } catch (e) {
      cb(e);
      cb = noop;
    }
    cb(null, result);
  }
  module2.exports = function loadFont(opt, cb) {
    cb = typeof cb === "function" ? cb : noop;
    if (typeof opt === "string")
      opt = {uri: opt, url: opt};
    else if (!opt)
      opt = {};
    var file = opt.uri || opt.url;
    function handleData(err, data) {
      if (err)
        return cb(err);
      parseFont(file, data.body || data, cb);
    }
    if (url.parse(file).host) {
      request(opt, handleData);
    } else {
      fs.readFile(file, opt, handleData);
    }
  };
});

// node_modules/@jimp/plugin-print/dist/measure-text.js
var require_measure_text = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.measureText = measureText;
  exports2.measureTextHeight = measureTextHeight;
  function measureText(font, text) {
    var x = 0;
    for (var i = 0; i < text.length; i++) {
      if (font.chars[text[i]]) {
        var kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;
        x += (font.chars[text[i]].xadvance || 0) + kerning;
      }
    }
    return x;
  }
  function measureTextHeight(font, text, maxWidth) {
    var words = text.split(" ");
    var line = "";
    var textTotalHeight = font.common.lineHeight;
    for (var n = 0; n < words.length; n++) {
      var testLine = line + words[n] + " ";
      var testWidth = measureText(font, testLine);
      if (testWidth > maxWidth && n > 0) {
        textTotalHeight += font.common.lineHeight;
        line = words[n] + " ";
      } else {
        line = testLine;
      }
    }
    return textTotalHeight;
  }
});

// node_modules/@jimp/plugin-print/dist/index.js
var require_dist25 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
  var _path = _interopRequireDefault(require("path"));
  var _loadBmfont = _interopRequireDefault(require_load_bmfont());
  var _utils = require_dist();
  var _measureText = require_measure_text();
  function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
    if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {
      return 0;
    }
    if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {
      return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;
    }
    return maxWidth - (0, _measureText.measureText)(font, line);
  }
  function drawCharacter(image, font, x, y, _char) {
    if (_char.width > 0 && _char.height > 0) {
      var characterPage = font.pages[_char.page];
      image.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);
    }
    return image;
  }
  function printText(font, x, y, text, defaultCharWidth) {
    for (var i = 0; i < text.length; i++) {
      var _char2 = void 0;
      if (font.chars[text[i]]) {
        _char2 = text[i];
      } else if (/\s/.test(text[i])) {
        _char2 = "";
      } else {
        _char2 = "?";
      }
      var fontChar = font.chars[_char2] || {};
      var fontKerning = font.kernings[_char2];
      drawCharacter(this, font, x, y, fontChar || {});
      var kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;
      x += kerning + (fontChar.xadvance || defaultCharWidth);
    }
  }
  function splitLines(font, text, maxWidth) {
    var words = text.split(" ");
    var lines = [];
    var currentLine = [];
    var longestLine = 0;
    words.forEach(function(word) {
      var line = [].concat((0, _toConsumableArray2["default"])(currentLine), [word]).join(" ");
      var length = (0, _measureText.measureText)(font, line);
      if (length <= maxWidth) {
        if (length > longestLine) {
          longestLine = length;
        }
        currentLine.push(word);
      } else {
        lines.push(currentLine);
        currentLine = [word];
      }
    });
    lines.push(currentLine);
    return {
      lines,
      longestLine
    };
  }
  function loadPages(Jimp2, dir2, pages) {
    var newPages = pages.map(function(page) {
      return Jimp2.read(dir2 + "/" + page);
    });
    return Promise.all(newPages);
  }
  var dir = process.env.DIRNAME || "".concat(__dirname, "/../");
  var _default = function _default2() {
    return {
      constants: {
        measureText: _measureText.measureText,
        measureTextHeight: _measureText.measureTextHeight,
        FONT_SANS_8_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
        FONT_SANS_10_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
        FONT_SANS_12_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
        FONT_SANS_14_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
        FONT_SANS_16_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
        FONT_SANS_32_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
        FONT_SANS_64_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
        FONT_SANS_128_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
        FONT_SANS_8_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
        FONT_SANS_16_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
        FONT_SANS_32_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
        FONT_SANS_64_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
        FONT_SANS_128_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
        loadFont: function loadFont(file, cb) {
          var _this = this;
          if (typeof file !== "string")
            return _utils.throwError.call(this, "file must be a string", cb);
          return new Promise(function(resolve, reject) {
            cb = cb || function(err, font) {
              if (err)
                reject(err);
              else
                resolve(font);
            };
            (0, _loadBmfont["default"])(file, function(err, font) {
              var chars = {};
              var kernings = {};
              if (err) {
                return _utils.throwError.call(_this, err, cb);
              }
              for (var i = 0; i < font.chars.length; i++) {
                chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];
              }
              for (var _i = 0; _i < font.kernings.length; _i++) {
                var firstString = String.fromCharCode(font.kernings[_i].first);
                kernings[firstString] = kernings[firstString] || {};
                kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
              }
              loadPages(_this, _path["default"].dirname(file), font.pages).then(function(pages) {
                cb(null, {
                  chars,
                  kernings,
                  pages,
                  common: font.common,
                  info: font.info
                });
              });
            });
          });
        }
      },
      class: {
        print: function print(font, x, y, text, maxWidth, maxHeight, cb) {
          var _this2 = this;
          if (typeof maxWidth === "function" && typeof cb === "undefined") {
            cb = maxWidth;
            maxWidth = Infinity;
          }
          if (typeof maxWidth === "undefined") {
            maxWidth = Infinity;
          }
          if (typeof maxHeight === "function" && typeof cb === "undefined") {
            cb = maxHeight;
            maxHeight = Infinity;
          }
          if (typeof maxHeight === "undefined") {
            maxHeight = Infinity;
          }
          if ((0, _typeof2["default"])(font) !== "object") {
            return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
          }
          if (typeof x !== "number" || typeof y !== "number" || typeof maxWidth !== "number") {
            return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
          }
          if (typeof maxWidth !== "number") {
            return _utils.throwError.call(this, "maxWidth must be a number", cb);
          }
          if (typeof maxHeight !== "number") {
            return _utils.throwError.call(this, "maxHeight must be a number", cb);
          }
          var alignmentX;
          var alignmentY;
          if ((0, _typeof2["default"])(text) === "object" && text.text !== null && text.text !== void 0) {
            alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
            alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
            var _text = text;
            text = _text.text;
          } else {
            alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
            alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
            text = text.toString();
          }
          if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
            y += maxHeight - (0, _measureText.measureTextHeight)(font, text, maxWidth);
          } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
            y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text, maxWidth) / 2;
          }
          var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;
          var _splitLines = splitLines(font, text, maxWidth), lines = _splitLines.lines, longestLine = _splitLines.longestLine;
          lines.forEach(function(line) {
            var lineString = line.join(" ");
            var alignmentWidth = xOffsetBasedOnAlignment(_this2.constructor, font, lineString, maxWidth, alignmentX);
            printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth);
            y += font.common.lineHeight;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this, {
              x: x + longestLine,
              y
            });
          }
          return this;
        }
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-resize/dist/modules/resize.js
var require_resize = __commonJS((exports2, module2) => {
  "use strict";
  function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
    this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
    this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
    this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
    this.colorChannels = blendAlpha ? 4 : 3;
    this.interpolationPass = Boolean(interpolationPass);
    this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
    };
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
    this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
    this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
    this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
    this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
    this.initialize();
  }
  Resize.prototype.initialize = function() {
    if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
      this.configurePasses();
    } else {
      throw new Error("Invalid settings specified for the resizer.");
    }
  };
  Resize.prototype.configurePasses = function() {
    if (this.widthOriginal === this.targetWidth) {
      this.resizeWidth = this.bypassResizer;
    } else {
      this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
      if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
        this.initializeFirstPassBuffers(true);
        this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
      } else {
        this.initializeFirstPassBuffers(false);
        this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
      }
    }
    if (this.heightOriginal === this.targetHeight) {
      this.resizeHeight = this.bypassResizer;
    } else {
      this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
      if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
        this.initializeSecondPassBuffers(true);
        this.resizeHeight = this.resizeHeightInterpolated;
      } else {
        this.initializeSecondPassBuffers(false);
        this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
      }
    }
  };
  Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
    var channelsNum = fourthChannel ? 4 : 3;
    var ratioWeight = this.ratioWeightWidthPass;
    var outputBuffer = this.widthBuffer;
    var weight = 0;
    var finalOffset = 0;
    var pixelOffset = 0;
    var firstWeight = 0;
    var secondWeight = 0;
    var targetPosition;
    for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
      for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
        outputBuffer[finalOffset] = buffer[pixelOffset];
        outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
        outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
        if (fourthChannel)
          outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
      }
    }
    weight -= 1 / 3;
    var interpolationWidthSourceReadStop;
    for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
      secondWeight = weight % 1;
      firstWeight = 1 - secondWeight;
      for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
        outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
        outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
        outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
        if (fourthChannel)
          outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
      }
    }
    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
      for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
        outputBuffer[finalOffset] = buffer[pixelOffset];
        outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
        outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
        if (fourthChannel)
          outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
      }
    }
    return outputBuffer;
  };
  Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
    var channelsNum = fourthChannel ? 4 : 3;
    var ratioWeight = this.ratioWeightWidthPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
    var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
    var output = this.outputWidthWorkBench;
    var outputBuffer = this.widthBuffer;
    var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var line = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var multiplier = 1;
    var r = 0;
    var g = 0;
    var b = 0;
    var a = 0;
    do {
      for (line = 0; line < this.originalHeightMultipliedByChannels; ) {
        output[line++] = 0;
        output[line++] = 0;
        output[line++] = 0;
        if (fourthChannel) {
          output[line++] = 0;
          trustworthyColorsCount[line / channelsNum - 1] = 0;
        }
      }
      weight = ratioWeight;
      do {
        amountToNext = 1 + actualPosition - currentPosition;
        multiplier = Math.min(weight, amountToNext);
        for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
          r = buffer[pixelOffset];
          g = buffer[++pixelOffset];
          b = buffer[++pixelOffset];
          a = fourthChannel ? buffer[++pixelOffset] : 255;
          output[line++] += (a ? r : 0) * multiplier;
          output[line++] += (a ? g : 0) * multiplier;
          output[line++] += (a ? b : 0) * multiplier;
          if (fourthChannel) {
            output[line++] += a * multiplier;
            trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
          }
        }
        if (weight >= amountToNext) {
          actualPosition += channelsNum;
          currentPosition = actualPosition;
          weight -= amountToNext;
        } else {
          currentPosition += weight;
          break;
        }
      } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
      for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
        weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
        multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
        outputBuffer[pixelOffset] = output[line++] * multiplier;
        outputBuffer[++pixelOffset] = output[line++] * multiplier;
        outputBuffer[++pixelOffset] = output[line++] * multiplier;
        if (fourthChannel)
          outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
      }
      outputOffset += channelsNum;
    } while (outputOffset < this.targetWidthMultipliedByChannels);
    return outputBuffer;
  };
  Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
    var ratioWeight = this.ratioWeightHeightPass;
    var ratioWeightDivisor = 1 / ratioWeight;
    var output = this.outputHeightWorkBench;
    var outputBuffer = this.heightBuffer;
    var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
    var weight = 0;
    var amountToNext = 0;
    var actualPosition = 0;
    var currentPosition = 0;
    var pixelOffset = 0;
    var outputOffset = 0;
    var caret = 0;
    var multiplier = 1;
    var r = 0;
    var g = 0;
    var b = 0;
    var a = 0;
    do {
      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
        output[pixelOffset++] = 0;
        output[pixelOffset++] = 0;
        output[pixelOffset++] = 0;
        if (fourthChannel) {
          output[pixelOffset++] = 0;
          trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
        }
      }
      weight = ratioWeight;
      do {
        amountToNext = 1 + actualPosition - currentPosition;
        multiplier = Math.min(weight, amountToNext);
        caret = actualPosition;
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          r = buffer[caret++];
          g = buffer[caret++];
          b = buffer[caret++];
          a = fourthChannel ? buffer[caret++] : 255;
          output[pixelOffset++] += (a ? r : 0) * multiplier;
          output[pixelOffset++] += (a ? g : 0) * multiplier;
          output[pixelOffset++] += (a ? b : 0) * multiplier;
          if (fourthChannel) {
            output[pixelOffset++] += a * multiplier;
            trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
          }
        }
        if (weight >= amountToNext) {
          actualPosition = caret;
          currentPosition = actualPosition;
          weight -= amountToNext;
        } else {
          currentPosition += weight;
          break;
        }
      } while (weight > 0 && actualPosition < this.widthPassResultSize);
      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
        weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
        multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
        if (fourthChannel) {
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
        }
      }
    } while (outputOffset < this.finalResultSize);
    return outputBuffer;
  };
  Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, false);
  };
  Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, true);
  };
  Resize.prototype.resizeWidthRGB = function(buffer) {
    return this._resizeWidthRGBChannels(buffer, false);
  };
  Resize.prototype.resizeWidthRGBA = function(buffer) {
    return this._resizeWidthRGBChannels(buffer, true);
  };
  Resize.prototype.resizeHeightInterpolated = function(buffer) {
    var ratioWeight = this.ratioWeightHeightPass;
    var outputBuffer = this.heightBuffer;
    var weight = 0;
    var finalOffset = 0;
    var pixelOffset = 0;
    var pixelOffsetAccumulated = 0;
    var pixelOffsetAccumulated2 = 0;
    var firstWeight = 0;
    var secondWeight = 0;
    var interpolationHeightSourceReadStop;
    for (; weight < 1 / 3; weight += ratioWeight) {
      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
        outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
      }
    }
    weight -= 1 / 3;
    for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
      secondWeight = weight % 1;
      firstWeight = 1 - secondWeight;
      pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
      pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
        outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
      }
    }
    while (finalOffset < this.finalResultSize) {
      for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
        outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
      }
    }
    return outputBuffer;
  };
  Resize.prototype.resizeHeightRGB = function(buffer) {
    return this._resizeHeightRGBChannels(buffer, false);
  };
  Resize.prototype.resizeHeightRGBA = function(buffer) {
    return this._resizeHeightRGBChannels(buffer, true);
  };
  Resize.prototype.resize = function(buffer) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
  };
  Resize.prototype.bypassResizer = function(buffer) {
    return buffer;
  };
  Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
    if (!BILINEARAlgo) {
      this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
      if (this.colorChannels > 3) {
        this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
      }
    }
  };
  Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
    if (!BILINEARAlgo) {
      this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
      if (this.colorChannels > 3) {
        this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
      }
    }
  };
  Resize.prototype.generateFloatBuffer = function(bufferLength) {
    try {
      return new Float32Array(bufferLength);
    } catch (error) {
      return [];
    }
  };
  Resize.prototype.generateFloat64Buffer = function(bufferLength) {
    try {
      return new Float64Array(bufferLength);
    } catch (error) {
      return [];
    }
  };
  Resize.prototype.generateUint8Buffer = function(bufferLength) {
    try {
      return new Uint8Array(bufferLength);
    } catch (error) {
      return [];
    }
  };
  module2.exports = Resize;
});

// node_modules/@jimp/plugin-resize/dist/modules/resize2.js
var require_resize2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    nearestNeighbor: function nearestNeighbor(src, dst) {
      var wSrc = src.width;
      var hSrc = src.height;
      var wDst = dst.width;
      var hDst = dst.height;
      var bufSrc = src.data;
      var bufDst = dst.data;
      for (var i = 0; i < hDst; i++) {
        for (var j = 0; j < wDst; j++) {
          var posDst = (i * wDst + j) * 4;
          var iSrc = Math.floor(i * hSrc / hDst);
          var jSrc = Math.floor(j * wSrc / wDst);
          var posSrc = (iSrc * wSrc + jSrc) * 4;
          bufDst[posDst++] = bufSrc[posSrc++];
          bufDst[posDst++] = bufSrc[posSrc++];
          bufDst[posDst++] = bufSrc[posSrc++];
          bufDst[posDst++] = bufSrc[posSrc++];
        }
      }
    },
    bilinearInterpolation: function bilinearInterpolation(src, dst) {
      var wSrc = src.width;
      var hSrc = src.height;
      var wDst = dst.width;
      var hDst = dst.height;
      var bufSrc = src.data;
      var bufDst = dst.data;
      var interpolate = function interpolate2(k, kMin, vMin, kMax, vMax) {
        if (kMin === kMax) {
          return vMin;
        }
        return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
      };
      var assign = function assign2(pos, offset, x2, xMin2, xMax2, y2, yMin2, yMax2) {
        var posMin = (yMin2 * wSrc + xMin2) * 4 + offset;
        var posMax = (yMin2 * wSrc + xMax2) * 4 + offset;
        var vMin = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
        if (yMax2 === yMin2) {
          bufDst[pos + offset] = vMin;
        } else {
          posMin = (yMax2 * wSrc + xMin2) * 4 + offset;
          posMax = (yMax2 * wSrc + xMax2) * 4 + offset;
          var vMax = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
          bufDst[pos + offset] = interpolate(y2, yMin2, vMin, yMax2, vMax);
        }
      };
      for (var i = 0; i < hDst; i++) {
        for (var j = 0; j < wDst; j++) {
          var posDst = (i * wDst + j) * 4;
          var x = j * wSrc / wDst;
          var xMin = Math.floor(x);
          var xMax = Math.min(Math.ceil(x), wSrc - 1);
          var y = i * hSrc / hDst;
          var yMin = Math.floor(y);
          var yMax = Math.min(Math.ceil(y), hSrc - 1);
          assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
          assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
          assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
          assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
        }
      }
    },
    _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {
      var bufSrc = src.data;
      var bufDst = dst.data;
      var wSrc = src.width;
      var hSrc = src.height;
      var wDst = dst.width;
      var hDst = dst.height;
      var wM = Math.max(1, Math.floor(wSrc / wDst));
      var wDst2 = wDst * wM;
      var hM = Math.max(1, Math.floor(hSrc / hDst));
      var hDst2 = hDst * hM;
      var buf1 = Buffer.alloc(wDst2 * hSrc * 4);
      for (var i = 0; i < hSrc; i++) {
        for (var j = 0; j < wDst2; j++) {
          var x = j * (wSrc - 1) / wDst2;
          var xPos = Math.floor(x);
          var t = x - xPos;
          var srcPos = (i * wSrc + xPos) * 4;
          var buf1Pos = (i * wDst2 + j) * 4;
          for (var k = 0; k < 4; k++) {
            var kPos = srcPos + k;
            var x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
            var x1 = bufSrc[kPos];
            var x2 = bufSrc[kPos + 4];
            var x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
            buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
          }
        }
      }
      var buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
      for (var _i = 0; _i < hDst2; _i++) {
        for (var _j = 0; _j < wDst2; _j++) {
          var y = _i * (hSrc - 1) / hDst2;
          var yPos = Math.floor(y);
          var _t = y - yPos;
          var _buf1Pos = (yPos * wDst2 + _j) * 4;
          var buf2Pos = (_i * wDst2 + _j) * 4;
          for (var _k = 0; _k < 4; _k++) {
            var _kPos = _buf1Pos + _k;
            var y0 = yPos > 0 ? buf1[_kPos - wDst2 * 4] : 2 * buf1[_kPos] - buf1[_kPos + wDst2 * 4];
            var y1 = buf1[_kPos];
            var y2 = buf1[_kPos + wDst2 * 4];
            var y3 = yPos < hSrc - 2 ? buf1[_kPos + wDst2 * 8] : 2 * buf1[_kPos + wDst2 * 4] - buf1[_kPos];
            buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
          }
        }
      }
      var m = wM * hM;
      if (m > 1) {
        for (var _i2 = 0; _i2 < hDst; _i2++) {
          for (var _j2 = 0; _j2 < wDst; _j2++) {
            var r = 0;
            var g = 0;
            var b = 0;
            var a = 0;
            var realColors = 0;
            for (var _y = 0; _y < hM; _y++) {
              var _yPos = _i2 * hM + _y;
              for (var _x = 0; _x < wM; _x++) {
                var _xPos = _j2 * wM + _x;
                var xyPos = (_yPos * wDst2 + _xPos) * 4;
                var pixelAlpha = buf2[xyPos + 3];
                if (pixelAlpha) {
                  r += buf2[xyPos];
                  g += buf2[xyPos + 1];
                  b += buf2[xyPos + 2];
                  realColors++;
                }
                a += pixelAlpha;
              }
            }
            var pos = (_i2 * wDst + _j2) * 4;
            bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
            bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
            bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
            bufDst[pos + 3] = Math.round(a / m);
          }
        }
      } else {
        dst.data = buf2;
      }
    },
    bicubicInterpolation: function bicubicInterpolation(src, dst, options) {
      var interpolateCubic = function interpolateCubic2(x0, x1, x2, x3, t) {
        var a0 = x3 - x2 - x0 + x1;
        var a1 = x0 - x1 - a0;
        var a2 = x2 - x0;
        var a3 = x1;
        return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
      };
      return this._interpolate2D(src, dst, options, interpolateCubic);
    },
    hermiteInterpolation: function hermiteInterpolation(src, dst, options) {
      var interpolateHermite = function interpolateHermite2(x0, x1, x2, x3, t) {
        var c0 = x1;
        var c1 = 0.5 * (x2 - x0);
        var c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
        var c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
        return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
      };
      return this._interpolate2D(src, dst, options, interpolateHermite);
    },
    bezierInterpolation: function bezierInterpolation(src, dst, options) {
      var interpolateBezier = function interpolateBezier2(x0, x1, x2, x3, t) {
        var cp1 = x1 + (x2 - x0) / 4;
        var cp2 = x2 - (x3 - x1) / 4;
        var nt = 1 - t;
        var c0 = x1 * nt * nt * nt;
        var c1 = 3 * cp1 * nt * nt * t;
        var c2 = 3 * cp2 * nt * t * t;
        var c3 = x2 * t * t * t;
        return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
      };
      return this._interpolate2D(src, dst, options, interpolateBezier);
    }
  };
});

// node_modules/@jimp/plugin-resize/dist/index.js
var require_dist26 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _resize = _interopRequireDefault(require_resize());
  var _resize2 = _interopRequireDefault(require_resize2());
  var _default = function _default2() {
    return {
      constants: {
        RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
        RESIZE_BILINEAR: "bilinearInterpolation",
        RESIZE_BICUBIC: "bicubicInterpolation",
        RESIZE_HERMITE: "hermiteInterpolation",
        RESIZE_BEZIER: "bezierInterpolation"
      },
      class: {
        resize: function resize(w, h, mode, cb) {
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers", cb);
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
            return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
          }
          if (w === this.constructor.AUTO) {
            w = this.bitmap.width * (h / this.bitmap.height);
          }
          if (h === this.constructor.AUTO) {
            h = this.bitmap.height * (w / this.bitmap.width);
          }
          if (w < 0 || h < 0) {
            return _utils.throwError.call(this, "w and h must be positive numbers", cb);
          }
          w = Math.round(w);
          h = Math.round(h);
          if (typeof _resize2["default"][mode] === "function") {
            var dst = {
              data: Buffer.alloc(w * h * 4),
              width: w,
              height: h
            };
            _resize2["default"][mode](this.bitmap, dst);
            this.bitmap = dst;
          } else {
            var image = this;
            var resize2 = new _resize["default"](this.bitmap.width, this.bitmap.height, w, h, true, true, function(buffer) {
              image.bitmap.data = Buffer.from(buffer);
              image.bitmap.width = w;
              image.bitmap.height = h;
            });
            resize2.resize(this.bitmap.data);
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-rotate/dist/index.js
var require_dist27 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  function advancedRotate(deg, mode) {
    deg %= 360;
    var rad = deg * Math.PI / 180;
    var cosine = Math.cos(rad);
    var sine = Math.sin(rad);
    var w = this.bitmap.width;
    var h = this.bitmap.height;
    if (mode === true || typeof mode === "string") {
      w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
      h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;
      if (w % 2 !== 0) {
        w++;
      }
      if (h % 2 !== 0) {
        h++;
      }
      var c = this.cloneQuiet();
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x2, y2, idx) {
        this.bitmap.data.writeUInt32BE(this._background, idx);
      });
      var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
      this.resize(max, max, mode);
      this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
    }
    var bW = this.bitmap.width;
    var bH = this.bitmap.height;
    var dstBuffer = Buffer.alloc(this.bitmap.data.length);
    function createTranslationFunction(deltaX, deltaY) {
      return function(x2, y2) {
        return {
          x: x2 + deltaX,
          y: y2 + deltaY
        };
      };
    }
    var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
    var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
    for (var y = 1; y <= bH; y++) {
      for (var x = 1; x <= bW; x++) {
        var cartesian = translate2Cartesian(x, y);
        var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
        var dstIdx = bW * (y - 1) + x - 1 << 2;
        if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
          var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
          var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
          dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
        } else {
          dstBuffer.writeUInt32BE(this._background, dstIdx);
        }
      }
    }
    this.bitmap.data = dstBuffer;
    if (mode === true || typeof mode === "string") {
      var _x = bW / 2 - w / 2;
      var _y = bH / 2 - h / 2;
      this.crop(_x, _y, w, h);
    }
  }
  var _default = function _default2() {
    return {
      rotate: function rotate(deg, mode, cb) {
        if (typeof mode === "undefined" || mode === null) {
          mode = true;
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = true;
        }
        if (typeof deg !== "number") {
          return _utils.throwError.call(this, "deg must be a number", cb);
        }
        if (typeof mode !== "boolean" && typeof mode !== "string") {
          return _utils.throwError.call(this, "mode must be a boolean or a string", cb);
        }
        advancedRotate.call(this, deg, mode, cb);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-scale/dist/index.js
var require_dist28 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      scale: function scale(f, mode, cb) {
        if (typeof f !== "number") {
          return _utils.throwError.call(this, "f must be a number", cb);
        }
        if (f < 0) {
          return _utils.throwError.call(this, "f must be a positive number", cb);
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        var w = this.bitmap.width * f;
        var h = this.bitmap.height * f;
        this.resize(w, h, mode);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      scaleToFit: function scaleToFit(w, h, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
        this.scale(f, mode);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-shadow/dist/index.js
var require_dist29 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      shadow: function shadow() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        var _options = options, _options$opacity = _options.opacity, opacity = _options$opacity === void 0 ? 0.7 : _options$opacity, _options$size = _options.size, size = _options$size === void 0 ? 1.1 : _options$size, _options$x = _options.x, x = _options$x === void 0 ? -25 : _options$x, _options$y = _options.y, y = _options$y === void 0 ? 25 : _options$y, _options$blur = _options.blur, blur = _options$blur === void 0 ? 5 : _options$blur;
        var orig = this.clone();
        var shadow2 = this.clone();
        shadow2.scan(0, 0, shadow2.bitmap.width, shadow2.bitmap.height, function(x2, y2, idx) {
          shadow2.bitmap.data[idx] = 0;
          shadow2.bitmap.data[idx + 1] = 0;
          shadow2.bitmap.data[idx + 2] = 0;
          shadow2.bitmap.data[idx + 3] = shadow2.constructor.limit255(shadow2.bitmap.data[idx + 3] * opacity);
          _this.bitmap.data[idx] = 0;
          _this.bitmap.data[idx + 1] = 0;
          _this.bitmap.data[idx + 2] = 0;
          _this.bitmap.data[idx + 3] = 0;
        });
        shadow2.resize(shadow2.bitmap.width * size, shadow2.bitmap.height * size).blur(blur);
        this.composite(shadow2, x, y);
        this.composite(orig, 0, 0);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugin-threshold/dist/index.js
var require_dist30 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _utils = require_dist();
  var _default = function _default2() {
    return {
      threshold: function threshold(_ref, cb) {
        var _this = this;
        var max = _ref.max, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? 255 : _ref$replace, _ref$autoGreyscale = _ref.autoGreyscale, autoGreyscale = _ref$autoGreyscale === void 0 ? true : _ref$autoGreyscale;
        if (typeof max !== "number") {
          return _utils.throwError.call(this, "max must be a number", cb);
        }
        if (typeof replace !== "number") {
          return _utils.throwError.call(this, "replace must be a number", cb);
        }
        if (typeof autoGreyscale !== "boolean") {
          return _utils.throwError.call(this, "autoGreyscale must be a boolean", cb);
        }
        max = this.constructor.limit255(max);
        replace = this.constructor.limit255(replace);
        if (autoGreyscale) {
          this.greyscale();
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          var grey = _this.bitmap.data[idx] < max ? _this.bitmap.data[idx] : replace;
          _this.bitmap.data[idx] = grey;
          _this.bitmap.data[idx + 1] = grey;
          _this.bitmap.data[idx + 2] = grey;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    };
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/@jimp/plugins/dist/index.js
var require_dist31 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
  var _timm = require_timm();
  var _pluginBlit = _interopRequireDefault(require_dist10());
  var _pluginBlur = _interopRequireDefault(require_dist11());
  var _pluginCircle = _interopRequireDefault(require_dist12());
  var _pluginColor = _interopRequireDefault(require_dist13());
  var _pluginContain = _interopRequireDefault(require_dist14());
  var _pluginCover = _interopRequireDefault(require_dist15());
  var _pluginCrop = _interopRequireDefault(require_dist16());
  var _pluginDisplace = _interopRequireDefault(require_dist17());
  var _pluginDither = _interopRequireDefault(require_dist18());
  var _pluginFisheye = _interopRequireDefault(require_dist19());
  var _pluginFlip = _interopRequireDefault(require_dist20());
  var _pluginGaussian = _interopRequireDefault(require_dist21());
  var _pluginInvert = _interopRequireDefault(require_dist22());
  var _pluginMask = _interopRequireDefault(require_dist23());
  var _pluginNormalize = _interopRequireDefault(require_dist24());
  var _pluginPrint = _interopRequireDefault(require_dist25());
  var _pluginResize = _interopRequireDefault(require_dist26());
  var _pluginRotate = _interopRequireDefault(require_dist27());
  var _pluginScale = _interopRequireDefault(require_dist28());
  var _pluginShadow = _interopRequireDefault(require_dist29());
  var _pluginThreshold = _interopRequireDefault(require_dist30());
  var plugins = [_pluginBlit["default"], _pluginBlur["default"], _pluginCircle["default"], _pluginColor["default"], _pluginContain["default"], _pluginCover["default"], _pluginCrop["default"], _pluginDisplace["default"], _pluginDither["default"], _pluginFisheye["default"], _pluginFlip["default"], _pluginGaussian["default"], _pluginInvert["default"], _pluginMask["default"], _pluginNormalize["default"], _pluginPrint["default"], _pluginResize["default"], _pluginRotate["default"], _pluginScale["default"], _pluginShadow["default"], _pluginThreshold["default"]];
  var _default = function _default2(jimpEvChange) {
    var initializedPlugins = plugins.map(function(pluginModule) {
      var plugin = pluginModule(jimpEvChange) || {};
      if (!plugin["class"] && !plugin.constants) {
        plugin = {
          class: plugin
        };
      }
      return plugin;
    });
    return _timm.mergeDeep.apply(void 0, (0, _toConsumableArray2["default"])(initializedPlugins));
  };
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/jimp/dist/index.js
var require_dist32 = __commonJS((exports2, module2) => {
  "use strict";
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2["default"] = void 0;
  var _custom = _interopRequireDefault(require_dist3());
  var _types = _interopRequireDefault(require_dist9());
  var _plugins = _interopRequireDefault(require_dist31());
  var _default = (0, _custom["default"])({
    types: [_types["default"]],
    plugins: [_plugins["default"]]
  });
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = requiredArgs;
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = toDate;
  var _index = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function toDate(argument) {
    (0, _index.default)(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/compareAsc/index.js
var require_compareAsc = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = compareAsc;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarMonths/index.js
var require_differenceInCalendarMonths = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfDay/index.js
var require_endOfDay = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function endOfDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date = (0, _index.default)(dirtyDate);
    date.setHours(23, 59, 59, 999);
    return date;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfMonth/index.js
var require_endOfMonth = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function endOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date = (0, _index.default)(dirtyDate);
    var month = date.getMonth();
    date.setFullYear(date.getFullYear(), month + 1, 0);
    date.setHours(23, 59, 59, 999);
    return date;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isLastDayOfMonth/index.js
var require_isLastDayOfMonth = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isLastDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_endOfDay());
  var _index3 = _interopRequireDefault(require_endOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function isLastDayOfMonth(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date = (0, _index.default)(dirtyDate);
    return (0, _index2.default)(date).getTime() === (0, _index3.default)(date).getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInMonths/index.js
var require_differenceInMonths = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_isLastDayOfMonth());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index4.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
    var isLastMonthNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
    if ((0, _index5.default)((0, _index.default)(dirtyDateLeft)) && difference === 1 && (0, _index3.default)(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    var result = sign * (difference - isLastMonthNotFull);
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInMilliseconds/index.js
var require_differenceInMilliseconds = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInMilliseconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getTime() - dateRight.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInSeconds/index.js
var require_differenceInSeconds = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInSeconds;
  var _index = _interopRequireDefault(require_differenceInMilliseconds());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dirtyDateLeft, dirtyDateRight) / 1e3;
    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js
var require_formatDistance = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistance2;
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  function formatDistance2(token, count, options) {
    options = options || {};
    var result;
    if (typeof formatDistanceLocale[token] === "string") {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace("{{count}}", count);
    }
    if (options.addSuffix) {
      if (options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js
var require_buildFormatLongFn = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildFormatLongFn;
  function buildFormatLongFn(args) {
    return function(dirtyOptions) {
      var options = dirtyOptions || {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatLong/index.js
var require_formatLong = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(require_buildFormatLongFn());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: (0, _index.default)({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: (0, _index.default)({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: (0, _index.default)({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var _default = formatLong;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js
var require_formatRelative = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatRelative;
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js
var require_buildLocalizeFn = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildLocalizeFn;
  function buildLocalizeFn(args) {
    return function(dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/localize/index.js
var require_localize = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(require_buildLocalizeFn());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  function ordinalNumber(dirtyNumber, _dirtyOptions) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  }
  var localize = {
    ordinalNumber,
    era: (0, _index.default)({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: (0, _index.default)({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: (0, _index.default)({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: (0, _index.default)({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: (0, _index.default)({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var _default = localize;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js
var require_buildMatchPatternFn = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchPatternFn;
  function buildMatchPatternFn(args) {
    return function(dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult) {
        return null;
      }
      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value,
        rest: string.slice(matchedString.length)
      };
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildMatchFn/index.js
var require_buildMatchFn = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchFn;
  function buildMatchFn(args) {
    return function(dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options = dirtyOptions || {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var value;
      if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
        value = findIndex(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        });
      } else {
        value = findKey(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        });
      }
      value = args.valueCallback ? args.valueCallback(value) : value;
      value = options.valueCallback ? options.valueCallback(value) : value;
      return {
        value,
        rest: string.slice(matchedString.length)
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
  }
  function findIndex(array, predicate) {
    for (var key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/match/index.js
var require_match = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(require_buildMatchPatternFn());
  var _index2 = _interopRequireDefault(require_buildMatchFn());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: (0, _index.default)({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function(value) {
        return parseInt(value, 10);
      }
    }),
    era: (0, _index2.default)({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: (0, _index2.default)({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function(index) {
        return index + 1;
      }
    }),
    month: (0, _index2.default)({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: (0, _index2.default)({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: (0, _index2.default)({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var _default = match;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/index.js
var require_en_US = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(require_formatDistance());
  var _index2 = _interopRequireDefault(require_formatLong());
  var _index3 = _interopRequireDefault(require_formatRelative());
  var _index4 = _interopRequireDefault(require_localize());
  var _index5 = _interopRequireDefault(require_match());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var locale = {
    code: "en-US",
    formatDistance: _index.default,
    formatLong: _index2.default,
    formatRelative: _index3.default,
    localize: _index4.default,
    match: _index5.default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var _default = locale;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/assign/index.js
var require_assign = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = assign;
  function assign(target, dirtyObject) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    dirtyObject = dirtyObject || {};
    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        target[property] = dirtyObject[property];
      }
    }
    return target;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/cloneObject/index.js
var require_cloneObject = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = cloneObject;
  var _index = _interopRequireDefault(require_assign());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function cloneObject(dirtyObject) {
    return (0, _index.default)({}, dirtyObject);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js
var require_getTimezoneOffsetInMilliseconds = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getTimezoneOffsetInMilliseconds;
  var MILLISECONDS_IN_MINUTE = 6e4;
  function getDateMillisecondsPart(date) {
    return date.getTime() % MILLISECONDS_IN_MINUTE;
  }
  function getTimezoneOffsetInMilliseconds(dirtyDate) {
    var date = new Date(dirtyDate.getTime());
    var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
    date.setSeconds(0, 0);
    var hasNegativeUTCOffset = baseTimezoneOffset > 0;
    var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date);
    return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDistance/index.js
var require_formatDistance2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistance2;
  var _index = _interopRequireDefault(require_compareAsc());
  var _index2 = _interopRequireDefault(require_differenceInMonths());
  var _index3 = _interopRequireDefault(require_differenceInSeconds());
  var _index4 = _interopRequireDefault(require_en_US());
  var _index5 = _interopRequireDefault(require_toDate());
  var _index6 = _interopRequireDefault(require_cloneObject());
  var _index7 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index8 = _interopRequireDefault(require_requiredArgs());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var MINUTES_IN_DAY = 1440;
  var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
  var MINUTES_IN_MONTH = 43200;
  var MINUTES_IN_TWO_MONTHS = 86400;
  function formatDistance2(dirtyDate, dirtyBaseDate, dirtyOptions) {
    (0, _index8.default)(2, arguments);
    var options = dirtyOptions || {};
    var locale = options.locale || _index4.default;
    if (!locale.formatDistance) {
      throw new RangeError("locale must contain formatDistance property");
    }
    var comparison = (0, _index.default)(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = (0, _index6.default)(options);
    localizeOptions.addSuffix = Boolean(options.addSuffix);
    localizeOptions.comparison = comparison;
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = (0, _index5.default)(dirtyBaseDate);
      dateRight = (0, _index5.default)(dirtyDate);
    } else {
      dateLeft = (0, _index5.default)(dirtyDate);
      dateRight = (0, _index5.default)(dirtyBaseDate);
    }
    var seconds = (0, _index3.default)(dateRight, dateLeft);
    var offsetInSeconds = ((0, _index7.default)(dateRight) - (0, _index7.default)(dateLeft)) / 1e3;
    var minutes = Math.round((seconds - offsetInSeconds) / 60);
    var months;
    if (minutes < 2) {
      if (options.includeSeconds) {
        if (seconds < 5) {
          return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
        } else if (seconds < 10) {
          return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
        } else if (seconds < 20) {
          return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
        } else if (seconds < 40) {
          return locale.formatDistance("halfAMinute", null, localizeOptions);
        } else if (seconds < 60) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", 1, localizeOptions);
        }
      } else {
        if (minutes === 0) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", minutes, localizeOptions);
        }
      }
    } else if (minutes < 45) {
      return locale.formatDistance("xMinutes", minutes, localizeOptions);
    } else if (minutes < 90) {
      return locale.formatDistance("aboutXHours", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_DAY) {
      var hours = Math.round(minutes / 60);
      return locale.formatDistance("aboutXHours", hours, localizeOptions);
    } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
      return locale.formatDistance("xDays", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_MONTH) {
      var days = Math.round(minutes / MINUTES_IN_DAY);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (minutes < MINUTES_IN_TWO_MONTHS) {
      months = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = (0, _index2.default)(dateRight, dateLeft);
    if (months < 12) {
      var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
    } else {
      var monthsSinceStartOfYear = months % 12;
      var years = Math.floor(months / 12);
      if (monthsSinceStartOfYear < 3) {
        return locale.formatDistance("aboutXYears", years, localizeOptions);
      } else if (monthsSinceStartOfYear < 9) {
        return locale.formatDistance("overXYears", years, localizeOptions);
      } else {
        return locale.formatDistance("almostXYears", years + 1, localizeOptions);
      }
    }
  }
  module2.exports = exports2.default;
});

// lambda/ago.js
var Jimp = require_dist32();
var formatDistance = require_formatDistance2();
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
exports.handler = async (event) => {
  if (event.queryStringParameters.time === void 0) {
    return {
      statusCode: 400,
      body: "(\u30FB\u30FB;)\u309E"
    };
  }
  const mime = "image/png";
  const font = {chars: {"0": {id: 48, x: 20, y: 16, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "1": {id: 49, x: 438, y: 0, width: 6, height: 12, xoffset: 0, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "2": {id: 50, x: 444, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "3": {id: 51, x: 454, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "4": {id: 52, x: 464, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "5": {id: 53, x: 474, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "6": {id: 54, x: 484, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "7": {id: 55, x: 494, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "8": {id: 56, x: 0, y: 16, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "9": {id: 57, x: 10, y: 16, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "\0": {id: 0, x: 90, y: 16, width: 9, height: 12, xoffset: 0, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "\n": {id: 10, x: 0, y: 0, width: 0, height: 0, xoffset: -1, yoffset: 0, xadvance: 0, page: 0, chnl: 0}, " ": {id: 32, x: 0, y: 0, width: 0, height: 0, xoffset: -1, yoffset: 0, xadvance: 4, page: 0, chnl: 0}, "!": {id: 33, x: 504, y: 0, width: 4, height: 12, xoffset: 0, yoffset: 4, xadvance: 4, page: 0, chnl: 0}, '"': {id: 34, x: 284, y: 16, width: 7, height: 6, xoffset: -1, yoffset: 4, xadvance: 6, page: 0, chnl: 0}, "#": {id: 35, x: 66, y: 16, width: 11, height: 12, xoffset: -1, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, $: {id: 36, x: 69, y: 0, width: 10, height: 14, xoffset: -1, yoffset: 3, xadvance: 8, page: 0, chnl: 0}, "%": {id: 37, x: 53, y: 16, width: 13, height: 12, xoffset: -1, yoffset: 4, xadvance: 12, page: 0, chnl: 0}, "&": {id: 38, x: 77, y: 16, width: 13, height: 12, xoffset: -1, yoffset: 4, xadvance: 10, page: 0, chnl: 0}, "'": {id: 39, x: 291, y: 16, width: 5, height: 6, xoffset: -1, yoffset: 4, xadvance: 3, page: 0, chnl: 0}, "(": {id: 40, x: 31, y: 0, width: 6, height: 14, xoffset: -1, yoffset: 4, xadvance: 4, page: 0, chnl: 0}, ")": {id: 41, x: 37, y: 0, width: 6, height: 14, xoffset: -1, yoffset: 4, xadvance: 4, page: 0, chnl: 0}, "*": {id: 42, x: 274, y: 16, width: 10, height: 8, xoffset: -1, yoffset: 3, xadvance: 8, page: 0, chnl: 0}, "+": {id: 43, x: 234, y: 16, width: 10, height: 9, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, ",": {id: 44, x: 306, y: 16, width: 5, height: 5, xoffset: -1, yoffset: 12, xadvance: 3, page: 0, chnl: 0}, "-": {id: 45, x: 321, y: 16, width: 6, height: 4, xoffset: -1, yoffset: 10, xadvance: 5, page: 0, chnl: 0}, ".": {id: 46, x: 317, y: 16, width: 4, height: 4, xoffset: 0, yoffset: 12, xadvance: 4, page: 0, chnl: 0}, "/": {id: 47, x: 38, y: 16, width: 7, height: 12, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, ":": {id: 58, x: 230, y: 16, width: 4, height: 10, xoffset: 0, yoffset: 6, xadvance: 4, page: 0, chnl: 0}, ";": {id: 59, x: 99, y: 16, width: 5, height: 11, xoffset: -1, yoffset: 6, xadvance: 4, page: 0, chnl: 0}, "<": {id: 60, x: 244, y: 16, width: 10, height: 8, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, "=": {id: 61, x: 296, y: 16, width: 10, height: 6, xoffset: -1, yoffset: 7, xadvance: 8, page: 0, chnl: 0}, ">": {id: 62, x: 254, y: 16, width: 10, height: 8, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, "?": {id: 63, x: 30, y: 16, width: 8, height: 12, xoffset: -1, yoffset: 4, xadvance: 6, page: 0, chnl: 0}, "@": {id: 64, x: 171, y: 0, width: 14, height: 13, xoffset: -1, yoffset: 4, xadvance: 13, page: 0, chnl: 0}, A: {id: 65, x: 185, y: 0, width: 11, height: 12, xoffset: -1, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, B: {id: 66, x: 196, y: 0, width: 10, height: 12, xoffset: 0, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, C: {id: 67, x: 206, y: 0, width: 11, height: 12, xoffset: -1, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, D: {id: 68, x: 217, y: 0, width: 11, height: 12, xoffset: 0, yoffset: 4, xadvance: 10, page: 0, chnl: 0}, E: {id: 69, x: 228, y: 0, width: 8, height: 12, xoffset: 0, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, F: {id: 70, x: 236, y: 0, width: 8, height: 12, xoffset: 0, yoffset: 4, xadvance: 7, page: 0, chnl: 0}, G: {id: 71, x: 244, y: 0, width: 12, height: 12, xoffset: -1, yoffset: 4, xadvance: 10, page: 0, chnl: 0}, H: {id: 72, x: 256, y: 0, width: 10, height: 12, xoffset: 0, yoffset: 4, xadvance: 10, page: 0, chnl: 0}, I: {id: 73, x: 266, y: 0, width: 4, height: 12, xoffset: 0, yoffset: 4, xadvance: 4, page: 0, chnl: 0}, J: {id: 74, x: 10, y: 0, width: 8, height: 15, xoffset: -3, yoffset: 4, xadvance: 4, page: 0, chnl: 0}, K: {id: 75, x: 270, y: 0, width: 10, height: 12, xoffset: 0, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, L: {id: 76, x: 280, y: 0, width: 8, height: 12, xoffset: 0, yoffset: 4, xadvance: 7, page: 0, chnl: 0}, M: {id: 77, x: 288, y: 0, width: 13, height: 12, xoffset: 0, yoffset: 4, xadvance: 13, page: 0, chnl: 0}, N: {id: 78, x: 301, y: 0, width: 11, height: 12, xoffset: 0, yoffset: 4, xadvance: 11, page: 0, chnl: 0}, O: {id: 79, x: 312, y: 0, width: 13, height: 12, xoffset: -1, yoffset: 4, xadvance: 11, page: 0, chnl: 0}, P: {id: 80, x: 325, y: 0, width: 9, height: 12, xoffset: 0, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, Q: {id: 81, x: 18, y: 0, width: 13, height: 14, xoffset: -1, yoffset: 4, xadvance: 11, page: 0, chnl: 0}, R: {id: 82, x: 334, y: 0, width: 10, height: 12, xoffset: 0, yoffset: 4, xadvance: 9, page: 0, chnl: 0}, S: {id: 83, x: 344, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, T: {id: 84, x: 354, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, U: {id: 85, x: 364, y: 0, width: 10, height: 12, xoffset: 0, yoffset: 4, xadvance: 10, page: 0, chnl: 0}, V: {id: 86, x: 374, y: 0, width: 11, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, W: {id: 87, x: 385, y: 0, width: 15, height: 12, xoffset: -1, yoffset: 4, xadvance: 13, page: 0, chnl: 0}, X: {id: 88, x: 400, y: 0, width: 11, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, Y: {id: 89, x: 411, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, Z: {id: 90, x: 421, y: 0, width: 10, height: 12, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, "[": {id: 91, x: 43, y: 0, width: 6, height: 14, xoffset: 0, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, "\\": {id: 92, x: 45, y: 16, width: 8, height: 12, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, "]": {id: 93, x: 49, y: 0, width: 6, height: 14, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, "^": {id: 94, x: 264, y: 16, width: 10, height: 8, xoffset: -1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, _: {id: 95, x: 337, y: 16, width: 10, height: 3, xoffset: -2, yoffset: 15, xadvance: 6, page: 0, chnl: 0}, "`": {id: 96, x: 311, y: 16, width: 6, height: 4, xoffset: 1, yoffset: 4, xadvance: 8, page: 0, chnl: 0}, a: {id: 97, x: 104, y: 16, width: 9, height: 10, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, b: {id: 98, x: 79, y: 0, width: 9, height: 13, xoffset: 0, yoffset: 3, xadvance: 9, page: 0, chnl: 0}, c: {id: 99, x: 113, y: 16, width: 9, height: 10, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, d: {id: 100, x: 88, y: 0, width: 10, height: 13, xoffset: -1, yoffset: 3, xadvance: 9, page: 0, chnl: 0}, e: {id: 101, x: 122, y: 16, width: 10, height: 10, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, f: {id: 102, x: 98, y: 0, width: 8, height: 13, xoffset: -1, yoffset: 3, xadvance: 5, page: 0, chnl: 0}, g: {id: 103, x: 106, y: 0, width: 10, height: 13, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, h: {id: 104, x: 116, y: 0, width: 9, height: 13, xoffset: 0, yoffset: 3, xadvance: 9, page: 0, chnl: 0}, i: {id: 105, x: 125, y: 0, width: 4, height: 13, xoffset: 0, yoffset: 3, xadvance: 4, page: 0, chnl: 0}, j: {id: 106, x: 0, y: 0, width: 6, height: 16, xoffset: -2, yoffset: 3, xadvance: 4, page: 0, chnl: 0}, k: {id: 107, x: 129, y: 0, width: 9, height: 13, xoffset: 0, yoffset: 3, xadvance: 7, page: 0, chnl: 0}, l: {id: 108, x: 138, y: 0, width: 4, height: 13, xoffset: 0, yoffset: 3, xadvance: 4, page: 0, chnl: 0}, m: {id: 109, x: 132, y: 16, width: 13, height: 10, xoffset: 0, yoffset: 6, xadvance: 13, page: 0, chnl: 0}, n: {id: 110, x: 145, y: 16, width: 9, height: 10, xoffset: 0, yoffset: 6, xadvance: 9, page: 0, chnl: 0}, o: {id: 111, x: 154, y: 16, width: 10, height: 10, xoffset: -1, yoffset: 6, xadvance: 8, page: 0, chnl: 0}, p: {id: 112, x: 142, y: 0, width: 9, height: 13, xoffset: 0, yoffset: 6, xadvance: 9, page: 0, chnl: 0}, q: {id: 113, x: 151, y: 0, width: 10, height: 13, xoffset: -1, yoffset: 6, xadvance: 9, page: 0, chnl: 0}, r: {id: 114, x: 164, y: 16, width: 7, height: 10, xoffset: 0, yoffset: 6, xadvance: 6, page: 0, chnl: 0}, s: {id: 115, x: 171, y: 16, width: 9, height: 10, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, t: {id: 116, x: 431, y: 0, width: 7, height: 12, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, u: {id: 117, x: 180, y: 16, width: 9, height: 10, xoffset: 0, yoffset: 6, xadvance: 9, page: 0, chnl: 0}, v: {id: 118, x: 189, y: 16, width: 10, height: 10, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, w: {id: 119, x: 199, y: 16, width: 13, height: 10, xoffset: -1, yoffset: 6, xadvance: 11, page: 0, chnl: 0}, x: {id: 120, x: 212, y: 16, width: 10, height: 10, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, y: {id: 121, x: 161, y: 0, width: 10, height: 13, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, z: {id: 122, x: 222, y: 16, width: 8, height: 10, xoffset: -1, yoffset: 6, xadvance: 7, page: 0, chnl: 0}, "{": {id: 123, x: 55, y: 0, width: 7, height: 14, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, "|": {id: 124, x: 6, y: 0, width: 4, height: 16, xoffset: 2, yoffset: 3, xadvance: 8, page: 0, chnl: 0}, "}": {id: 125, x: 62, y: 0, width: 7, height: 14, xoffset: -1, yoffset: 4, xadvance: 5, page: 0, chnl: 0}, "~": {id: 126, x: 327, y: 16, width: 10, height: 4, xoffset: -1, yoffset: 8, xadvance: 8, page: 0, chnl: 0}}, kernings: {".": {Q: -1, G: -1, T: -1, C: -1, Y: -1, O: -1, V: -1, W: -1}, ",": {C: -1, O: -1, Q: -1, T: -1, Y: -1, W: -1, V: -1, G: -1}, A: {W: -1, J: 2, "'": -1, T: -1, '"': -1, V: -1, Y: -1}, T: {g: -1, n: -1, r: -1, s: -1, m: -1, c: -1, d: -1, e: -1, u: -1, o: -1, ".": -1, a: -1, ",": -1, q: -1, A: -1, p: -1, z: -1, "-": -1}, "(": {J: 1}, Y: {s: -1, d: -1, o: -1, e: -1, A: -1, a: -1, ",": -1, q: -1, ".": -1, c: -1}, w: {'"': 1, ",": -1, "'": 1, ".": -1}, V: {",": -1, A: -1, ".": -1}, B: {".": -1, ",": -1}, Q: {",": -1, ".": -1}, P: {".": -2, A: -1, ",": -2}, '"': {c: -1, e: -1, A: -1, o: -1, a: -1, q: -1, d: -1}, F: {",": -1, ".": -1}, L: {"'": -1, '"': -1}, f: {"'": 1, '"': 1}, "'": {e: -1, o: -1, A: -1, a: -1, d: -1, q: -1, c: -1}, O: {".": -1, ",": -1}, D: {".": -1, ",": -1}, y: {",": -1, "'": 1, ".": -1, '"': 1}, r: {'"': 1, "'": 1}, v: {".": -1, "'": 1, ",": -1, '"': 1}, "[": {J: 1}, W: {".": -1, A: -1, ",": -1}, "-": {T: -1}, "{": {J: 1}, E: {J: 1}}, pages: [{_events: {}, _eventsCount: 0, bitmap: {width: 512, height: 29, depth: 8, interlace: false, palette: false, color: true, alpha: true, bpp: 4, colorType: 6, data: {type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 247, 0, 0, 0, 171, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 191, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 203, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 183, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 203, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 155, 0, 0, 0, 151, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 99, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 20, 0, 0, 0, 87, 0, 0, 0, 127, 0, 0, 0, 115, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 127, 0, 0, 0, 119, 0, 0, 0, 32, 0, 0, 0, 79, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 143, 0, 0, 0, 211, 0, 0, 0, 223, 0, 0, 0, 219, 0, 0, 0, 163, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 247, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 227, 0, 0, 0, 215, 0, 0, 0, 151, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 171, 0, 0, 0, 247, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 203, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 235, 0, 0, 0, 215, 0, 0, 0, 151, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 151, 0, 0, 0, 235, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 239, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 219, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 223, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 195, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 247, 0, 0, 0, 171, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 251, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 199, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 215, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 231, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 199, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 163, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 107, 0, 0, 0, 227, 0, 0, 0, 231, 0, 0, 0, 243, 0, 0, 0, 171, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 143, 0, 0, 0, 235, 0, 0, 0, 227, 0, 0, 0, 247, 0, 0, 0, 183, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 199, 0, 0, 0, 239, 0, 0, 0, 223, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 251, 0, 0, 0, 119, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 155, 0, 0, 0, 223, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 135, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 103, 0, 0, 0, 239, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 159, 0, 0, 0, 147, 0, 0, 0, 52, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 87, 0, 0, 0, 95, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 159, 0, 0, 0, 67, 0, 0, 0, 123, 0, 0, 0, 255, 0, 0, 0, 103, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 199, 0, 0, 0, 147, 0, 0, 0, 95, 0, 0, 0, 175, 0, 0, 0, 219, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 231, 0, 0, 0, 115, 0, 0, 0, 111, 0, 0, 0, 207, 0, 0, 0, 215, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 219, 0, 0, 0, 99, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 83, 0, 0, 0, 219, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 227, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 56, 0, 0, 0, 199, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 231, 0, 0, 0, 159, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 87, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 60, 0, 0, 0, 167, 0, 0, 0, 239, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 227, 0, 0, 0, 171, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 227, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 227, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 239, 0, 0, 0, 231, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 251, 0, 0, 0, 119, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 155, 0, 0, 0, 223, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 103, 0, 0, 0, 247, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 91, 0, 0, 0, 243, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 239, 0, 0, 0, 99, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 199, 0, 0, 0, 115, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 239, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 211, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 199, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 231, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 239, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 143, 0, 0, 0, 215, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 211, 0, 0, 0, 183, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 155, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 191, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 135, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 179, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 219, 0, 0, 0, 231, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 115, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 71, 0, 0, 0, 239, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 235, 0, 0, 0, 215, 0, 0, 0, 195, 0, 0, 0, 199, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 239, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 231, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 235, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 215, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 32, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 227, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 243, 0, 0, 0, 79, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 239, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 135, 0, 0, 0, 243, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 151, 0, 0, 0, 231, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 131, 0, 0, 0, 243, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 247, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 243, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 243, 0, 0, 0, 135, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 251, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 235, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 231, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 243, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 219, 0, 0, 0, 175, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 91, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 195, 0, 0, 0, 83, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 251, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 251, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 60, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 67, 0, 0, 0, 87, 0, 0, 0, 127, 0, 0, 0, 107, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 127, 0, 0, 0, 119, 0, 0, 0, 32, 0, 0, 0, 215, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 179, 0, 0, 0, 207, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 243, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 67, 0, 0, 0, 87, 0, 0, 0, 127, 0, 0, 0, 115, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 247, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 223, 0, 0, 0, 163, 0, 0, 0, 211, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 251, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 48, 0, 0, 0, 231, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 199, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 123, 0, 0, 0, 215, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 247, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 243, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 219, 0, 0, 0, 24, 0, 0, 0, 251, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 167, 0, 0, 0, 175, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 24, 0, 0, 0, 79, 0, 0, 0, 223, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 199, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 223, 0, 0, 0, 175, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 183, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 251, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 32, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 243, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 95, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 211, 0, 0, 0, 147, 0, 0, 0, 95, 0, 0, 0, 171, 0, 0, 0, 215, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 231, 0, 0, 0, 115, 0, 0, 0, 111, 0, 0, 0, 207, 0, 0, 0, 227, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 191, 0, 0, 0, 207, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 191, 0, 0, 0, 127, 0, 0, 0, 171, 0, 0, 0, 191, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 207, 0, 0, 0, 151, 0, 0, 0, 95, 0, 0, 0, 159, 0, 0, 0, 231, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 227, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 227, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 207, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 203, 0, 0, 0, 163, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 255, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 207, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 167, 0, 0, 0, 231, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 99, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 4, 0, 0, 0, 207, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 239, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 99, 0, 0, 0, 235, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 243, 0, 0, 0, 191, 0, 0, 0, 87, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 227, 0, 0, 0, 215, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 147, 0, 0, 0, 211, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 215, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 235, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 159, 0, 0, 0, 215, 0, 0, 0, 143, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 219, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 247, 0, 0, 0, 231, 0, 0, 0, 251, 0, 0, 0, 183, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 135, 0, 0, 0, 207, 0, 0, 0, 195, 0, 0, 0, 235, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 155, 0, 0, 0, 191, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 179, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 239, 0, 0, 0, 231, 0, 0, 0, 147, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 167, 0, 0, 0, 95, 0, 0, 0, 64, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 227, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 243, 0, 0, 0, 32, 0, 0, 0, 247, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 231, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 67, 0, 0, 0, 243, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 175, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 107, 0, 0, 0, 207, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 175, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 175, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 135, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 243, 0, 0, 0, 123, 0, 0, 0, 247, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 247, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 255, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 223, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 223, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 115, 0, 0, 0, 219, 0, 0, 0, 219, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 4, 0, 0, 0, 227, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 235, 0, 0, 0, 239, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 251, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 243, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 203, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 99, 0, 0, 0, 143, 0, 0, 0, 227, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 211, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 159, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 243, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 239, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 255, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 207, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 211, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 167, 0, 0, 0, 223, 0, 0, 0, 239, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 247, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 103, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 111, 0, 0, 0, 239, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 195, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 239, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 179, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 243, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 255, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 219, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 135, 0, 0, 0, 12, 0, 0, 0, 239, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 207, 0, 0, 0, 4, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 255, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 143, 0, 0, 0, 32, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 243, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 151, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 115, 0, 0, 0, 67, 0, 0, 0, 235, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 247, 0, 0, 0, 44, 0, 0, 0, 243, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 239, 0, 0, 0, 44, 0, 0, 0, 243, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 111, 0, 0, 0, 135, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 247, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 183, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 231, 0, 0, 0, 87, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 91, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 247, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 227, 0, 0, 0, 219, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 147, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 243, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 231, 0, 0, 0, 207, 0, 0, 0, 203, 0, 0, 0, 183, 0, 0, 0, 211, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 235, 0, 0, 0, 99, 0, 0, 0, 115, 0, 0, 0, 175, 0, 0, 0, 199, 0, 0, 0, 87, 0, 0, 0, 219, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 243, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 255, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 195, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 231, 0, 0, 0, 107, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 215, 0, 0, 0, 119, 0, 0, 0, 231, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 203, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 195, 0, 0, 0, 151, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 151, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 147, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 203, 0, 0, 0, 4, 0, 0, 0, 12, 0, 0, 0, 227, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 223, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 247, 0, 0, 0, 199, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 251, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 231, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 243, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 123, 0, 0, 0, 231, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 64, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 247, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 75, 0, 0, 0, 48, 0, 0, 0, 243, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 12, 0, 0, 0, 56, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 243, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 127, 0, 0, 0, 103, 0, 0, 0, 4, 0, 0, 0, 75, 0, 0, 0, 127, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 247, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 139, 0, 0, 0, 231, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 247, 0, 0, 0, 107, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 147, 0, 0, 0, 243, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 251, 0, 0, 0, 119, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 235, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 239, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 243, 0, 0, 0, 243, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 243, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 123, 0, 0, 0, 231, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 227, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 151, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 235, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 247, 0, 0, 0, 227, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 243, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 239, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 231, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 231, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 243, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 195, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 147, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 231, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 223, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 239, 0, 0, 0, 199, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 243, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 247, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 175, 0, 0, 0, 207, 0, 0, 0, 207, 0, 0, 0, 231, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 195, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 231, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 251, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 227, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 227, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 255, 0, 0, 0, 195, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 223, 0, 0, 0, 243, 0, 0, 0, 223, 0, 0, 0, 231, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 239, 0, 0, 0, 167, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 211, 0, 0, 0, 247, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 243, 0, 0, 0, 215, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 243, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 223, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 239, 0, 0, 0, 195, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 239, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 251, 0, 0, 0, 227, 0, 0, 0, 223, 0, 0, 0, 239, 0, 0, 0, 191, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 243, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 243, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 255, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 247, 0, 0, 0, 195, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 243, 0, 0, 0, 211, 0, 0, 0, 191, 0, 0, 0, 231, 0, 0, 0, 203, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 239, 0, 0, 0, 191, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 199, 0, 0, 0, 219, 0, 0, 0, 203, 0, 0, 0, 231, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 67, 0, 0, 0, 219, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 71, 0, 0, 0, 175, 0, 0, 0, 135, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 107, 0, 0, 0, 223, 0, 0, 0, 191, 0, 0, 0, 243, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 231, 0, 0, 0, 207, 0, 0, 0, 203, 0, 0, 0, 183, 0, 0, 0, 183, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 231, 0, 0, 0, 135, 0, 0, 0, 127, 0, 0, 0, 139, 0, 0, 0, 227, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 167, 0, 0, 0, 231, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 215, 0, 0, 0, 191, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 183, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 64, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 40, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 40, 0, 0, 0, 60, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 0, 0, 0, 44, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 52, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 40, 0, 0, 0, 56, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 36, 0, 0, 0, 60, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 48, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 135, 0, 0, 0, 243, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 239, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 235, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 231, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 207, 0, 0, 0, 191, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 191, 0, 0, 0, 239, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 235, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 231, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 56, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 48, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 91, 0, 0, 0, 95, 0, 0, 0, 83, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 91, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 79, 0, 0, 0, 79, 0, 0, 0, 52, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 151, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 95, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 95, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 159, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 215, 0, 0, 0, 231, 0, 0, 0, 235, 0, 0, 0, 199, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 207, 0, 0, 0, 235, 0, 0, 0, 239, 0, 0, 0, 151, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 195, 0, 0, 0, 239, 0, 0, 0, 243, 0, 0, 0, 167, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 231, 0, 0, 0, 255, 0, 0, 0, 251, 0, 0, 0, 171, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 203, 0, 0, 0, 211, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 159, 0, 0, 0, 235, 0, 0, 0, 235, 0, 0, 0, 203, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 87, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 123, 0, 0, 0, 127, 0, 0, 0, 99, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 20, 0, 0, 0, 91, 0, 0, 0, 127, 0, 0, 0, 107, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 115, 0, 0, 0, 127, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 16, 0, 0, 0, 87, 0, 0, 0, 127, 0, 0, 0, 119, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 123, 0, 0, 0, 127, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 16, 0, 0, 0, 75, 0, 0, 0, 127, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 115, 0, 0, 0, 127, 0, 0, 0, 115, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 127, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 143, 0, 0, 0, 223, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 127, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 239, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 155, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 191, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 151, 0, 0, 0, 191, 0, 0, 0, 143, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 227, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 179, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 151, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 179, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 207, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 227, 0, 0, 0, 12, 0, 0, 0, 4, 0, 0, 0, 187, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 167, 0, 0, 0, 107, 0, 0, 0, 123, 0, 0, 0, 243, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 243, 0, 0, 0, 139, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 227, 0, 0, 0, 115, 0, 0, 0, 115, 0, 0, 0, 227, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 199, 0, 0, 0, 135, 0, 0, 0, 103, 0, 0, 0, 203, 0, 0, 0, 183, 0, 0, 0, 207, 0, 0, 0, 119, 0, 0, 0, 107, 0, 0, 0, 231, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 199, 0, 0, 0, 151, 0, 0, 0, 95, 0, 0, 0, 159, 0, 0, 0, 239, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 231, 0, 0, 0, 123, 0, 0, 0, 107, 0, 0, 0, 203, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 143, 0, 0, 0, 195, 0, 0, 0, 127, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 239, 0, 0, 0, 131, 0, 0, 0, 95, 0, 0, 0, 139, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 255, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 231, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 235, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 207, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 143, 0, 0, 0, 211, 0, 0, 0, 107, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 119, 0, 0, 0, 215, 0, 0, 0, 127, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 175, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 255, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 103, 0, 0, 0, 64, 0, 0, 0, 127, 0, 0, 0, 223, 0, 0, 0, 255, 0, 0, 0, 199, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 243, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 255, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 247, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 243, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 239, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 239, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 239, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 231, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 239, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 159, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 247, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 227, 0, 0, 0, 16, 0, 0, 0, 191, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 235, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 175, 0, 0, 0, 155, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 143, 0, 0, 0, 207, 0, 0, 0, 95, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 111, 0, 0, 0, 211, 0, 0, 0, 127, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 219, 0, 0, 0, 16, 0, 0, 0, 191, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 103, 0, 0, 0, 32, 0, 0, 0, 171, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 155, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 175, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 255, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 215, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 183, 0, 0, 0, 8, 0, 0, 0, 219, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 223, 0, 0, 0, 231, 0, 0, 0, 243, 0, 0, 0, 223, 0, 0, 0, 231, 0, 0, 0, 243, 0, 0, 0, 223, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 223, 0, 0, 0, 115, 0, 0, 0, 111, 0, 0, 0, 231, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 87, 0, 0, 0, 95, 0, 0, 0, 175, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 247, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 251, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 95, 0, 0, 0, 119, 0, 0, 0, 255, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 215, 0, 0, 0, 179, 0, 0, 0, 71, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 235, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 251, 0, 0, 0, 12, 0, 0, 0, 36, 0, 0, 0, 235, 0, 0, 0, 40, 0, 0, 0, 235, 0, 0, 0, 4, 0, 0, 0, 64, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 223, 0, 0, 0, 195, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 207, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 207, 0, 0, 0, 195, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 223, 0, 0, 0, 151, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 171, 0, 0, 0, 211, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 175, 0, 0, 0, 195, 0, 0, 0, 247, 0, 0, 0, 219, 0, 0, 0, 191, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 191, 0, 0, 0, 223, 0, 0, 0, 231, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 247, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 199, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 139, 0, 0, 0, 123, 0, 0, 0, 131, 0, 0, 0, 151, 0, 0, 0, 207, 0, 0, 0, 211, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 255, 0, 0, 0, 223, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 183, 0, 0, 0, 199, 0, 0, 0, 131, 0, 0, 0, 95, 0, 0, 0, 175, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 239, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 127, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 107, 0, 0, 0, 211, 0, 0, 0, 219, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 75, 0, 0, 0, 123, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 60, 0, 0, 0, 131, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 255, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 83, 0, 0, 0, 195, 0, 0, 0, 195, 0, 0, 0, 87, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 103, 0, 0, 0, 207, 0, 0, 0, 179, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 215, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 187, 0, 0, 0, 219, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 219, 0, 0, 0, 107, 0, 0, 0, 163, 0, 0, 0, 223, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 231, 0, 0, 0, 163, 0, 0, 0, 187, 0, 0, 0, 159, 0, 0, 0, 255, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 227, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 175, 0, 0, 0, 219, 0, 0, 0, 64, 0, 0, 0, 215, 0, 0, 0, 52, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 227, 0, 0, 0, 111, 0, 0, 0, 243, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 219, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 255, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 255, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 255, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 235, 0, 0, 0, 24, 0, 0, 0, 243, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 143, 0, 0, 0, 199, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 135, 0, 0, 0, 139, 0, 0, 0, 199, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 227, 0, 0, 0, 103, 0, 0, 0, 231, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 227, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 167, 0, 0, 0, 227, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 231, 0, 0, 0, 151, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 243, 0, 0, 0, 48, 0, 0, 0, 159, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 243, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0, 239, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 64, 0, 0, 0, 36, 0, 0, 0, 36, 0, 0, 0, 247, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 12, 0, 0, 0, 151, 0, 0, 0, 103, 0, 0, 0, 79, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 0, 191, 0, 0, 0, 239, 0, 0, 0, 207, 0, 0, 0, 191, 0, 0, 0, 239, 0, 0, 0, 207, 0, 0, 0, 191, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 251, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 231, 0, 0, 0, 111, 0, 0, 0, 36, 0, 0, 0, 243, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 219, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 235, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 151, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 247, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 255, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 167, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 207, 0, 0, 0, 239, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 215, 0, 0, 0, 247, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 215, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 223, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 95, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 251, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 247, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 239, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 243, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 211, 0, 0, 0, 4, 0, 0, 0, 79, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 36, 0, 0, 0, 235, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 239, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 231, 0, 0, 0, 219, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 255, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 207, 0, 0, 0, 219, 0, 0, 0, 195, 0, 0, 0, 207, 0, 0, 0, 127, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 219, 0, 0, 0, 223, 0, 0, 0, 207, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 203, 0, 0, 0, 235, 0, 0, 0, 199, 0, 0, 0, 235, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 203, 0, 0, 0, 215, 0, 0, 0, 199, 0, 0, 0, 235, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 239, 0, 0, 0, 199, 0, 0, 0, 195, 0, 0, 0, 231, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 239, 0, 0, 0, 203, 0, 0, 0, 203, 0, 0, 0, 183, 0, 0, 0, 183, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 255, 0, 0, 0, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 247, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 215, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 251, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 243, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 247, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 239, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 139, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 251, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 203, 0, 0, 0, 251, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 52, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 60, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 48, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 48, 0, 0, 0, 48, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 239, 0, 0, 0, 195, 0, 0, 0, 199, 0, 0, 0, 231, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 191, 0, 0, 0, 207, 0, 0, 0, 219, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 215, 0, 0, 0, 211, 0, 0, 0, 223, 0, 0, 0, 203, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 255, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 175, 0, 0, 0, 223, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 247, 0, 0, 0, 223, 0, 0, 0, 227, 0, 0, 0, 235, 0, 0, 0, 115, 0, 0, 0, 40, 0, 0, 0, 231, 0, 0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 159, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 0, 0, 0, 44, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 60, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 52, 0, 0, 0, 40, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, gamma: 0}, _background: 0, _originalMime: "image/png", _exif: null, _rgba: true}], common: {lineHeight: 20, base: 15, scaleW: 512, scaleH: 512, pages: 1, packed: 0}, info: {face: "Open Sans Regular", size: 14, bold: 0, italic: 0, charset: "", unicode: 0, stretchH: 100, smooth: 1, aa: 1, padding: [1, 1, 1, 1], spacing: [-2, -2]}};
  const text = capitalize(formatDistance(new Date(), new Date(+event.queryStringParameters.time).getTime())) + " ago";
  const width = Jimp.measureText(font, text);
  const height = Jimp.measureTextHeight(font, text);
  const image = await Jimp.read(width, height + 3);
  image.color([{apply: "lighten", params: [45]}]);
  image.filterType(Jimp.PNG_FILTER_NONE);
  image.print(font, 0, 3, text);
  return {
    isBase64Encoded: true,
    statusCode: 200,
    headers: {
      "Content-Type": mime
    },
    body: (await image.getBase64Async(mime)).split(",", 2).pop()
  };
};
